"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PatternMatcher = void 0;
// MIT Â© 2017 azu
var nlcst_types_1 = require("nlcst-types");
var matcher_1 = require("./matcher");
var walk = require("estree-walker").walk;
var PatternMatcher = /** @class */ (function () {
    function PatternMatcher(args) {
        this.parser = args.parser;
    }
    /**
     * Return true If test is passed
     */
    PatternMatcher.prototype.test = function (text, patterns) {
        return this.match(text, patterns).length !== 0;
    };
    PatternMatcher.prototype.match = function (text, patterns) {
        if (typeof text !== "string") {
            throw new Error("Invalid Arguments: match(text: string, pattern: TagPattern)\n" +
                "matcher.match(text, matcher.tag`pattern`)");
        }
        var CST = this.parser.parse(text);
        var CSTResults = this.matchCST(CST, patterns);
        return CSTResults.map(function (node) {
            var firstNode = node.nodeList[0];
            var lastNode = node.nodeList[node.nodeList.length - 1];
            if (!firstNode || !lastNode) {
                return {
                    text: "",
                    position: node.position,
                    nodeList: node.nodeList
                };
            }
            return {
                text: text.slice(firstNode.position.start.offset, lastNode.position.end.offset),
                position: node.position,
                nodeList: node.nodeList
            };
        });
    };
    PatternMatcher.prototype.testCST = function (cst, patterns) {
        return this.matchCST(cst, patterns).length > 0;
    };
    PatternMatcher.prototype.matchCST = function (cst, patterns) {
        var allResults = [];
        walk(cst, {
            enter: function (node) {
                if ((0, nlcst_types_1.isSentence)(node)) {
                    var results = (0, matcher_1.match)(node.children, patterns);
                    allResults = allResults.concat(results);
                    this.skip();
                }
            }
        });
        return allResults;
    };
    /**
     * Template tag function.
     * Return pattern objects that are used for `matcher.match` method.
     */
    PatternMatcher.prototype.tag = function (strings) {
        var values = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            values[_i - 1] = arguments[_i];
        }
        if (!Array.isArray(strings)) {
            throw new Error("tag method is template tag function.\n" + 'For example matcher.tag`this is ${{ type: "WordNode" }}` .');
        }
        var replaceHolders = [];
        var createPlaceholder = function (result, value) {
            var DEFAULT_VALUE_LENGTH = 5;
            var length = value.length ? value.length : DEFAULT_VALUE_LENGTH;
            replaceHolders.push({
                start: result.length,
                length: length,
                value: value
            });
            if ((0, nlcst_types_1.isPunctuation)(value)) {
                return new Array(length + 1).join(".");
            }
            else if ((0, nlcst_types_1.isWhiteSpace)(value)) {
                return new Array(length + 1).join(" ");
            }
            else {
                var lastCharacter = result[result.length - 1];
                if (!lastCharacter) {
                    // other is Symbol
                    return new Array(length + 1).join("|");
                }
                if (lastCharacter === " ") {
                    return new Array(length + 1).join("|");
                }
                else if (lastCharacter === "|") {
                    return new Array(length + 1).join(" ");
                }
                else {
                    return new Array(length + 1).join("|");
                }
            }
        };
        var allString = strings.reduce(function (result, string, i) {
            var valueIndex = i - 1;
            var value = values[valueIndex];
            return "".concat(result).concat(createPlaceholder(result, value)).concat(string);
        });
        var AST = this.parser.parse(allString);
        walk(AST, {
            enter: function (node, parent) {
                if (!parent || !parent.children) {
                    return;
                }
                if ((0, nlcst_types_1.isParagraph)(node) || (0, nlcst_types_1.isSentence)(node)) {
                    return;
                }
                replaceHolders
                    .filter(function (replaceHolder) {
                    return (node.position.start.offset === replaceHolder.start &&
                        node.position.end.offset === replaceHolder.start + replaceHolder.length);
                })
                    .forEach(function (replaceHolder) {
                    var indexOf = parent.children.indexOf(node);
                    var actualNode = parent.children[indexOf];
                    var placeholderNode = replaceHolder.value;
                    parent.children[indexOf] = Object.assign({}, placeholderNode, {
                        position: actualNode.position
                    });
                });
            }
        });
        var section = AST.children[0].children[0];
        return section.children;
    };
    return PatternMatcher;
}());
exports.PatternMatcher = PatternMatcher;
//# sourceMappingURL=nlcst-pattern-match.js.map