{"version":3,"sources":["../src/textlint-rule-prefer-tari-tari.js"],"names":["japaneseParser","StringSource","require","nlcstToString","動詞","type","data","pos","pos_detail_1","たり","surface_form","する","basic_form","report","Syntax","context","RuleError","Paragraph","node","ready","then","matcher","parser","TARI_SURU","tag","TARI","VERB","source","text","toString","CST","parse","children","length","sentences","isSameNode","resultsA","resultsB","some","resultB","index","resultA","forEach","tariResults","matchCST","sentence","tariSuruResults","suru","afterSuru","find","firstToken","nodeList","suruFirstToken","prevSuruNode","indexOf","prevIsNotTari","position","start","offset","originalIndexFromIndex","module","exports","linter","fixer"],"mappings":"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","file":"textlint-rule-prefer-tari-tari.js","sourcesContent":["// MIT © 2017 azu\n\"use strict\";\nimport { JapaneseParser } from \"nlcst-parse-japanese\";\nimport { match, PatternMatcher } from \"nlcst-pattern-match\";\n\nconst japaneseParser = new JapaneseParser();\nconst StringSource = require(\"textlint-util-to-string\");\nconst nlcstToString = require(\"nlcst-to-string\");\n// definition\nconst 動詞 = {\n    type: \"WordNode\",\n    data: {\n        pos: \"動詞\",\n        pos_detail_1: [\"自立\", \"非自立\"]\n    }\n};\nconst たり = {\n    type: \"WordNode\",\n    data: {\n        pos: \"助詞\",\n        surface_form: [\"だり\", \"たり\"]\n    }\n};\nconst する = {\n    type: \"WordNode\",\n    data: {\n        basic_form: \"する\"\n    }\n};\nconst report = context => {\n    const { Syntax, RuleError, report } = context;\n    return {\n        [Syntax.Paragraph](node) {\n            return japaneseParser.ready().then(() => {\n                const matcher = new PatternMatcher({\n                    parser: japaneseParser\n                });\n                const TARI_SURU = matcher.tag`${動詞}${たり}${する}`;\n                const TARI = matcher.tag`${動詞}${たり}`;\n                const VERB = matcher.tag`${動詞}`;\n                const source = new StringSource(node);\n                const text = source.toString();\n                const CST = japaneseParser.parse(text);\n                // Ignore empty Paragraph. Ex) '<p></p>'\n                if (typeof CST.children === \"undefined\" || CST.children.length == 0) {\n                    return;\n                }\n                const sentences = CST.children[0].children;\n                const isSameNode = (resultsA, resultsB) => {\n                    return resultsA.some(resultA => {\n                        return resultsB.some(resultB => {\n                            return resultB.index === resultA.index;\n                        });\n                    });\n                };\n                sentences.forEach(sentence => {\n                    const tariResults = matcher.matchCST(sentence, TARI);\n                    const tariSuruResults = matcher.matchCST(sentence, TARI_SURU);\n                    // `${動詞}${たり}` かつ `${動詞}${たり}${する}` の場合は除外\n                    if (isSameNode(tariResults, tariSuruResults)) {\n                        return;\n                    }\n                    if (tariResults.length === 1) {\n                        const suru = matcher.matchCST(sentence, VERB);\n                        const afterSuru = suru.find(suru => {\n                            const firstToken = tariResults[0].nodeList[0];\n                            const suruFirstToken = suru.nodeList[0];\n                            const prevSuruNode = sentence.children[sentence.children.indexOf(suruFirstToken) - 1];\n                            // 逃げ\"たり\"しない のようなパターン\n                            const prevIsNotTari = prevSuruNode && nlcstToString(prevSuruNode) !== \"たり\";\n                            // 最初の\"たり\"より後ろ\n                            return (\n                                prevIsNotTari &&\n                                suruFirstToken.position.start.offset > firstToken.position.start.offset &&\n                                // not たり\n                                match(suru.nodeList, TARI)\n                            );\n                        });\n                        if (!afterSuru) {\n                            return;\n                        }\n                        // report\n                        // console.log(afterSuru.nodeList);\n                        report(\n                            node,\n                            new RuleError(\n                                `例示・並列・対表現において、片方の動詞が「〜たり」表現な場合は、もう片方の動詞も「〜たり」とします。`,\n                                {\n                                    index: source.originalIndexFromIndex(afterSuru.position.index)\n                                }\n                            )\n                        );\n                    }\n                });\n            });\n        }\n    };\n};\nmodule.exports = {\n    linter: report,\n    fixer: report\n};\n"]}