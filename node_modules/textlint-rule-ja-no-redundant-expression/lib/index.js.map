{"version":3,"sources":["../src/index.ts"],"names":["replaceAll","text","from","to","split","join","replaceTokenWith","matcherToken","actualToken","specialTo","surface_form","tokensToString","tokens","map","token","isTokensAllowed","allows","length","matchedText","allowsMatchResults","createExpected","expected","matcherTokens","skipped","actualTokens","resultText","actualTokenIndex","index","_capture","ExpectedType","STOP_REPLACE","createMessage","id","forEach","reporter","context","options","Syntax","RuleError","fixer","DefaultOptions","allowNodeTypes","BlockQuote","Link","ReferenceDef","Code","dictOptions","enabledDictionaryList","Dictionary","filter","dict","dictOption","disabled","matchAll","skipNodeTypes","ignoreNodeTypes","report","Paragraph","node","source","StringSource","toString","then","currentTokens","matchResults","matchResult","isAllowed","firstToken","lastToken","firstWordIndex","originalIndexFromIndex","Math","max","word_position","lastWordIndex","message","hasFixableResult","wordLength","fix","replaceTextRange","linter"],"mappings":"AAAA;AACA;;;;;;;AACA;;AACA;;AACA;;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMA,UAAU,GAAG,CAACC,IAAD,EAAeC,IAAf,EAAyCC,EAAzC,KAAgE;AAC/E,MAAI,CAACD,IAAL,EAAW;AACP,WAAOD,IAAP;AACH;;AACD,SAAOA,IAAI,CAACG,KAAL,CAAWF,IAAX,EAAiBG,IAAjB,CAAsBF,EAAtB,CAAP;AACH,CALD;;AAOA,IAAMG,gBAAgB,GAAG,CAACC,YAAD,EAAoBC,WAApB,EAAgDC,SAAhD,KAAsE;AAC3F,MAAIF,YAAY,CAACE,SAAD,CAAhB,EAA6B;AACzB,WAAOF,YAAY,CAACE,SAAD,CAAZ,CAAwBD,WAAxB,CAAP;AACH;;AACD,SAAOA,WAAW,CAACE,YAAnB;AACH,CALD;AAOA;AACA;AACA;AACA;AACA;;;AACA,IAAMC,cAAc,GAAIC,MAAD,IAA6B;AAChD,SAAOA,MAAM,CAACC,GAAP,CAAYC,KAAD,IAAWA,KAAK,CAACJ,YAA5B,EAA0CL,IAA1C,CAA+C,EAA/C,CAAP;AACH,CAFD;AAIA;AACA;AACA;AACA;AACA;;;AACA,IAAMU,eAAe,GAAG,CAACH,MAAD,EAA0BI,MAA1B,KAA+C;AACnE,MAAIA,MAAM,CAACC,MAAP,KAAkB,CAAtB,EAAyB;AACrB,WAAO,KAAP;AACH;;AACD,MAAMC,WAAW,GAAGP,cAAc,CAACC,MAAD,CAAlC;AACA,MAAMO,kBAAkB,GAAG,wCAAcD,WAAd,EAA2BF,MAA3B,CAA3B;AACA,SAAOG,kBAAkB,CAACF,MAAnB,GAA4B,CAAnC;AACH,CAPD;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMG,cAAc,GAAG,UAUF;AAAA,MAVG;AACpBC,IAAAA,QADoB;AAEpBC,IAAAA,aAFoB;AAGpBC,IAAAA,OAHoB;AAIpBC,IAAAA;AAJoB,GAUH;;AACjB,MAAI,CAACH,QAAL,EAAe;AACX,WAAO,IAAP;AACH;;AACD,MAAII,UAAU,GAAGJ,QAAjB;AACA,MAAIK,gBAAgB,GAAG,CAAvB;;AACA,OAAK,IAAIC,MAAK,GAAG,CAAjB,EAAoBA,MAAK,GAAGL,aAAa,CAACL,MAA1C,EAAkDU,MAAK,EAAvD,EAA2D;AACvD,QAAMb,KAAK,GAAGQ,aAAa,CAACK,MAAD,CAA3B;;AACA,QAAIJ,OAAO,CAACI,MAAD,CAAX,EAAoB;AAChBF,MAAAA,UAAU,GAAGzB,UAAU,CAACyB,UAAD,EAAaX,KAAK,CAACc,QAAnB,EAA6B,EAA7B,CAAvB;AACA;AACH;;AACD,QAAId,KAAK,CAACc,QAAV,EAAoB;AAChB,UAAMzB,EAAE,GAAGG,gBAAgB,CAACQ,KAAD,EAAQU,YAAY,CAACE,gBAAD,CAApB,EAAwC,sBAAxC,CAA3B,CADgB,CAEhB;;AACA,UAAIvB,EAAE,KAAK0B,yBAAaC,YAAxB,EAAsC;AAClC,eAAO,IAAP;AACH;;AACDL,MAAAA,UAAU,GAAGzB,UAAU,CAACyB,UAAD,EAAaX,KAAK,CAACc,QAAnB,EAA6BzB,EAA7B,CAAvB;AACH;;AACD,MAAEuB,gBAAF;AACH;;AACD,SAAOD,UAAP;AACH,CAjCD;;AAmCA,IAAMM,aAAa,GAAG,WAYhB;AAAA,MAZiB;AACnBC,IAAAA,EADmB;AAEnB/B,IAAAA,IAFmB;AAGnBqB,IAAAA,aAHmB;AAInBC,IAAAA,OAJmB;AAKnBC,IAAAA;AALmB,GAYjB;AACF,MAAIC,UAAU,GAAGxB,IAAjB;AACA,MAAIyB,gBAAgB,GAAG,CAAvB;AACAJ,EAAAA,aAAa,CAACW,OAAd,CAAsB,CAACnB,KAAD,EAAQa,KAAR,KAAkB;AACpC,QAAIJ,OAAO,CAACI,KAAD,CAAX,EAAoB;AAChBF,MAAAA,UAAU,GAAGzB,UAAU,CAACyB,UAAD,EAAaX,KAAK,CAACc,QAAnB,EAA6B,EAA7B,CAAvB;AACA;AACH;;AAED,QAAId,KAAK,CAACc,QAAV,EAAoB;AAChB,UAAMzB,EAAE,GAAGG,gBAAgB,CAACQ,KAAD,EAAQU,YAAY,CAACE,gBAAD,CAApB,EAAwC,qBAAxC,CAA3B;AACAD,MAAAA,UAAU,GAAGzB,UAAU,CAACyB,UAAD,EAAaX,KAAK,CAACc,QAAnB,EAA6BzB,EAA7B,CAAvB;AACH;;AACD,MAAEuB,gBAAF;AACH,GAXD;AAYA,yBAAWM,EAAX,oBAAkBP,UAAlB,qGAC0EO,EAD1E;AAEH,CA7BD;;AA8CA,IAAME,QAAqC,GAAG,SAAxCA,QAAwC,CAACC,OAAD,EAA2B;AAAA,MAAjBC,OAAiB,uEAAP,EAAO;AACrE,MAAM;AAAEC,IAAAA,MAAF;AAAUC,IAAAA,SAAV;AAAqBC,IAAAA;AAArB,MAA+BJ,OAArC;AACA,MAAMK,cAAc,GAAG;AACnB;AACAC,IAAAA,cAAc,EAAE,CAACJ,MAAM,CAACK,UAAR,EAAoBL,MAAM,CAACM,IAA3B,EAAiCN,MAAM,CAACO,YAAxC,EAAsDP,MAAM,CAACQ,IAA7D,CAFG;AAGnBC,IAAAA,WAAW,EAAE;AAHM,GAAvB;AAKA,MAAMA,WAAW,GAAGV,OAAO,CAACU,WAAR,IAAuBN,cAAc,CAACM,WAA1D,CAPqE,CAQrE;;AACA,MAAMC,qBAAqB,GAAGC,uBAAWC,MAAX,CAAmBC,IAAD,IAAU;AACtD,QAAMC,UAAU,GAAGL,WAAW,CAACI,IAAI,CAAClB,EAAN,CAAX,IAAwB,EAA3C;AACA,QAAMoB,QAAQ,GAAG,OAAOD,UAAU,CAACC,QAAlB,KAA+B,SAA/B,GAA2CD,UAAU,CAACC,QAAtD,GAAiEF,IAAI,CAACE,QAAvF;AACA,WAAO,CAACA,QAAR;AACH,GAJ6B,CAA9B;;AAKA,MAAMC,QAAQ,GAAG,qCAAcN,qBAAd,CAAjB;AACA,MAAMO,aAAa,GAAGlB,OAAO,CAACK,cAAR,IAA0BD,cAAc,CAACC,cAA/D;AACA,SAAO,2CACHN,OADG,EAEH;AACIoB,IAAAA,eAAe,EAAED;AADrB,GAFG,EAKFE,MAAD,IAAY;AACR,WAAO;AACH,OAACnB,MAAM,CAACoB,SAAR,EAAmBC,IAAnB,EAAyB;AACrB,YAAMC,MAAM,GAAG,IAAIC,kCAAJ,CAAiBF,IAAjB,CAAf;AACA,YAAMzD,IAAI,GAAG0D,MAAM,CAACE,QAAP,EAAb;AACA,eAAO,yBAAS5D,IAAT,EAAe6D,IAAf,CAAqBC,aAAD,IAAmB;AAC1C,cAAMC,YAAY,GAAGX,QAAQ,CAACU,aAAD,CAA7B;AACAC,UAAAA,YAAY,CAAC/B,OAAb,CAAsBgC,WAAD,IAAiB;AAClC,gBAAMd,UAAU,GAAGL,WAAW,CAACmB,WAAW,CAACf,IAAZ,CAAiBlB,EAAlB,CAAX,IAAoC,EAAvD,CADkC,CAElC;;AACA,gBAAMhB,MAAM,GAAGmC,UAAU,CAACnC,MAAX,IAAqBiD,WAAW,CAACf,IAAZ,CAAiBlC,MAArD;AACA,gBAAMkD,SAAS,GAAGnD,eAAe,CAACkD,WAAW,CAACrD,MAAb,EAAqBI,MAArB,CAAjC;;AACA,gBAAIkD,SAAJ,EAAe;AACX;AACH,aAPiC,CAQlC;;;AACA,gBAAMC,UAAU,GAAGF,WAAW,CAACrD,MAAZ,CAAmB,CAAnB,CAAnB;AACA,gBAAMwD,SAAS,GAAGH,WAAW,CAACrD,MAAZ,CAAmBqD,WAAW,CAACrD,MAAZ,CAAmBK,MAAnB,GAA4B,CAA/C,CAAlB;AACA,gBAAMoD,cAAc,GAChBV,MAAM,CAACW,sBAAP,CAA8BC,IAAI,CAACC,GAAL,CAASL,UAAU,CAACM,aAAX,GAA2B,CAApC,EAAuC,CAAvC,CAA9B,KAA4E,CADhF;AAEA,gBAAMC,aAAa,GACff,MAAM,CAACW,sBAAP,CAA8BC,IAAI,CAACC,GAAL,CAASJ,SAAS,CAACK,aAAV,GAA0B,CAAnC,EAAsC,CAAtC,CAA9B,KAA2E,CAD/E,CAbkC,CAelC;;AACA,gBAAME,OAAO,GAAG5C,aAAa,CAAC;AAC1BC,cAAAA,EAAE,EAAEiC,WAAW,CAACf,IAAZ,CAAiBlB,EADK;AAE1B/B,cAAAA,IAAI,EAAEgE,WAAW,CAACf,IAAZ,CAAiByB,OAFG;AAG1BrD,cAAAA,aAAa,EAAE2C,WAAW,CAACf,IAAZ,CAAiBtC,MAHN;AAI1BW,cAAAA,OAAO,EAAE0C,WAAW,CAAC1C,OAJK;AAK1BC,cAAAA,YAAY,EAAEyC,WAAW,CAACrD;AALA,aAAD,CAA7B,CAhBkC,CAuBlC;;AACA,gBAAMS,QAAQ,GAAGD,cAAc,CAAC;AAC5BC,cAAAA,QAAQ,EAAE4C,WAAW,CAACf,IAAZ,CAAiB7B,QADC;AAE5BC,cAAAA,aAAa,EAAE2C,WAAW,CAACf,IAAZ,CAAiBtC,MAFJ;AAG5BW,cAAAA,OAAO,EAAE0C,WAAW,CAAC1C,OAHO;AAI5BC,cAAAA,YAAY,EAAEyC,WAAW,CAACrD;AAJE,aAAD,CAA/B;AAMA,gBAAMgE,gBAAgB,GAAGvD,QAAQ,IAAIV,cAAc,CAACsD,WAAW,CAACrD,MAAb,CAAd,KAAuCS,QAA5E;;AACA,gBAAIA,QAAQ,IAAIuD,gBAAhB,EAAkC;AAC9B,kBAAMC,UAAU,GAAGT,SAAS,CAAC1D,YAAV,CAAuBO,MAA1C;AACAuC,cAAAA,MAAM,CACFE,IADE,EAEF,IAAIpB,SAAJ,CAAcqC,OAAd,EAAuB;AACnBhD,gBAAAA,KAAK,EAAE0C,cADY;AAEnBS,gBAAAA,GAAG,EAAEvC,KAAK,CAACwC,gBAAN,CACD,CAACV,cAAD,EAAiBK,aAAa,GAAGG,UAAjC,CADC,EAEDxD,QAFC;AAFc,eAAvB,CAFE,CAAN;AAUH,aAZD,MAYO;AACHmC,cAAAA,MAAM,CACFE,IADE,EAEF,IAAIpB,SAAJ,CAAcqC,OAAd,EAAuB;AACnBhD,gBAAAA,KAAK,EAAE0C;AADY,eAAvB,CAFE,CAAN;AAMH;AACJ,WAnDD;AAoDH,SAtDM,CAAP;AAuDH;;AA3DE,KAAP;AA6DH,GAnEE,CAAP;AAqEH,CArFD;;eAsFe;AACXW,EAAAA,MAAM,EAAE9C,QADG;AAEXK,EAAAA,KAAK,EAAEL;AAFI,C","sourcesContent":["// MIT © 2016 azu\n\"use strict\";\nimport { matchPatterns } from \"@textlint/regexp-string-matcher\";\nimport { wrapReportHandler } from \"textlint-rule-helper\";\nimport { StringSource } from \"textlint-util-to-string\";\nimport { Dictionary, ExpectedType } from \"./dictionary\";\n\nimport { tokenize, KuromojiToken } from \"kuromojin\";\nimport { TextlintRuleModule } from \"@textlint/types\";\nimport { createMatcher } from \"morpheme-match-all\";\n\n/**\n * textの中身をすべて置換する\n * @param {string} text\n * @param {string|undefined} from\n * @param {string} to\n * @returns {string}\n */\nconst replaceAll = (text: string, from: string | undefined, to: string): string => {\n    if (!from) {\n        return text;\n    }\n    return text.split(from).join(to);\n};\n\nconst replaceTokenWith = (matcherToken: any, actualToken: KuromojiToken, specialTo: string) => {\n    if (matcherToken[specialTo]) {\n        return matcherToken[specialTo](actualToken);\n    }\n    return actualToken.surface_form;\n};\n\n/**\n * tokensのsurface_formをつなげた文字列を返す\n * @param tokens\n * @returns {string}\n */\nconst tokensToString = (tokens: KuromojiToken[]) => {\n    return tokens.map((token) => token.surface_form).join(\"\");\n};\n\n/**\n * \"allows\" オプションで許可されているかどうか\n * @param {*[]} tokens\n * @param {string[]} allows\n */\nconst isTokensAllowed = (tokens: KuromojiToken[], allows: string[]) => {\n    if (allows.length === 0) {\n        return false;\n    }\n    const matchedText = tokensToString(tokens);\n    const allowsMatchResults = matchPatterns(matchedText, allows);\n    return allowsMatchResults.length > 0;\n};\n\n/**\n * マッチしたtokensを置換した結果の文字列を返す\n * 置換できなかった場合はnullを返す\n * @param {string} expected\n * @param {*[]} matcherTokens\n * @param {boolean[]} skipped\n * @param {*[]} actualTokens\n * @returns {null|string}\n */\nconst createExpected = ({\n    expected,\n    matcherTokens,\n    skipped,\n    actualTokens\n}: {\n    expected?: string;\n    matcherTokens: any[];\n    skipped: boolean[];\n    actualTokens: KuromojiToken[];\n}): null | string => {\n    if (!expected) {\n        return null;\n    }\n    let resultText = expected;\n    let actualTokenIndex = 0;\n    for (let index = 0; index < matcherTokens.length; index++) {\n        const token = matcherTokens[index];\n        if (skipped[index]) {\n            resultText = replaceAll(resultText, token._capture, \"\");\n            continue;\n        }\n        if (token._capture) {\n            const to = replaceTokenWith(token, actualTokens[actualTokenIndex], \"_capture_to_expected\");\n            // _capture_to_expectedが\"STOP_REPLACE\"を返した場合は置換を取りやめる\n            if (to === ExpectedType.STOP_REPLACE) {\n                return null;\n            }\n            resultText = replaceAll(resultText, token._capture, to);\n        }\n        ++actualTokenIndex;\n    }\n    return resultText;\n};\n\nconst createMessage = ({\n    id,\n    text,\n    matcherTokens,\n    skipped,\n    actualTokens\n}: {\n    id: string;\n    text: string;\n    matcherTokens: any[];\n    skipped: boolean[];\n    actualTokens: KuromojiToken[];\n}) => {\n    let resultText = text;\n    let actualTokenIndex = 0;\n    matcherTokens.forEach((token, index) => {\n        if (skipped[index]) {\n            resultText = replaceAll(resultText, token._capture, \"\");\n            return;\n        }\n\n        if (token._capture) {\n            const to = replaceTokenWith(token, actualTokens[actualTokenIndex], \"_capture_to_message\");\n            resultText = replaceAll(resultText, token._capture, to);\n        }\n        ++actualTokenIndex;\n    });\n    return `【${id}】 ${resultText}\n解説: https://github.com/textlint-ja/textlint-rule-ja-no-redundant-expression#${id}`;\n};\n\nexport interface Options {\n    // - それぞれの`dict`に対するオプションを指定する\n    // - プロパティに`dict`の【dict[id]】を書き、値には次の辞書オプションを指定する\n    // - 辞書オプション: `object`\n    dictOptions?: {\n        [index: string]: {\n            disabled?: boolean;\n            allows?: string[];\n        };\n    };\n    // - 無視したいNode typeを配列で指定\n    // - Node typeは <https://textlint.github.io/docs/txtnode.html#type> を参照\n    // - デフォルトでは、`[\"BlockQuote\", \"Link\", \"ReferenceDef\", \"Code\"]`を指定し、引用やリンクのテキストは無視する\n}\n\nconst reporter: TextlintRuleModule<Options> = (context, options = {}) => {\n    const { Syntax, RuleError, fixer } = context;\n    const DefaultOptions = {\n        // https://textlint.github.io/docs/txtnode.html#type\n        allowNodeTypes: [Syntax.BlockQuote, Syntax.Link, Syntax.ReferenceDef, Syntax.Code],\n        dictOptions: {}\n    };\n    const dictOptions = options.dictOptions || DefaultOptions.dictOptions;\n    // \"disabled\": trueな辞書は取り除く\n    const enabledDictionaryList = Dictionary.filter((dict) => {\n        const dictOption = dictOptions[dict.id] || {};\n        const disabled = typeof dictOption.disabled === \"boolean\" ? dictOption.disabled : dict.disabled;\n        return !disabled;\n    });\n    const matchAll = createMatcher(enabledDictionaryList);\n    const skipNodeTypes = options.allowNodeTypes || DefaultOptions.allowNodeTypes;\n    return wrapReportHandler(\n        context,\n        {\n            ignoreNodeTypes: skipNodeTypes\n        },\n        (report) => {\n            return {\n                [Syntax.Paragraph](node) {\n                    const source = new StringSource(node);\n                    const text = source.toString();\n                    return tokenize(text).then((currentTokens) => {\n                        const matchResults = matchAll(currentTokens);\n                        matchResults.forEach((matchResult) => {\n                            const dictOption = dictOptions[matchResult.dict.id] || {};\n                            // \"allows\" オプションにマッチした場合はエラーを報告しない\n                            const allows = dictOption.allows || matchResult.dict.allows;\n                            const isAllowed = isTokensAllowed(matchResult.tokens, allows);\n                            if (isAllowed) {\n                                return;\n                            }\n                            // エラー報告\n                            const firstToken = matchResult.tokens[0];\n                            const lastToken = matchResult.tokens[matchResult.tokens.length - 1];\n                            const firstWordIndex =\n                                source.originalIndexFromIndex(Math.max(firstToken.word_position - 1, 0)) || 0;\n                            const lastWordIndex =\n                                source.originalIndexFromIndex(Math.max(lastToken.word_position - 1, 0)) || 0;\n                            // エラーメッセージ\n                            const message = createMessage({\n                                id: matchResult.dict.id,\n                                text: matchResult.dict.message,\n                                matcherTokens: matchResult.dict.tokens,\n                                skipped: matchResult.skipped,\n                                actualTokens: matchResult.tokens\n                            });\n                            // 置換結果\n                            const expected = createExpected({\n                                expected: matchResult.dict.expected,\n                                matcherTokens: matchResult.dict.tokens,\n                                skipped: matchResult.skipped,\n                                actualTokens: matchResult.tokens\n                            });\n                            const hasFixableResult = expected && tokensToString(matchResult.tokens) !== expected;\n                            if (expected && hasFixableResult) {\n                                const wordLength = lastToken.surface_form.length;\n                                report(\n                                    node,\n                                    new RuleError(message, {\n                                        index: firstWordIndex,\n                                        fix: fixer.replaceTextRange(\n                                            [firstWordIndex, lastWordIndex + wordLength],\n                                            expected\n                                        )\n                                    })\n                                );\n                            } else {\n                                report(\n                                    node,\n                                    new RuleError(message, {\n                                        index: firstWordIndex\n                                    })\n                                );\n                            }\n                        });\n                    });\n                }\n            };\n        }\n    );\n};\nexport default {\n    linter: reporter,\n    fixer: reporter\n};\n"],"file":"index.js"}