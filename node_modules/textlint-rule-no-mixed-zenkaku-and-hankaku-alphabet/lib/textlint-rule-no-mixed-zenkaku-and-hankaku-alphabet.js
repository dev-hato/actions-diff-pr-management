// MIT © 2017 azu
"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var RuleHelper = require("textlint-rule-helper").RuleHelper;
var matchCaptureGroupAll = require("match-index").matchCaptureGroupAll;
var moji = require("moji");
function toHankaku(string) {
    return moji(string).convert('ZE', 'HE').toString();
}
function toZenakaku(string) {
    return moji(string).convert('HE', 'ZE').toString();
}
var defaultOptions = {
    // "全角" or "半角"
    "prefer": "半角"
};

var zenkakuOnly = function zenkakuOnly(_ref) {
    var report = _ref.report,
        RuleError = _ref.RuleError,
        fixer = _ref.fixer;

    return function checkZenkaku(node, text) {
        var matchRegExp = /([a-zA-Z]+)/;
        matchCaptureGroupAll(text, matchRegExp).forEach(function (match) {
            var index = match.index,
                text = match.text;

            report(node, new RuleError("アルファベットは「全角」で表記します。", {
                index: index,
                fix: fixer.replaceTextRange([index, index + text.length], toZenakaku(text))
            }));
        });
    };
};
var hankakuOnly = function hankakuOnly(_ref2) {
    var report = _ref2.report,
        RuleError = _ref2.RuleError,
        fixer = _ref2.fixer;

    return function checkZenkaku(node, text) {
        var matchRegExp = /([ａ-ｚＡ-Ｚ]+)/;
        matchCaptureGroupAll(text, matchRegExp).forEach(function (match) {
            var index = match.index,
                text = match.text;

            report(node, new RuleError("アルファベットは「半角」で表記します。", {
                index: index,
                fix: fixer.replaceTextRange([index, index + text.length], toHankaku(text))
            }));
        });
    };
};
function reporter(context) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var Syntax = context.Syntax,
        RuleError = context.RuleError,
        report = context.report,
        fixer = context.fixer,
        getSource = context.getSource;

    var prefer = options.prefer || defaultOptions.prefer;
    var helper = new RuleHelper(context);
    var checkText = prefer === "半角" ? hankakuOnly({ report: report, RuleError: RuleError, fixer: fixer }) : zenkakuOnly({ report: report, RuleError: RuleError, fixer: fixer });
    return _defineProperty({}, Syntax.Str, function (node) {
        if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {
            return;
        }
        var text = getSource(node);
        checkText(node, text);
    });
}
module.exports = {
    linter: reporter,
    fixer: reporter
};
//# sourceMappingURL=textlint-rule-no-mixed-zenkaku-and-hankaku-alphabet.js.map