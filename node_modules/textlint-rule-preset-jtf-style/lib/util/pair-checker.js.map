{"version":3,"file":"pair-checker.js","names":["flat","array","concat","apply","checkPair","context","left","right","assert","Syntax","RuleError","report","getSource","helper","RuleHelper","isInParagraph","currentStrInParagraph","findAllSymbolLocations","symbol","text","index","symbolLocations","length","indexOf","push","foundMissingPairNodes","matchParentheses","map","node","leftSymbolLocations","rightSymbolLocations","allSymbolLocations","sort","a","b","loc","isCompletedParentheses","lastUnmatchParences","item","shift","last","pop","Paragraph","isChildNode","BlockQuote","Str","missingPairList","forEach","message"],"sources":["../../src/util/pair-checker.js"],"sourcesContent":["// LICENSE : MIT\n\"use strict\";\n/**\n * 「と」といったペアがちゃんと閉じられているかをチェックします\n * @param {object} context\n * @param {string} left\n * @param {string} right\n * @returns {object}\n */\nimport assert from \"assert\";\nimport { RuleHelper } from \"textlint-rule-helper\";\nconst flat = (array) => {\n    return [].concat.apply([], array);\n};\nexport function checkPair(context, { left, right }) {\n    assert(left);\n    assert(right);\n    const { Syntax, RuleError, report, getSource } = context;\n    const helper = new RuleHelper(context);\n    let isInParagraph = false;\n    let currentStrInParagraph = [];\n    /**\n     * `Str` nodeの配列を受け取り、pairが見つからないnodeを返す\n     * @param {Object} currentStrInParagraph\n     * @returns {{node, index}[]}\n     */\n    const findAllSymbolLocations = (symbol, text) => {\n        let index = 0;\n        const symbolLocations = [];\n        while (index < text.length) {\n            index = text.indexOf(symbol, index);\n            if (index < 0) break;\n            symbolLocations.push({\n                index,\n                symbol\n            });\n            index += 1;\n        }\n        return symbolLocations;\n    };\n    const foundMissingPairNodes = (currentStrInParagraph) => {\n        const matchParentheses = flat(\n            currentStrInParagraph.map((node) => {\n                let text = getSource(node);\n                const leftSymbolLocations = findAllSymbolLocations(left, text);\n                const rightSymbolLocations = left !== right ? findAllSymbolLocations(right, text) : [];\n                const allSymbolLocations = [...leftSymbolLocations, ...rightSymbolLocations].sort(\n                    (a, b) => a.index - b.index\n                );\n                return allSymbolLocations.map((loc) => ({ ...loc, node }));\n            })\n        );\n        if (left === right) {\n            const isCompletedParentheses = matchParentheses.length % 2 == 0;\n            if (isCompletedParentheses) {\n                return [];\n            } else {\n                return [matchParentheses[matchParentheses.length - 1]];\n            }\n        } else {\n            const lastUnmatchParences = [];\n            while (matchParentheses.length > 0) {\n                const item = matchParentheses.shift();\n                if (item.symbol == left) {\n                    lastUnmatchParences.push(item);\n                } else {\n                    // right\n                    const last = lastUnmatchParences.pop();\n                    if (last) {\n                        if (last.symbol == right) {\n                            lastUnmatchParences.push(last);\n                            lastUnmatchParences.push(item);\n                        }\n                    } else {\n                        lastUnmatchParences.push(item);\n                    }\n                }\n            }\n            return lastUnmatchParences;\n        }\n    };\n    return {\n        [Syntax.Paragraph](node) {\n            if (helper.isChildNode(node, [Syntax.BlockQuote])) {\n                return;\n            }\n            currentStrInParagraph = [];\n            isInParagraph = true;\n        },\n        [Syntax.Str](node) {\n            if (!isInParagraph) {\n                return;\n            }\n            currentStrInParagraph.push(node);\n        },\n        [`${Syntax.Paragraph}:exit`]() {\n            const missingPairList = foundMissingPairNodes(currentStrInParagraph);\n            // 探索おわり\n            isInParagraph = false;\n            // 全ての対が見つかったなら配列は空になる\n            if (missingPairList.length === 0) {\n                return;\n            }\n            missingPairList.forEach(({ index, node, symbol }) => {\n                let message =\n                    symbol === left\n                        ? `${left}の対となる${right}が見つかりません。${left}${right}`\n                        : `${right}の対となる${left}が見つかりません。${left}${right}`;\n                report(node, new RuleError(message, { index }));\n            });\n        }\n    };\n}\n"],"mappings":"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"}