"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var DEFAULT_OPTIONS = {
  startIndex: 1
};

var report = function report(context) {
  var _ref;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var Syntax = context.Syntax,
      RuleError = context.RuleError,
      report = context.report,
      fixer = context.fixer; // start index number

  var startIndex = options.startIndex !== undefined ? options.startIndex : DEFAULT_OPTIONS.startIndex;
  var shortcuts = [];
  var definitions = [];
  return _ref = {}, _defineProperty(_ref, "LinkReference", function LinkReference(node) {
    // ^identifer
    if (node.identifier && node.identifier[0] === "^" && node.referenceType === "shortcut") {
      shortcuts.push({
        node: node,
        identifier: node.identifier
      });
    }
  }), _defineProperty(_ref, "Definition", function Definition(node) {
    if (node.identifier && node.identifier[0] === "^") {
      definitions.push({
        node: node,
        identifier: node.identifier
      });
    }
  }), _defineProperty(_ref, Syntax.DocumentExit, function () {
    // Check Pair
    shortcuts.forEach(function (shortcut, index) {
      var hasDefinition = definitions.some(function (definition) {
        return definition.identifier === shortcut.identifier;
      });

      if (hasDefinition) {
        return;
      } // Workaround for remark
      // remark can not treat Definition correctly
      // For more details, see https://twitter.com/azu_re/status/1137019229322981376
      // Convert LinkReference to Definition


      var afterNodesOfShortcut = shortcuts.slice(index + 1);
      var shortcutNodeAsDefinitionNodeIndex = afterNodesOfShortcut.findIndex(function (definition) {
        return definition.identifier === shortcut.identifier;
      });

      if (shortcutNodeAsDefinitionNodeIndex !== -1) {
        // move the node into definition
        var _shortcuts$splice = shortcuts.splice(index + 1 + shortcutNodeAsDefinitionNodeIndex, 1),
            _shortcuts$splice2 = _slicedToArray(_shortcuts$splice, 1),
            shortcutNodeAsDefinitionNode = _shortcuts$splice2[0];

        definitions.push(shortcutNodeAsDefinitionNode);
        return;
      }

      report(shortcut.node, new RuleError("Not found definition for the shortcut"));
    }); // Check Identifier

    shortcuts.forEach(function (shortcut, index) {
      var expectedSortedNumber = startIndex + index; // 1 + 0 = "^1"

      var expectedShortcutIdentifier = String("^".concat(expectedSortedNumber));

      if (expectedShortcutIdentifier === shortcut.identifier) {
        return;
      }

      var pairDefinition = definitions.find(function (definition) {
        return definition.identifier === shortcut.identifier;
      }); // [^childStr]

      var childStr = Array.isArray(shortcut.node.children) && shortcut.node.children[0];

      if (pairDefinition && childStr) {
        // report fixable error
        report(childStr, new RuleError("Should use incremental number for identifier", {
          fix: fixer.replaceText(childStr, expectedShortcutIdentifier)
        }));
        var pairDefinitionReplace = "[^".concat(pairDefinition.identifier, "]");
        report(pairDefinition.node, new RuleError("Should use incremental number for definition", {
          fix: fixer.replaceTextRange([0, pairDefinitionReplace.length - 1], "[^".concat(expectedSortedNumber, "]"))
        }));
      } else {
        // report error
        report(shortcut.node, new RuleError("Should use use incremental number for identifier"));

        if (pairDefinition) {
          report(pairDefinition.node, new RuleError("Should use use incremental number for definition"));
        }
      }
    });
  }), _ref;
};

module.exports = {
  linter: report,
  fixer: report
};
//# sourceMappingURL=textlint-rule-footnote-order.js.map