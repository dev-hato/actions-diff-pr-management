{"version":3,"sources":["../src/textlint-rule-footnote-order.js"],"names":["DEFAULT_OPTIONS","startIndex","report","context","options","Syntax","RuleError","fixer","undefined","shortcuts","definitions","node","identifier","referenceType","push","DocumentExit","forEach","shortcut","index","hasDefinition","some","definition","afterNodesOfShortcut","slice","shortcutNodeAsDefinitionNodeIndex","findIndex","splice","shortcutNodeAsDefinitionNode","expectedSortedNumber","expectedShortcutIdentifier","String","pairDefinition","find","childStr","Array","isArray","children","fix","replaceText","pairDefinitionReplace","replaceTextRange","length","module","exports","linter"],"mappings":"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","sourcesContent":["const DEFAULT_OPTIONS = {\n    startIndex: 1\n};\nconst report = (context, options = {}) => {\n    const { Syntax, RuleError, report, fixer } = context;\n    // start index number\n    let startIndex = options.startIndex !== undefined ? options.startIndex : DEFAULT_OPTIONS.startIndex;\n    const shortcuts = [];\n    const definitions = [];\n    return {\n        // Markdown specific type\n        // It is not documented\n        [\"LinkReference\"](node) {\n            // ^identifer\n            if (node.identifier && node.identifier[0] === \"^\" && node.referenceType === \"shortcut\") {\n                shortcuts.push({\n                    node,\n                    identifier: node.identifier\n                });\n            }\n        },\n        [\"Definition\"](node) {\n            if (node.identifier && node.identifier[0] === \"^\") {\n                definitions.push({\n                    node,\n                    identifier: node.identifier\n                });\n            }\n        },\n        [Syntax.DocumentExit]() {\n            // Check Pair\n            shortcuts.forEach((shortcut, index) => {\n                const hasDefinition = definitions.some(definition => {\n                    return definition.identifier === shortcut.identifier;\n                });\n                if (hasDefinition) {\n                    return;\n                }\n                // Workaround for remark\n                // remark can not treat Definition correctly\n                // For more details, see https://twitter.com/azu_re/status/1137019229322981376\n                // Convert LinkReference to Definition\n                const afterNodesOfShortcut = shortcuts.slice(index + 1);\n                const shortcutNodeAsDefinitionNodeIndex = afterNodesOfShortcut.findIndex(definition => {\n                    return definition.identifier === shortcut.identifier;\n                });\n                if (shortcutNodeAsDefinitionNodeIndex !== -1) {\n                    // move the node into definition\n                    const [shortcutNodeAsDefinitionNode] = shortcuts.splice(index + 1 + shortcutNodeAsDefinitionNodeIndex, 1);\n                    definitions.push(shortcutNodeAsDefinitionNode);\n                    return;\n                }\n                report(shortcut.node, new RuleError(`Not found definition for the shortcut`));\n            });\n            // Check Identifier\n            shortcuts.forEach((shortcut, index) => {\n                const expectedSortedNumber = startIndex + index;\n                // 1 + 0 = \"^1\"\n                const expectedShortcutIdentifier = String(`^${expectedSortedNumber}`);\n                if (expectedShortcutIdentifier === shortcut.identifier) {\n                    return;\n                }\n                const pairDefinition = definitions.find(definition => {\n                    return definition.identifier === shortcut.identifier;\n                });\n                // [^childStr]\n                const childStr = Array.isArray(shortcut.node.children) && shortcut.node.children[0];\n                if (pairDefinition && childStr) {\n                    // report fixable error\n                    report(childStr, new RuleError(`Should use incremental number for identifier`, {\n                        fix: fixer.replaceText(childStr, expectedShortcutIdentifier)\n                    }));\n                    const pairDefinitionReplace = `[^${pairDefinition.identifier}]`;\n                    report(pairDefinition.node, new RuleError(`Should use incremental number for definition`, {\n                        fix: fixer.replaceTextRange([0, pairDefinitionReplace.length - 1], `[^${expectedSortedNumber}]`)\n                    }));\n                } else {\n                    // report error\n                    report(shortcut.node, new RuleError(`Should use use incremental number for identifier`));\n                    if (pairDefinition) {\n                        report(pairDefinition.node, new RuleError(`Should use use incremental number for definition`));\n                    }\n                }\n            });\n        }\n    };\n};\n\nmodule.exports = {\n    linter: report,\n    fixer: report\n};\n"],"file":"textlint-rule-footnote-order.js"}