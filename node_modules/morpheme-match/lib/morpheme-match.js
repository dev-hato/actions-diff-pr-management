"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function matchToken(token, expectedToken) {
    return Object.keys(expectedToken).every(function (key) {
        // Ignore start with _ key
        if (key[0] === "_") {
            return true;
        }
        var expectedKey = key;
        var actualValue = token[expectedKey];
        // support multiple value
        // "pos": ["名詞", "副詞"]
        var expectedValue = expectedToken[expectedKey];
        var expectedValues = Array.isArray(expectedValue) ? expectedValue : [expectedValue];
        return expectedValues.some(function (expectedValue) {
            return actualValue === expectedValue;
        });
    });
}
/**
 * Create matcher function that return { match : true , tokens []} if match the `token`.
 */
function createTokenMatcher(expectedTokens) {
    var currentTokenPosition = 0;
    var tokenCount = expectedTokens.length;
    var matchTokens = [];
    var matchSkipped = [];
    return function (token) {
        while (currentTokenPosition < tokenCount) {
            var expectedToken = expectedTokens[currentTokenPosition];
            if (matchToken(token, expectedToken)) {
                matchTokens.push(token);
                matchSkipped.push(false);
                currentTokenPosition += 1;
                break;
            }
            else if (expectedToken["_skippable"]) {
                currentTokenPosition += 1;
                matchSkipped.push(true);
            }
            else {
                // reset position
                matchTokens.length = 0;
                matchSkipped.length = 0;
                currentTokenPosition = 0;
                break;
            }
        }
        // match all tokens
        if (currentTokenPosition === tokenCount) {
            var tokens = matchTokens.slice();
            var skipped = matchSkipped.slice();
            // match -> reset
            currentTokenPosition = 0;
            matchTokens.length = 0;
            matchSkipped.length = 0;
            return {
                match: true,
                tokens: tokens,
                skipped: skipped
            };
        }
        return {
            match: false,
            tokens: [],
            skipped: []
        };
    };
}
exports.createTokenMatcher = createTokenMatcher;
//# sourceMappingURL=morpheme-match.js.map