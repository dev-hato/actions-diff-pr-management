{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as yaml from \"js-yaml\";\n\nimport * as raw from \"./raw\";\nimport { Engine } from \"./engine\";\nimport { ChangeSet, Diff } from \"./changeset/\";\n\nexport { Engine, ChangeSet, Diff };\n\nexport function fromYAMLFilePaths(...configPaths: string[]): Engine {\n    const engine = fromYAMLFilePath(configPaths[0]);\n    configPaths.splice(1).forEach(path => {\n        engine.merge(fromYAMLFilePath(path));\n    });\n    return engine;\n}\n\nexport interface Options {\n    disableImports?: boolean;\n}\n\nexport function fromYAMLFilePath(configPath: string, opts: Options = {}): Engine {\n    const content = fs.readFileSync(configPath, { encoding: \"utf8\" });\n    return fromYAML(configPath, content, opts);\n}\n\nexport function fromYAML(configPath: string, yamlContent: string, opts: Options = {}): Engine {\n    const rawConfig = yaml.load(yamlContent);\n    return fromRowConfig(configPath, rawConfig, opts);\n}\n\nexport function fromRowConfig(configPath: string, rawConfig: raw.Config, opts: Options = {}): Engine {\n    const engine = new Engine(rawConfig);\n    engine.sourcePaths.push(path.normalize(configPath));\n\n    if (!opts.disableImports && rawConfig.imports) {\n        // TODO この辺の処理をEngine側に移したい\n        // なるべく破壊的変更を避ける\n        // fsやyamlを使わずに同等のEngineを組み立てる余地を残す\n        // async化したいけどprhの参照パッケージが壊れるのが辛い\n\n        let importSpecs: raw.ImportSpec[];\n        if (typeof rawConfig.imports === \"string\") {\n            importSpecs = [{\n                path: rawConfig.imports,\n            }];\n        } else {\n            importSpecs = rawConfig.imports.map(imp => {\n                if (typeof imp === \"string\") {\n                    return {\n                        path: imp,\n                    };\n                }\n                return imp;\n            });\n        }\n        importSpecs.forEach(importSpec => {\n            const importedConfigPath = path.join(path.dirname(configPath), importSpec.path);\n            const newEngine = fromYAMLFilePath(importedConfigPath, {\n                disableImports: !!importSpec.disableImports,\n            });\n\n            const ignoreRules = (importSpec.ignoreRules || []).map(ignoreRule => {\n                return typeof ignoreRule === \"string\" ? { pattern: ignoreRule } : ignoreRule;\n            });\n            newEngine.rules = newEngine.rules.filter(rule => {\n                return ignoreRules.every(ignoreRule => {\n                    return !rule._shouldIgnore(ignoreRule);\n                });\n            });\n\n            engine.merge(newEngine);\n        });\n    }\n\n    return engine;\n}\n\nexport function fromYAMLFilePathsAsync(...configPaths: string[]): Promise<Engine> {\n    try {\n        return Promise.resolve(fromYAMLFilePaths(...configPaths));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n}\n\nexport function fromYAMLFilePathAsync(configPath: string, opts: Options = {}): Promise<Engine> {\n    try {\n        return Promise.resolve(fromYAMLFilePath(configPath, opts));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n}\n\nexport function fromYAMLAsync(configPath: string, yamlContent: string, opts: Options = {}): Promise<Engine> {\n    try {\n        return Promise.resolve(fromYAML(configPath, yamlContent, opts));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n}\n\nexport function fromRowConfigAsync(configPath: string, rawConfig: raw.Config, opts: Options = {}): Promise<Engine> {\n    try {\n        return Promise.resolve(fromRowConfig(configPath, rawConfig, opts));\n    } catch (e) {\n        return Promise.reject(e);\n    }\n}\n\nexport function getRuleFilePath(baseDir: string, configFileName = \"prh.yml\"): string | null {\n    const configFilePath = path.resolve(baseDir, configFileName);\n    if (fs.existsSync(configFilePath)) {\n        return configFilePath;\n    }\n\n    if (baseDir.length === path.dirname(baseDir).length) {\n        return null;\n    }\n\n    return getRuleFilePath(path.resolve(baseDir, \"../\"), configFileName);\n}\n"]}