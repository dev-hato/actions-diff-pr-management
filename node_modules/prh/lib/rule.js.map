{"version":3,"file":"rule.js","sourceRoot":"","sources":["rule.ts"],"names":[],"mappings":"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","sourcesContent":["import { spreadAlphaNum, addBoundary, addDefaultFlags, parseRegExpString, escapeSpecialChars, combine, collectAll } from \"./utils/regexp\";\n\nimport { Options } from \"./options\";\nimport { RuleSpec } from \"./ruleSpec\";\n\nimport { Diff } from \"./changeset/diff\";\n\nimport * as raw from \"./raw\";\nimport { ChangeSet } from \"./changeset\";\n\nexport class Rule {\n    expected: string;\n    pattern: RegExp;\n    regexpMustEmpty: string | undefined;\n    options: Options;\n    specs: RuleSpec[];\n    raw: any /* raw.Rule */;\n\n    constructor(src: string | raw.Rule) {\n        if (!src) {\n            throw new Error(\"src is requried\");\n        }\n        let rawRule: raw.Rule;\n        if (typeof src === \"string\") {\n            rawRule = {\n                expected: src,\n            };\n        } else {\n            rawRule = src;\n        }\n        function checkEmptyPattern(patterns: string | string[] | null | undefined) {\n            if (patterns === \"\") {\n                throw new Error(\"pattern can't be empty\");\n            }\n            Array.isArray(patterns) && patterns.forEach(pattern => {\n                if (pattern === \"\") {\n                    throw new Error(\"patterns can't be empty\");\n                }\n            });\n        }\n        checkEmptyPattern(rawRule.pattern);\n        checkEmptyPattern(rawRule.patterns);\n\n        this.options = new Options(this, rawRule.options);\n\n        this.expected = rawRule.expected;\n        if (this.expected == null) {\n            throw new Error(\"expected is required\");\n        }\n\n        this.pattern = this._patternToRegExp(rawRule.pattern || rawRule.patterns);\n        if (this.pattern == null) {\n            throw new Error(\"pattern is required\");\n        }\n\n        this.regexpMustEmpty = rawRule.regexpMustEmpty;\n\n        // for JSON order\n        const options = this.options;\n        delete this.options;\n        this.options = options;\n\n        this.specs = (rawRule.specs || []).map(spec => new RuleSpec(spec));\n\n        this.raw = rawRule;\n\n        this.check();\n    }\n\n    /* @internal */\n    _patternToRegExp(pattern?: string | string[] | null): RegExp {\n        if (pattern === \"\") {\n            throw new Error(\"pattern can't be empty\");\n        } else if (pattern == null) {\n            let result = spreadAlphaNum(this.expected);\n            if (this.options.wordBoundary) {\n                result = addBoundary(result);\n            }\n            return addDefaultFlags(result);\n        } else if (typeof pattern === \"string\") {\n            let result = parseRegExpString(pattern);\n            if (!result) {\n                result = new RegExp(escapeSpecialChars(pattern));\n            }\n            if (this.options.wordBoundary) {\n                result = addBoundary(result);\n            }\n            return addDefaultFlags(result);\n        } else if (pattern instanceof Array) {\n            const result = combine(pattern.map(p => this._patternToRegExp(p)));\n            return addDefaultFlags(result!);\n        } else {\n            throw new Error(`unexpected pattern: ${pattern}`);\n        }\n    }\n\n    /* @internal */\n    _shouldIgnore(ignoreRule: raw.IgnoreRule) {\n        // NOTE 考え方：--rules-yaml で表示されるpattern or expectedで指定する\n        // patternは配列で指定できて、そのうちの1つのパターンが指定された時に\n        // そのルール全体が無視されるのか該当の1パターンだけ無視されるのか予想できないため\n\n        if (ignoreRule.pattern != null && this.pattern.toString() === ignoreRule.pattern) {\n            return true;\n        }\n        if (ignoreRule.expected != null && ignoreRule.expected === this.expected) {\n            return true;\n        }\n\n        return false;\n    }\n\n    reset() {\n        this.pattern.lastIndex = 0;\n    }\n\n    check() {\n        this.specs.forEach(spec => {\n            const diffs = this.applyRule(spec.from);\n            const changeSet = new ChangeSet({ content: spec.from, diffs });\n            const result = changeSet.applyChangeSets(spec.from);\n            if (spec.to !== result) {\n                throw new Error(`${this.expected} spec failed. \"${spec.from}\", expected \"${spec.to}\", but got \"${result}\", ${this.pattern}`);\n            }\n        });\n    }\n\n    applyRule(content: string): Diff[] {\n        this.reset();\n        const resultList = collectAll(this.pattern, content);\n        return resultList\n            .map(matches => {\n                // JavaScriptでの正規表現では /(?<!記|大)事/ のような書き方ができない\n                // /(記|大)事/ で regexpMustEmpty $1 の場合、第一グループが空じゃないとマッチしない、というルールにして回避\n                if (this.regexpMustEmpty) {\n                    const match = /^\\$([0-9]+)$/.exec(this.regexpMustEmpty);\n                    if (match == null) {\n                        throw new Error(`${this.expected} target failed. please use $1 format.`);\n                    }\n                    const index = parseInt(match[1], 10);\n                    if (matches[index]) {\n                        return null;\n                    }\n                }\n                // 検出したものと期待するものが一致している場合無視させる\n                if (this.expected === matches[0]) {\n                    return null;\n                }\n                return new Diff({\n                    pattern: this.pattern,\n                    expected: this.expected,\n                    index: matches.index,\n                    matches: matches,\n                    rule: this,\n                });\n            })\n            .filter(v => !!v) as any as Diff[]; // (Diff | null)[] を Diff[] に変換したい\n    }\n\n    toJSON() {\n        const alt: any = {};\n        for (const key in this) {\n            if (key.indexOf(\"_\") === 0) {\n                continue;\n            }\n            const value = (<any>this)[key];\n            if (value instanceof RegExp) {\n                alt[key] = value.toString();\n                continue;\n            }\n            alt[key] = value;\n        }\n        return alt;\n    }\n}\n"]}