{"version":3,"sources":["../src/index.js"],"names":["kuromojin","require","createMatcher","dictionaries","matchAll","reporter","context","options","Syntax","RuleError","report","getSource","fixer","Str","node","text","tokenize","then","actualTokens","results","length","forEach","result","offset","dict","extensions","undefined","index","Math","max","tokens","word_position","textToReplace","token","i","surface_form","fix","replaceTextRange","expected","ruleError","message","module","exports","linter"],"mappings":"AAAA;;;;AAEA,IAAMA,YAAYC,QAAQ,WAAR,CAAlB;AACA,IAAMC,gBAAgBD,QAAQ,oBAAR,CAAtB;AACA,IAAME,eAAeF,QAAQ,QAAR,CAArB;;AAEA,IAAMG,WAAWF,cAAcC,YAAd,CAAjB;;AAEA,SAASE,QAAT,CAAkBC,OAAlB,EAAyC;AAAA,MAAdC,OAAc,uEAAJ,EAAI;AAAA,MAErCC,MAFqC,GAOnCF,OAPmC,CAErCE,MAFqC;AAAA,MAGrCC,SAHqC,GAOnCH,OAPmC,CAGrCG,SAHqC;AAAA,MAIrCC,MAJqC,GAOnCJ,OAPmC,CAIrCI,MAJqC;AAAA,MAKrCC,SALqC,GAOnCL,OAPmC,CAKrCK,SALqC;AAAA,MAMrCC,KANqC,GAOnCN,OAPmC,CAMrCM,KANqC;;AAQvC,6BACGJ,OAAOK,GADV,YACeC,IADf,EACqB;AAAE;AACnB,QAAMC,OAAOJ,UAAUG,IAAV,CAAb,CADiB,CACa;;AAE9B,WAAOd,UAAUgB,QAAV,CAAmBD,IAAnB,EAAyBE,IAAzB,CAA8B,UAACC,YAAD,EAAkB;AACrD;AACA,UAAMC,UAAUf,SAASc,YAAT,CAAhB;;AAEA,UAAIC,QAAQC,MAAR,IAAkB,CAAtB,EAAyB;AACvB;AACD;;AAEDD,cAAQE,OAAR,CAAgB,UAASC,MAAT,EAAiB;;AAE/B,YAAMC,SAASD,OAAOE,IAAP,CAAYC,UAAZ,CAAuBF,MAAvB,KAAkCG,SAAlC,GAA8C,CAA9C,GAAkDJ,OAAOE,IAAP,CAAYC,UAAZ,CAAuBF,MAAxF;AACA,YAAMI,QAAQC,KAAKC,GAAL,CAASP,OAAOQ,MAAP,CAAcP,MAAd,EAAsBQ,aAAtB,GAAsC,CAA/C,EAAkD,CAAlD,CAAd;;AAEA,YAAIC,gBAAgB,EAApB;;AAEAV,eAAOQ,MAAP,CAAcT,OAAd,CAAsB,UAASY,KAAT,EAAgBC,CAAhB,EAAkB;AACtC,cAAIA,KAAKX,MAAT,EAAiB;AACfS,6BAAiBC,MAAME,YAAvB;AACD;AACF,SAJD;;AAMA,YAAMC,MAAMxB,MAAMyB,gBAAN,CAAuB,CAACV,KAAD,EAAQA,QAAQK,cAAcZ,MAA9B,CAAvB,EAA8DE,OAAOE,IAAP,CAAYc,QAA1E,CAAZ;AACA,YAAMC,YAAY,IAAI9B,SAAJ,CAAca,OAAOE,IAAP,CAAYgB,OAA1B,EAChB;AACEb,iBAAOA,KADT;AAEES,eAAKA;AAFP,SADgB,CAAlB;AAMA1B,eAAOI,IAAP,EAAayB,SAAb;AACD,OArBD;AAsBD,KA9BM,CAAP;AA+BD,GAnCH;AAqCD;;AAEDE,OAAOC,OAAP,GAAiB;AACfC,UAAQtC,QADO;AAEfO,SAAOP;AAFQ,CAAjB","file":"index.js","sourcesContent":["\"use strict\";\n\nconst kuromojin = require(\"kuromojin\");\nconst createMatcher = require(\"morpheme-match-all\");\nconst dictionaries = require(\"./dict\");\n\nconst matchAll = createMatcher(dictionaries);\n\nfunction reporter(context, options = {}) {\n  const {\n    Syntax,\n    RuleError,\n    report,\n    getSource,\n    fixer\n  } = context;\n  return {\n    [Syntax.Str](node) { // \"Str\" node\n      const text = getSource(node); // Get text\n\n      return kuromojin.tokenize(text).then((actualTokens) => {\n        //console.log(actualTokens);\n        const results = matchAll(actualTokens);\n        \n        if (results.length == 0) {\n          return;\n        }\n\n        results.forEach(function(result) {\n          \n          const offset = result.dict.extensions.offset === undefined ? 0 : result.dict.extensions.offset;\n          const index = Math.max(result.tokens[offset].word_position - 1, 0);\n\n          let textToReplace = \"\";\n\n          result.tokens.forEach(function(token, i){            \n            if (i >= offset) {\n              textToReplace += token.surface_form;\n            }\n          });\n\n          const fix = fixer.replaceTextRange([index, index + textToReplace.length], result.dict.expected);\n          const ruleError = new RuleError(result.dict.message,\n            {\n              index: index,\n              fix: fix\n            }\n          );\n          report(node, ruleError);\n        });\n      });\n    }\n  };\n}\n\nmodule.exports = {\n  linter: reporter,\n  fixer: reporter\n};"]}