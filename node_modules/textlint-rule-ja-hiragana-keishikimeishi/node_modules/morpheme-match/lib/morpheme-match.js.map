{"version":3,"sources":["../src/morpheme-match.js"],"names":["matchToken","token","expectShape","Object","keys","every","key","actualValue","expectedValues","Array","isArray","some","expectedValue","module","exports","createTokenMatcher","matchedTokens","currentTokenPosition","tokenCount","length","matchTokens","matchSkipped","index","expectedToken","push","tokens","slice","skipped","match"],"mappings":"AAAA;AACA;;AACA,SAASA,UAAT,CAAoBC,KAApB,EAA2BC,WAA3B,EAAwC;AACpC,WAAOC,OAAOC,IAAP,CAAYF,WAAZ,EAAyBG,KAAzB,CAA+B,eAAO;AACzC;AACA,YAAIC,IAAI,CAAJ,MAAW,GAAf,EAAoB;AAChB,mBAAO,IAAP;AACH;AACD,YAAMC,cAAcN,MAAMK,GAAN,CAApB;AACA;AACA;AACA,YAAME,iBAAiBC,MAAMC,OAAN,CAAcR,YAAYI,GAAZ,CAAd,IAAkCJ,YAAYI,GAAZ,CAAlC,GAAqD,CAACJ,YAAYI,GAAZ,CAAD,CAA5E;AACA,eAAOE,eAAeG,IAAf,CAAoB,yBAAiB;AACxC,mBAAOJ,gBAAgBK,aAAvB;AACH,SAFM,CAAP;AAGH,KAZM,CAAP;AAaH;;AAED;;;;;AAKAC,OAAOC,OAAP,GAAiB,SAASC,kBAAT,CAA4BC,aAA5B,EAA2C;AACxD,QAAIC,uBAAuB,CAA3B;AACA,QAAMC,aAAaF,cAAcG,MAAjC;AACA,QAAMC,cAAc,EAApB;AACA,QAAMC,eAAe,EAArB;AACA,WAAO,UAACpB,KAAD,EAAQqB,KAAR,EAAkB;AACrB,eAAOL,uBAAuBC,UAA9B,EAA0C;AACtC,gBAAMK,gBAAgBP,cAAcC,oBAAd,CAAtB;AACA,gBAAIjB,WAAWC,KAAX,EAAkBsB,aAAlB,CAAJ,EAAsC;AAClCH,4BAAYI,IAAZ,CAAiBvB,KAAjB;AACAoB,6BAAaG,IAAb,CAAkB,KAAlB;AACAP,wCAAwB,CAAxB;AACA;AACH,aALD,MAKO,IAAIM,cAAc,YAAd,CAAJ,EAAiC;AACpCN,wCAAwB,CAAxB;AACAI,6BAAaG,IAAb,CAAkB,IAAlB;AACH,aAHM,MAGA;AACH;AACAJ,4BAAYD,MAAZ,GAAqB,CAArB;AACAE,6BAAaF,MAAb,GAAsB,CAAtB;AACAF,uCAAuB,CAAvB;AACA;AACH;AACJ;AACD;AACA,YAAIA,yBAAyBC,UAA7B,EAAyC;AACrC,gBAAMO,SAASL,YAAYM,KAAZ,EAAf;AACA,gBAAMC,UAAUN,aAAaK,KAAb,EAAhB;AACA;AACAT,mCAAuB,CAAvB;AACAG,wBAAYD,MAAZ,GAAqB,CAArB;AACAE,yBAAaF,MAAb,GAAsB,CAAtB;AACA,mBAAO;AACHS,uBAAO,IADJ;AAEHH,wBAAQA,MAFL;AAGHE,yBAASA;AAHN,aAAP;AAKH;AACD,eAAO;AACHC,mBAAO;AADJ,SAAP;AAGH,KApCD;AAqCH,CA1CD","file":"morpheme-match.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nfunction matchToken(token, expectShape) {\n    return Object.keys(expectShape).every(key => {\n        // Ignore start with _ key\n        if (key[0] === \"_\") {\n            return true;\n        }\n        const actualValue = token[key];\n        // support multiple value\n        // \"pos\": [\"名詞\", \"副詞\"]\n        const expectedValues = Array.isArray(expectShape[key]) ? expectShape[key] : [expectShape[key]];\n        return expectedValues.some(expectedValue => {\n            return actualValue === expectedValue;\n        });\n    })\n}\n\n/**\n * Create matcher function that return { match : true , tokens []} if match the `token`.\n * @param {Object[]} matchedTokens\n * @returns {function(token:Object)}\n */\nmodule.exports = function createTokenMatcher(matchedTokens) {\n    let currentTokenPosition = 0;\n    const tokenCount = matchedTokens.length;\n    const matchTokens = [];\n    const matchSkipped = [];\n    return (token, index) => {\n        while (currentTokenPosition < tokenCount) {\n            const expectedToken = matchedTokens[currentTokenPosition];\n            if (matchToken(token, expectedToken)) {\n                matchTokens.push(token);\n                matchSkipped.push(false);\n                currentTokenPosition += 1;\n                break;\n            } else if (expectedToken[\"_skippable\"]) {\n                currentTokenPosition += 1;\n                matchSkipped.push(true);\n            } else {\n                // reset position\n                matchTokens.length = 0;\n                matchSkipped.length = 0;\n                currentTokenPosition = 0;\n                break;\n            }\n        }\n        // match all tokens\n        if (currentTokenPosition === tokenCount) {\n            const tokens = matchTokens.slice();\n            const skipped = matchSkipped.slice();\n            // match -> reset\n            currentTokenPosition = 0;\n            matchTokens.length = 0;\n            matchSkipped.length = 0;\n            return {\n                match: true,\n                tokens: tokens,\n                skipped: skipped,\n            };\n        }\n        return {\n            match: false\n        };\n    }\n};\n"]}