{"version":3,"file":"auto-replace.js","sourceRoot":"","sources":["../../../../../lib/workers/repository/update/branch/auto-replace.ts"],"names":[],"mappings":"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","sourcesContent":["// TODO #7154\nimport { WORKER_FILE_UPDATE_FAILED } from '../../../../constants/error-messages';\nimport { logger } from '../../../../logger';\nimport { get } from '../../../../modules/manager';\nimport type { PackageDependency } from '../../../../modules/manager/types';\nimport { writeLocalFile } from '../../../../util/fs';\nimport { escapeRegExp, regEx } from '../../../../util/regex';\nimport { matchAt, replaceAt } from '../../../../util/string';\nimport { compile } from '../../../../util/template';\nimport type { BranchUpgradeConfig } from '../../../types';\n\nexport async function confirmIfDepUpdated(\n  upgrade: BranchUpgradeConfig,\n  newContent: string\n): Promise<boolean> {\n  const {\n    manager,\n    packageFile,\n    newValue,\n    newDigest,\n    depIndex,\n    currentDigest,\n    pinDigests,\n  } = upgrade;\n  const extractPackageFile = get(manager, 'extractPackageFile');\n  let newUpgrade: PackageDependency;\n  try {\n    const newExtract = await extractPackageFile!(\n      newContent,\n      packageFile,\n      upgrade\n    );\n    // istanbul ignore if\n    if (!newExtract) {\n      logger.debug({ manager, packageFile }, 'Could not extract package file');\n      return false;\n    }\n    newUpgrade = newExtract.deps[depIndex!];\n  } catch (err) /* istanbul ignore next */ {\n    logger.debug({ manager, packageFile, err }, 'Failed to parse newContent');\n  }\n  if (!newUpgrade!) {\n    logger.debug({ manager, packageFile }, 'No newUpgrade');\n    return false;\n  }\n\n  if (upgrade.depName !== newUpgrade.depName) {\n    logger.debug(\n      {\n        manager,\n        packageFile,\n        currentDepName: upgrade.depName,\n        newDepName: newUpgrade.depName,\n      },\n      'depName mismatch'\n    );\n    return false;\n  }\n  if (newUpgrade.currentValue !== newValue) {\n    logger.debug(\n      {\n        manager,\n        packageFile,\n        expectedValue: newValue,\n        foundValue: newUpgrade.currentValue,\n      },\n      'Value mismatch'\n    );\n    return false;\n  }\n  if (!newDigest) {\n    return true;\n  }\n  if (newUpgrade.currentDigest === newDigest) {\n    return true;\n  }\n  if (!currentDigest && !pinDigests) {\n    return true;\n  }\n  // istanbul ignore next\n  return false;\n}\n\nfunction getDepsSignature(deps: PackageDependency[]): string {\n  // TODO: types (#7154)\n  return deps.map((dep) => `${dep.depName!}${dep.packageName!}`).join(',');\n}\n\nexport async function checkBranchDepsMatchBaseDeps(\n  upgrade: BranchUpgradeConfig,\n  branchContent: string\n): Promise<boolean> {\n  const { baseDeps, manager, packageFile } = upgrade;\n  const extractPackageFile = get(manager, 'extractPackageFile');\n  try {\n    const res = await extractPackageFile!(branchContent, packageFile, upgrade)!;\n    const branchDeps = res!.deps;\n    return getDepsSignature(baseDeps!) === getDepsSignature(branchDeps);\n  } catch (err) /* istanbul ignore next */ {\n    logger.info(\n      { manager, packageFile },\n      'Failed to parse branchContent - rebasing'\n    );\n    return false;\n  }\n}\n\nexport async function doAutoReplace(\n  upgrade: BranchUpgradeConfig,\n  existingContent: string,\n  reuseExistingBranch: boolean\n): Promise<string | null> {\n  const {\n    packageFile,\n    depName,\n    currentValue,\n    newValue,\n    currentDigest,\n    newDigest,\n    autoReplaceStringTemplate,\n  } = upgrade;\n  if (reuseExistingBranch) {\n    if (!(await checkBranchDepsMatchBaseDeps(upgrade, existingContent))) {\n      logger.debug(\n        { packageFile, depName },\n        'Rebasing branch after deps list has changed'\n      );\n      return null;\n    }\n    if (!(await confirmIfDepUpdated(upgrade, existingContent))) {\n      logger.debug(\n        { packageFile, depName },\n        'Rebasing after outdated branch dep found'\n      );\n      return null;\n    }\n    logger.debug({ packageFile, depName }, 'Branch dep is already updated');\n    return existingContent;\n  }\n  const replaceString = upgrade.replaceString ?? currentValue;\n  logger.trace({ depName, replaceString }, 'autoReplace replaceString');\n  let searchIndex = existingContent.indexOf(replaceString!);\n  if (searchIndex === -1) {\n    logger.info(\n      { packageFile, depName, existingContent, replaceString },\n      'Cannot find replaceString in current file content. Was it already updated?'\n    );\n    return existingContent;\n  }\n  try {\n    let newString: string;\n    if (autoReplaceStringTemplate) {\n      newString = compile(autoReplaceStringTemplate, upgrade, false);\n    } else {\n      newString = replaceString!;\n      if (currentValue) {\n        newString = newString.replace(\n          regEx(escapeRegExp(currentValue), 'g'),\n          newValue!\n        );\n      }\n      if (currentDigest && newDigest) {\n        newString = newString.replace(\n          regEx(escapeRegExp(currentDigest), 'g'),\n          newDigest\n        );\n      }\n    }\n    logger.debug(\n      { packageFile, depName },\n      `Starting search at index ${searchIndex}`\n    );\n    // Iterate through the rest of the file\n    for (; searchIndex < existingContent.length; searchIndex += 1) {\n      // First check if we have a hit for the old version\n      if (matchAt(existingContent, searchIndex, replaceString!)) {\n        logger.debug(\n          { packageFile, depName },\n          `Found match at index ${searchIndex}`\n        );\n        // Now test if the result matches\n        const testContent = replaceAt(\n          existingContent,\n          searchIndex,\n          replaceString!,\n          newString\n        );\n        await writeLocalFile(upgrade.packageFile!, testContent);\n\n        if (await confirmIfDepUpdated(upgrade, testContent)) {\n          return testContent;\n        }\n        // istanbul ignore next\n        await writeLocalFile(upgrade.packageFile!, existingContent);\n      }\n    }\n  } catch (err) /* istanbul ignore next */ {\n    logger.debug({ packageFile, depName, err }, 'doAutoReplace error');\n  }\n  // istanbul ignore next\n  throw new Error(WORKER_FILE_UPDATE_FAILED);\n}\n"]}