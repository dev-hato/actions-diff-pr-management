{"version":3,"file":"reuse.js","sourceRoot":"","sources":["../../../../../lib/workers/repository/update/branch/reuse.ts"],"names":[],"mappings":"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","sourcesContent":["// TODO #7154\nimport { GlobalConfig } from '../../../../config/global';\nimport { logger } from '../../../../logger';\nimport { platform } from '../../../../modules/platform';\nimport type { RangeStrategy } from '../../../../types';\nimport {\n  branchExists,\n  isBranchBehindBase,\n  isBranchConflicted,\n  isBranchModified,\n} from '../../../../util/git';\nimport type { BranchConfig } from '../../../types';\n\ntype ParentBranch = {\n  reuseExistingBranch: boolean;\n  isModified?: boolean;\n  isConflicted?: boolean;\n};\n\nexport async function shouldReuseExistingBranch(\n  config: BranchConfig\n): Promise<ParentBranch> {\n  const { baseBranch, branchName } = config;\n  const result: ParentBranch = { reuseExistingBranch: false };\n  // Check if branch exists\n  if (!branchExists(branchName)) {\n    logger.debug(`Branch needs creating`);\n    return result;\n  }\n  logger.debug(`Branch already exists`);\n\n  // Check for existing PR\n  const pr = await platform.getBranchPr(branchName);\n\n  if (pr) {\n    if (pr.title?.startsWith('rebase!')) {\n      logger.debug(`Manual rebase requested via PR title for #${pr.number}`);\n      return result;\n    }\n    if (pr.bodyStruct?.rebaseRequested) {\n      logger.debug(`Manual rebase requested via PR checkbox for #${pr.number}`);\n      return result;\n    }\n    if (pr.labels?.includes(config.rebaseLabel!)) {\n      logger.debug(`Manual rebase requested via PR labels for #${pr.number}`);\n      // istanbul ignore if\n      if (GlobalConfig.get('dryRun')) {\n        logger.info(\n          `DRY-RUN: Would delete label ${config.rebaseLabel!} from #${\n            pr.number\n          }`\n        );\n      } else {\n        await platform.deleteLabel(pr.number, config.rebaseLabel!);\n      }\n      return result;\n    }\n  }\n\n  if (\n    config.rebaseWhen === 'behind-base-branch' ||\n    (config.rebaseWhen === 'auto' &&\n      (config.automerge || (await platform.getRepoForceRebase())))\n  ) {\n    if (await isBranchBehindBase(branchName)) {\n      logger.debug(`Branch is stale and needs rebasing`);\n      // We can rebase the branch only if no PR or PR can be rebased\n      if (await isBranchModified(branchName)) {\n        logger.debug('Cannot rebase branch as it has been modified');\n        result.reuseExistingBranch = true;\n        result.isModified = true;\n        return result;\n      }\n      logger.debug('Branch is unmodified, so can be rebased');\n      return result;\n    }\n    logger.debug('Branch is up-to-date');\n  } else {\n    logger.debug(\n      `Skipping stale branch check due to rebaseWhen=${config.rebaseWhen!}`\n    );\n  }\n\n  // Now check if PR is unmergeable. If so then we also rebase\n  result.isConflicted = await isBranchConflicted(baseBranch!, branchName);\n  if (result.isConflicted) {\n    logger.debug('Branch is conflicted');\n\n    if ((await isBranchModified(branchName)) === false) {\n      logger.debug(`Branch is not mergeable and needs rebasing`);\n      if (config.rebaseWhen === 'never') {\n        logger.debug('Rebasing disabled by config');\n        result.reuseExistingBranch = true;\n        result.isModified = false;\n      }\n      // Setting reuseExistingBranch back to undefined means that we'll use the default branch\n      return result;\n    }\n    // Don't do anything different, but warn\n    // TODO: Add warning to PR (#9720)\n    logger.debug(`Branch is not mergeable but can't be rebased`);\n  }\n  logger.debug(`Branch does not need rebasing`);\n\n  // Branches can get in an inconsistent state if \"update-lockfile\" is used at the same time as other strategies\n  // On the first execution, everything is executed, but if on a second execution the package.json modification is\n  // skipped but the lockfile update is executed, the lockfile will have a different result than if it was executed\n  // along with the changes to the package.json. Thus ending up with an incomplete branch update\n  // This is why we are skipping branch reuse in this case (#10050)\n  const groupedByPackageFile: Record<string, Set<RangeStrategy>> = {};\n  for (const upgrade of config.upgrades) {\n    const packageFile = upgrade.packageFile!;\n    groupedByPackageFile[packageFile] ??= new Set();\n    groupedByPackageFile[packageFile].add(upgrade.rangeStrategy!);\n\n    if (\n      groupedByPackageFile[packageFile].size > 1 &&\n      groupedByPackageFile[packageFile].has('update-lockfile')\n    ) {\n      logger.debug(\n        `Detected multiple rangeStrategies along with update-lockfile`\n      );\n      result.reuseExistingBranch = false;\n      result.isModified = false;\n      return result;\n    }\n  }\n\n  result.reuseExistingBranch = true;\n  result.isModified = false;\n  return result;\n}\n"]}