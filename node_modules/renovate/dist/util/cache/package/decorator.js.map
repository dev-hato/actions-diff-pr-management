{"version":3,"file":"decorator.js","sourceRoot":"","sources":["../../../../lib/util/cache/package/decorator.ts"],"names":[],"mappings":";;;;AAAA,kEAAkC;AAClC,+CAAsD;AACtD,wDAAkC;AAiClC;;GAEG;AACH,SAAgB,KAAK,CAAI,EACvB,SAAS,EACT,GAAG,EACH,SAAS,GAAG,GAAG,EAAE,CAAC,IAAI,EACtB,UAAU,GAAG,EAAE,GACC;IAChB,OAAO,IAAA,oBAAQ,EAAC,KAAK,EAAE,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,EAAE,EAAE;QACrD,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAI,CAAC,EAAE;YACpC,OAAO,QAAQ,EAAE,CAAC;SACnB;QAED,IAAI,cAAkC,CAAC;QACvC,IAAI,YAAE,CAAC,MAAM,CAAC,SAAS,CAAC,EAAE;YACxB,cAAc,GAAG,SAAS,CAAC;SAC5B;aAAM,IAAI,YAAE,CAAC,SAAS,CAAC,SAAS,CAAC,EAAE;YAClC,cAAc,GAAG,SAAS,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;SAClD;QAED,IAAI,QAA4B,CAAC;QACjC,IAAI,YAAE,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE;YAClB,QAAQ,GAAG,GAAG,CAAC;SAChB;aAAM,IAAI,YAAE,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE;YAC5B,QAAQ,GAAG,GAAG,CAAC,KAAK,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;SACtC;QAED,qBAAqB;QACrB,IAAI,CAAC,cAAc,IAAI,CAAC,QAAQ,EAAE;YAChC,OAAO,QAAQ,EAAE,CAAC;SACnB;QAED,MAAM,YAAY,GAAG,MAAM,YAAY,CAAC,GAAG,CACzC,cAAc,EACd,QAAQ,CACT,CAAC;QAEF,IAAI,YAAY,KAAK,SAAS,EAAE;YAC9B,OAAO,YAAY,CAAC;SACrB;QAED,MAAM,MAAM,GAAG,MAAM,QAAQ,EAAE,CAAC;QAEhC,sCAAsC;QACtC,IAAI,MAAM,KAAK,SAAS,EAAE;YACxB,MAAM,YAAY,CAAC,GAAG,CAAC,cAAc,EAAE,QAAQ,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC;SACtE;QACD,OAAO,MAAM,CAAC;IAChB,CAAC,CAAC,CAAC;AACL,CAAC;AA/CD,sBA+CC","sourcesContent":["import is from '@sindresorhus/is';\nimport { Decorator, decorate } from '../../decorator';\nimport * as packageCache from '.';\n\ntype HashFunction<T extends any[] = any[]> = (...args: T) => string;\ntype BooleanFunction<T extends any[] = any[]> = (...args: T) => boolean;\n\n/**\n * The cache decorator parameters.\n */\ninterface CacheParameters {\n  /**\n   * The cache namespace\n   * Either a string or a hash function that generates a string\n   */\n  namespace: string | HashFunction;\n\n  /**\n   * The cache key\n   * Either a string or a hash function that generates a string\n   */\n  key: string | HashFunction;\n\n  /**\n   * A function that returns true if a result is cacheable\n   * Used to prevent caching of private, sensitive, results\n   */\n  cacheable?: BooleanFunction;\n\n  /**\n   * The TTL (or expiry) of the key in minutes\n   */\n  ttlMinutes?: number;\n}\n\n/**\n * caches the result of a decorated method.\n */\nexport function cache<T>({\n  namespace,\n  key,\n  cacheable = () => true,\n  ttlMinutes = 30,\n}: CacheParameters): Decorator<T> {\n  return decorate(async ({ args, instance, callback }) => {\n    if (!cacheable.apply(instance, args)) {\n      return callback();\n    }\n\n    let finalNamespace: string | undefined;\n    if (is.string(namespace)) {\n      finalNamespace = namespace;\n    } else if (is.function_(namespace)) {\n      finalNamespace = namespace.apply(instance, args);\n    }\n\n    let finalKey: string | undefined;\n    if (is.string(key)) {\n      finalKey = key;\n    } else if (is.function_(key)) {\n      finalKey = key.apply(instance, args);\n    }\n\n    // istanbul ignore if\n    if (!finalNamespace || !finalKey) {\n      return callback();\n    }\n\n    const cachedResult = await packageCache.get<unknown>(\n      finalNamespace,\n      finalKey\n    );\n\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    }\n\n    const result = await callback();\n\n    // only cache if we got a valid result\n    if (result !== undefined) {\n      await packageCache.set(finalNamespace, finalKey, result, ttlMinutes);\n    }\n    return result;\n  });\n}\n"]}