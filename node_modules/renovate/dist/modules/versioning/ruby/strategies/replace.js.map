{"version":3,"file":"replace.js","sourceRoot":"","sources":["../../../../../lib/modules/versioning/ruby/strategies/replace.ts"],"names":[],"mappings":"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","sourcesContent":["import { satisfies } from '@renovatebot/ruby-semver';\nimport { logger } from '../../../../logger';\nimport bump from './bump';\n\nfunction countInstancesOf(str: string, char: string): number {\n  return str.split(char).length - 1;\n}\n\nfunction isMajorRange(range: string): boolean {\n  const splitRange = range.split(',').map((part) => part.trim());\n  return (\n    splitRange.length === 1 &&\n    splitRange[0]?.startsWith('~>') &&\n    countInstancesOf(splitRange[0], '.') === 0\n  );\n}\n\nfunction isCommonRubyMajorRange(range: string): boolean {\n  const splitRange = range.split(',').map((part) => part.trim());\n  return (\n    splitRange.length === 2 &&\n    splitRange[0]?.startsWith('~>') &&\n    countInstancesOf(splitRange[0], '.') === 1 &&\n    splitRange[1]?.startsWith('>=')\n  );\n}\n\nfunction isCommonRubyMinorRange(range: string): boolean {\n  const splitRange = range.split(',').map((part) => part.trim());\n  return (\n    splitRange.length === 2 &&\n    splitRange[0]?.startsWith('~>') &&\n    countInstancesOf(splitRange[0], '.') === 2 &&\n    splitRange[1]?.startsWith('>=')\n  );\n}\n\nfunction reduceOnePrecision(version: string): string {\n  const versionParts = version.split('.');\n  // istanbul ignore if\n  if (versionParts.length === 1) {\n    return version;\n  }\n  versionParts.pop();\n  return versionParts.join('.');\n}\n\nexport function matchPrecision(existing: string, next: string): string {\n  let res = next;\n  while (res.split('.').length > existing.split('.').length) {\n    res = reduceOnePrecision(res);\n  }\n  return res;\n}\n\nexport default ({ to, range }: { range: string; to: string }): string => {\n  if (satisfies(to, range)) {\n    return range;\n  }\n  let newRange;\n  if (isCommonRubyMajorRange(range)) {\n    const firstPart = reduceOnePrecision(to);\n    newRange = `~> ${firstPart}, >= ${to}`;\n  } else if (isCommonRubyMinorRange(range)) {\n    const firstPart = reduceOnePrecision(to) + '.0';\n    newRange = `~> ${firstPart}, >= ${to}`;\n  } else if (isMajorRange(range)) {\n    const majorPart = to.split('.')[0];\n    newRange = '~>' + (range.includes(' ') ? ' ' : '') + majorPart;\n  } else {\n    const lastPart = range\n      .split(',')\n      .map((part) => part.trim())\n      .slice(-1)\n      .join();\n    const lastPartPrecision = lastPart.split('.').length;\n    const toPrecision = to.split('.').length;\n    let massagedTo: string = to;\n    if (!lastPart.startsWith('<') && toPrecision > lastPartPrecision) {\n      massagedTo = to.split('.').slice(0, lastPartPrecision).join('.');\n    }\n    const newLastPart = bump({ to: massagedTo, range: lastPart });\n    newRange = range.replace(lastPart, newLastPart);\n    const firstPart = range\n      .split(',')\n      .map((part) => part.trim())\n      .shift();\n    if (firstPart && !satisfies(to, firstPart)) {\n      let newFirstPart = bump({ to: massagedTo, range: firstPart });\n      newFirstPart = matchPrecision(firstPart, newFirstPart);\n      newRange = newRange.replace(firstPart, newFirstPart);\n    }\n  }\n  // istanbul ignore if\n  if (!satisfies(to, newRange)) {\n    logger.warn(\n      { range, to, newRange },\n      'Ruby versioning getNewValue problem: to version is not satisfied by new range'\n    );\n    return range;\n  }\n  return newRange;\n};\n"]}