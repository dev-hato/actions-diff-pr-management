"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CpanDatasource = void 0;
const tslib_1 = require("tslib");
const decorator_1 = require("../../../util/cache/package/decorator");
const url_1 = require("../../../util/url");
const perlVersioning = tslib_1.__importStar(require("../../versioning/perl"));
const datasource_1 = require("../datasource");
class CpanDatasource extends datasource_1.Datasource {
    constructor() {
        super(CpanDatasource.id);
        this.customRegistrySupport = false;
        this.defaultRegistryUrls = ['https://fastapi.metacpan.org/'];
        this.defaultVersioning = perlVersioning.id;
    }
    async getReleases({ packageName, registryUrl, }) {
        // istanbul ignore if
        if (!registryUrl) {
            return null;
        }
        let result = null;
        const searchUrl = (0, url_1.joinUrlParts)(registryUrl, 'v1/file/_search');
        let hits = null;
        try {
            const body = {
                query: {
                    filtered: {
                        query: { match_all: {} },
                        filter: {
                            and: [
                                { term: { 'module.name': packageName } },
                                { exists: { field: 'module.associated_pod' } },
                            ],
                        },
                    },
                },
                _source: [
                    'module.name',
                    'module.version',
                    'distribution',
                    'date',
                    'deprecated',
                    'maturity',
                ],
                sort: [{ date: 'desc' }],
            };
            const res = await this.http.postJson(searchUrl, { body });
            hits = res.body?.hits?.hits?.map(({ _source }) => _source);
        }
        catch (err) {
            this.handleGenericErrors(err);
        }
        let latestDistribution = null;
        if (hits) {
            const releases = [];
            for (const hit of hits) {
                const { module, distribution, date: releaseTimestamp, deprecated: isDeprecated, maturity, } = hit;
                const version = module.find(({ name }) => name === packageName)?.version;
                if (version) {
                    // https://metacpan.org/pod/CPAN::DistnameInfo#maturity
                    const isStable = maturity === 'released';
                    releases.push({
                        isDeprecated,
                        isStable,
                        releaseTimestamp,
                        version,
                    });
                    if (!latestDistribution) {
                        latestDistribution = distribution;
                    }
                }
            }
            if (releases.length > 0 && latestDistribution) {
                result = {
                    releases,
                    changelogUrl: `https://metacpan.org/dist/${latestDistribution}/changes`,
                    homepage: `https://metacpan.org/pod/${packageName}`,
                };
            }
        }
        return result;
    }
}
CpanDatasource.id = 'cpan';
tslib_1.__decorate([
    (0, decorator_1.cache)({
        namespace: `datasource-${CpanDatasource.id}`,
        key: ({ packageName }) => `${packageName}`,
    })
], CpanDatasource.prototype, "getReleases", null);
exports.CpanDatasource = CpanDatasource;
//# sourceMappingURL=index.js.map