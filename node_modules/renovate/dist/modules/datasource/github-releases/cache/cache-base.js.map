{"version":3,"file":"cache-base.js","sourceRoot":"","sources":["../../../../../lib/modules/datasource/github-releases/cache/cache-base.ts"],"names":[],"mappings":"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","sourcesContent":["import { DateTime, DurationLikeObject } from 'luxon';\nimport { logger } from '../../../../logger';\nimport * as packageCache from '../../../../util/cache/package';\nimport type {\n  GithubGraphqlResponse,\n  GithubHttp,\n} from '../../../../util/http/github';\nimport type { GetReleasesConfig } from '../../types';\nimport { getApiBaseUrl } from '../common';\nimport type {\n  CacheOptions,\n  ChangelogRelease,\n  GithubDatasourceCache,\n  GithubQueryParams,\n  QueryResponse,\n  StoredItemBase,\n} from './types';\n\n/**\n * The options that are meant to be used in production.\n */\nconst cacheDefaults: Required<CacheOptions> = {\n  /**\n   * How many minutes to wait until next cache update\n   */\n  updateAfterMinutes: 120,\n\n  /**\n   * If package was released recently, we assume higher\n   * probability of having one more release soon.\n   *\n   * In this case, we use `updateAfterMinutesFresh` option.\n   */\n  packageFreshDays: 7,\n\n  /**\n   * If package was released recently, we assume higher\n   * probability of having one more release soon.\n   *\n   * In this case, this option will be used\n   * instead of `updateAfterMinutes`.\n   *\n   * Fresh period is configured via `freshDays` option.\n   */\n  updateAfterMinutesFresh: 30,\n\n  /**\n   * How many days to wait until full cache reset (for single package).\n   */\n  resetAfterDays: 7,\n\n  /**\n   * Delays cache reset by some random amount of minutes,\n   * in order to stabilize load during mass cache reset.\n   */\n  resetDeltaMinutes: 3 * 60,\n\n  /**\n   * How many days ago the package should be published to be considered as stable.\n   * Since this period is expired, it won't be refreshed via soft updates anymore.\n   */\n  unstableDays: 30,\n\n  /**\n   * How many items per page to obtain per page during initial fetch (i.e. pre-fetch)\n   */\n  itemsPerPrefetchPage: 100,\n\n  /**\n   * How many pages to fetch (at most) during the initial fetch (i.e. pre-fetch)\n   */\n  maxPrefetchPages: 100,\n\n  /**\n   * How many items per page to obtain per page during the soft update\n   */\n  itemsPerUpdatePage: 100,\n\n  /**\n   * How many pages to fetch (at most) during the soft update\n   */\n  maxUpdatePages: 100,\n};\n\n/**\n * Tells whether the time `duration` is expired starting\n * from the `date` (ISO date format) at the moment of `now`.\n */\nfunction isExpired(\n  now: DateTime,\n  date: string,\n  duration: DurationLikeObject\n): boolean {\n  const then = DateTime.fromISO(date);\n  const expiry = then.plus(duration);\n  return now >= expiry;\n}\n\nexport abstract class AbstractGithubDatasourceCache<\n  StoredItem extends StoredItemBase,\n  FetchedItem = unknown\n> {\n  private updateDuration: DurationLikeObject;\n  private packageFreshDaysDuration: DurationLikeObject;\n  private updateDurationFresh: DurationLikeObject;\n  private resetDuration: DurationLikeObject;\n  private stabilityDuration: DurationLikeObject;\n\n  private maxPrefetchPages: number;\n  private itemsPerPrefetchPage: number;\n\n  private maxUpdatePages: number;\n  private itemsPerUpdatePage: number;\n\n  private resetDeltaMinutes: number;\n\n  constructor(private http: GithubHttp, opts: CacheOptions = {}) {\n    const {\n      updateAfterMinutes,\n      packageFreshDays,\n      updateAfterMinutesFresh,\n      resetAfterDays,\n      unstableDays,\n      maxPrefetchPages,\n      itemsPerPrefetchPage,\n      maxUpdatePages,\n      itemsPerUpdatePage,\n      resetDeltaMinutes,\n    } = {\n      ...cacheDefaults,\n      ...opts,\n    };\n\n    this.updateDuration = { minutes: updateAfterMinutes };\n    this.packageFreshDaysDuration = { days: packageFreshDays };\n    this.updateDurationFresh = { minutes: updateAfterMinutesFresh };\n    this.resetDuration = { days: resetAfterDays };\n    this.stabilityDuration = { days: unstableDays };\n\n    this.maxPrefetchPages = maxPrefetchPages;\n    this.itemsPerPrefetchPage = itemsPerPrefetchPage;\n    this.maxUpdatePages = maxUpdatePages;\n    this.itemsPerUpdatePage = itemsPerUpdatePage;\n\n    this.resetDeltaMinutes = resetDeltaMinutes;\n  }\n\n  /**\n   * The key at which data is stored in the package cache.\n   */\n  abstract readonly cacheNs: string;\n\n  /**\n   * The query string.\n   * For parameters, see `GithubQueryParams`.\n   */\n  abstract readonly graphqlQuery: string;\n\n  /**\n   * Transform `fetchedItem` for storing in the package cache.\n   * @param fetchedItem Node obtained from GraphQL response\n   */\n  abstract coerceFetched(fetchedItem: FetchedItem): StoredItem | null;\n\n  private async query(\n    baseUrl: string,\n    variables: GithubQueryParams\n  ): Promise<QueryResponse<FetchedItem> | Error> {\n    try {\n      const graphqlRes = await this.http.postJson<\n        GithubGraphqlResponse<QueryResponse<FetchedItem>>\n      >('/graphql', {\n        baseUrl,\n        body: { query: this.graphqlQuery, variables },\n      });\n      const { body } = graphqlRes;\n      const { data, errors } = body;\n      return data ?? new Error(errors?.[0]?.message);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  /**\n   * Pre-fetch, update, or just return the package cache items.\n   */\n  async getItems(\n    releasesConfig: GetReleasesConfig,\n    changelogRelease?: ChangelogRelease\n  ): Promise<StoredItem[]> {\n    const { packageName, registryUrl } = releasesConfig;\n\n    // The time meant to be used across the function\n    const now = DateTime.now();\n\n    // Initialize items and timestamps for the new cache\n    let cacheItems: Record<string, StoredItem> = {};\n\n    // Add random minutes to the creation date in order to\n    // provide back-off time during mass cache invalidation.\n    const randomDelta = this.getRandomDeltaMinutes();\n    let cacheCreatedAt = now.plus(randomDelta).toISO();\n\n    // We have to initialize `updatedAt` value as already expired,\n    // so that soft update mechanics is immediately starting.\n    let cacheUpdatedAt = now.minus(this.updateDuration).toISO();\n\n    const baseUrl = getApiBaseUrl(registryUrl).replace(/\\/v3\\/$/, '/'); // Replace for GHE\n\n    const [owner, name] = packageName.split('/');\n    if (owner && name) {\n      const cacheKey = `${baseUrl}:${owner}:${name}`;\n      const cache = await packageCache.get<GithubDatasourceCache<StoredItem>>(\n        this.cacheNs,\n        cacheKey\n      );\n\n      const cacheDoesExist =\n        cache && !isExpired(now, cache.createdAt, this.resetDuration);\n      let lastReleasedAt: string | null = null;\n      let updateDuration = this.updateDuration;\n      if (cacheDoesExist) {\n        // Keeping the the original `cache` value intact\n        // in order to be used in exception handler\n        cacheItems = { ...cache.items };\n        cacheCreatedAt = cache.createdAt;\n        cacheUpdatedAt = cache.updatedAt;\n        lastReleasedAt =\n          cache.lastReleasedAt ?? this.getLastReleaseTimestamp(cacheItems);\n\n        // Release is considered fresh, so we'll check it earlier\n        if (\n          lastReleasedAt &&\n          !isExpired(now, lastReleasedAt, this.packageFreshDaysDuration)\n        ) {\n          updateDuration = this.updateDurationFresh;\n        }\n      }\n\n      if (\n        isExpired(now, cacheUpdatedAt, updateDuration) ||\n        this.newChangelogReleaseDetected(\n          changelogRelease,\n          now,\n          updateDuration,\n          cacheItems\n        )\n      ) {\n        const variables: GithubQueryParams = {\n          owner,\n          name,\n          cursor: null,\n          count: cacheDoesExist\n            ? this.itemsPerUpdatePage\n            : this.itemsPerPrefetchPage,\n        };\n\n        // Collect version values to determine deleted items\n        const checkedVersions = new Set<string>();\n\n        // Page-by-page update loop\n        let pagesRemained = cacheDoesExist\n          ? this.maxUpdatePages\n          : this.maxPrefetchPages;\n        let stopIteration = false;\n        while (pagesRemained > 0 && !stopIteration) {\n          const res = await this.query(baseUrl, variables);\n          if (res instanceof Error) {\n            if (\n              res.message.startsWith(\n                'Something went wrong while executing your query.' // #16343\n              ) &&\n              variables.count > 30\n            ) {\n              logger.warn(\n                `GitHub datasource cache: shrinking GraphQL page size due to error`\n              );\n              pagesRemained *= 2;\n              variables.count = Math.floor(variables.count / 2);\n              continue;\n            }\n            throw res;\n          }\n\n          pagesRemained -= 1;\n\n          const {\n            nodes: fetchedItems,\n            pageInfo: { hasNextPage, endCursor },\n          } = res.repository.payload;\n\n          if (hasNextPage) {\n            variables.cursor = endCursor;\n          } else {\n            stopIteration = true;\n          }\n\n          for (const item of fetchedItems) {\n            const newStoredItem = this.coerceFetched(item);\n            if (newStoredItem) {\n              const { version, releaseTimestamp } = newStoredItem;\n\n              // Stop earlier if the stored item have reached stability,\n              // which means `unstableDays` period have passed\n              const oldStoredItem = cacheItems[version];\n              if (\n                oldStoredItem &&\n                isExpired(\n                  now,\n                  oldStoredItem.releaseTimestamp,\n                  this.stabilityDuration\n                )\n              ) {\n                stopIteration = true;\n              }\n\n              cacheItems[version] = newStoredItem;\n              checkedVersions.add(version);\n\n              lastReleasedAt ??= releaseTimestamp;\n              // It may be tempting to optimize the code and\n              // remove the check, as we're fetching fresh releases here.\n              // That's wrong, because some items are already cached,\n              // and they obviously aren't latest.\n              if (\n                DateTime.fromISO(releaseTimestamp) >\n                DateTime.fromISO(lastReleasedAt)\n              ) {\n                lastReleasedAt = releaseTimestamp;\n              }\n            }\n          }\n        }\n\n        // Detect removed items\n        for (const [version, item] of Object.entries(cacheItems)) {\n          if (\n            !isExpired(now, item.releaseTimestamp, this.stabilityDuration) &&\n            !checkedVersions.has(version)\n          ) {\n            delete cacheItems[version];\n          }\n        }\n\n        // Store cache\n        const expiry = DateTime.fromISO(cacheCreatedAt).plus(\n          this.resetDuration\n        );\n        const { minutes: ttlMinutes } = expiry\n          .diff(now, ['minutes'])\n          .toObject();\n        if (ttlMinutes && ttlMinutes > 0) {\n          const cacheValue: GithubDatasourceCache<StoredItem> = {\n            items: cacheItems,\n            createdAt: cacheCreatedAt,\n            updatedAt: now.toISO(),\n          };\n\n          if (lastReleasedAt) {\n            cacheValue.lastReleasedAt = lastReleasedAt;\n          }\n\n          await packageCache.set(\n            this.cacheNs,\n            cacheKey,\n            cacheValue,\n            ttlMinutes\n          );\n        }\n      }\n    }\n\n    const items = Object.values(cacheItems);\n    return items;\n  }\n\n  getRandomDeltaMinutes(): number {\n    const rnd = Math.random();\n    return Math.floor(rnd * this.resetDeltaMinutes);\n  }\n\n  public getLastReleaseTimestamp(\n    items: Record<string, StoredItem>\n  ): string | null {\n    let result: string | null = null;\n    let latest: DateTime | null = null;\n\n    for (const { releaseTimestamp } of Object.values(items)) {\n      const timestamp = DateTime.fromISO(releaseTimestamp);\n\n      result ??= releaseTimestamp;\n      latest ??= timestamp;\n\n      if (timestamp > latest) {\n        result = releaseTimestamp;\n        latest = timestamp;\n      }\n    }\n\n    return result;\n  }\n\n  newChangelogReleaseDetected(\n    changelogRelease: ChangelogRelease | undefined,\n    now: DateTime,\n    updateDuration: DurationLikeObject,\n    cacheItems: Record<string, StoredItem>\n  ): boolean {\n    if (!changelogRelease) {\n      return false;\n    }\n\n    const releaseTime = changelogRelease.date.toString();\n    const isVersionPresentInCache = !!cacheItems[changelogRelease.version];\n    const isChangelogReleaseFresh = !isExpired(\n      now,\n      releaseTime,\n      updateDuration\n    );\n\n    if (isVersionPresentInCache || !isChangelogReleaseFresh) {\n      return false;\n    }\n\n    return true;\n  }\n}\n"]}