{"version":3,"file":"tokenizer.js","sourceRoot":"","sources":["../../../../lib/modules/manager/gradle/tokenizer.ts"],"names":[],"mappings":"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","sourcesContent":["import moo from 'moo';\nimport { regEx } from '../../../util/regex';\nimport { TokenType } from './common';\nimport type { StringInterpolation, Token } from './types';\n\nconst escapedCharRegex = /\\\\['\"bfnrt\\\\]/; // TODO #12870\nconst escapedChars = {\n  [TokenType.EscapedChar]: {\n    match: escapedCharRegex,\n    value: (x: string): string =>\n      /* istanbul ignore next */\n      ({\n        \"\\\\'\": \"'\",\n        '\\\\\"': '\"',\n        '\\\\b': '\\b',\n        '\\\\f': '\\f',\n        '\\\\n': '\\n',\n        '\\\\r': '\\r',\n        '\\\\t': '\\t',\n        '\\\\\\\\': '\\\\',\n      }[x] ?? x),\n  },\n};\n\nconst lexer = moo.states({\n  // Top-level Groovy lexemes\n  main: {\n    [TokenType.LineComment]: { match: /\\/\\/.*?$/ }, // TODO #12870\n    [TokenType.MultiComment]: { match: /\\/\\*[^]*?\\*\\//, lineBreaks: true }, // TODO #12870\n    [TokenType.Newline]: { match: /\\r?\\n/, lineBreaks: true }, // TODO #12870\n    [TokenType.Space]: { match: /[ \\t\\r]+/ }, // TODO #12870\n    [TokenType.Semicolon]: ';',\n    [TokenType.Colon]: ':',\n    [TokenType.Dot]: '.',\n    [TokenType.Comma]: ',',\n    [TokenType.Operator]: /(?:==|\\+=?|-=?|\\/=?|\\*\\*?|\\.+|:)/, // TODO #12870\n    [TokenType.Assignment]: '=',\n    [TokenType.Word]: { match: /[a-zA-Z$_][a-zA-Z0-9$_]*/ }, // TODO #12870\n    [TokenType.LeftParen]: { match: '(' },\n    [TokenType.RightParen]: { match: ')' },\n    [TokenType.LeftBracket]: { match: '[' },\n    [TokenType.RightBracket]: { match: ']' },\n    [TokenType.LeftBrace]: { match: '{', push: 'main' },\n    [TokenType.RightBrace]: { match: '}', pop: 1 },\n    [TokenType.TripleSingleQuotedStart]: {\n      match: \"'''\",\n      push: TokenType.TripleSingleQuotedStart,\n    },\n    [TokenType.TripleDoubleQuotedStart]: {\n      match: '\"\"\"',\n      push: TokenType.TripleDoubleQuotedStart,\n    },\n    [TokenType.SingleQuotedStart]: {\n      match: \"'\",\n      push: TokenType.SingleQuotedStart,\n    },\n    [TokenType.DoubleQuotedStart]: {\n      match: '\"',\n      push: TokenType.DoubleQuotedStart,\n    },\n    [TokenType.UnknownFragment]: moo.fallback,\n  },\n\n  // Tokenize triple-quoted string literal characters\n  [TokenType.TripleSingleQuotedStart]: {\n    ...escapedChars,\n    [TokenType.TripleQuotedFinish]: { match: \"'''\", pop: 1 },\n    [TokenType.Chars]: moo.fallback,\n  },\n  [TokenType.TripleDoubleQuotedStart]: {\n    ...escapedChars,\n    [TokenType.TripleQuotedFinish]: { match: '\"\"\"', pop: 1 },\n    [TokenType.Chars]: moo.fallback,\n  },\n\n  // Tokenize single-quoted string literal characters\n  [TokenType.SingleQuotedStart]: {\n    ...escapedChars,\n    [TokenType.SingleQuotedFinish]: { match: \"'\", pop: 1 },\n    [TokenType.Chars]: moo.fallback,\n  },\n\n  // Tokenize double-quoted string literal chars and interpolations\n  [TokenType.DoubleQuotedStart]: {\n    ...escapedChars,\n    [TokenType.DoubleQuotedFinish]: { match: '\"', pop: 1 },\n    variable: {\n      // Supported: ${foo}, $foo, ${ foo.bar.baz }, $foo.bar.baz\n      match:\n        /\\${\\s*[a-zA-Z_][a-zA-Z0-9_]*(?:\\s*\\.\\s*[a-zA-Z_][a-zA-Z0-9_]*)*\\s*}|\\$[a-zA-Z_][a-zA-Z0-9_]*(?:\\.[a-zA-Z_][a-zA-Z0-9_]*)*/, // TODO #12870\n      value: (x: string): string =>\n        x.replace(regEx(/^\\${?\\s*/), '').replace(regEx(/\\s*}$/), ''),\n    },\n    [TokenType.IgnoredInterpolationStart]: {\n      match: /\\${/, // TODO #12870\n      push: TokenType.IgnoredInterpolationStart,\n    },\n    [TokenType.Chars]: moo.fallback,\n  },\n\n  // Ignore interpolation of complex expressions˙,\n  // but track the balance of braces to find the end of interpolation.\n  [TokenType.IgnoredInterpolationStart]: {\n    [TokenType.LeftBrace]: {\n      match: '{',\n      push: TokenType.IgnoredInterpolationStart,\n    },\n    [TokenType.RightBrace]: { match: '}', pop: 1 },\n    [TokenType.UnknownFragment]: moo.fallback,\n  },\n});\n\n//\n// Turn substrings of chars and escaped chars into single String token\n//\nfunction processChars(acc: Token[], token: Token): Token[] {\n  const tokenType = token.type;\n  const prevToken: Token = acc[acc.length - 1];\n  if ([TokenType.Chars, TokenType.EscapedChar].includes(tokenType)) {\n    // istanbul ignore if\n    if (prevToken?.type === TokenType.String) {\n      prevToken.value += token.value;\n    } else {\n      acc.push({ ...token, type: TokenType.String });\n    }\n  } else {\n    acc.push(token);\n  }\n  return acc;\n}\n\nexport function isInterpolationToken(\n  token: Token\n): token is StringInterpolation {\n  return token?.type === TokenType.StringInterpolation;\n}\n\n//\n// Turn all tokens between double quote pairs into StringInterpolation token\n//\nfunction processInterpolation(acc: Token[], token: Token): Token[] {\n  if (token.type === TokenType.DoubleQuotedStart) {\n    // This token will accumulate further strings and variables\n    const interpolationToken: StringInterpolation = {\n      type: TokenType.StringInterpolation,\n      children: [],\n      isValid: true,\n      isComplete: false,\n      offset: token.offset + 1,\n      value: '',\n    };\n    acc.push(interpolationToken);\n    return acc;\n  }\n\n  const prevToken: Token = acc[acc.length - 1];\n  if (isInterpolationToken(prevToken) && !prevToken.isComplete) {\n    const type = token.type;\n    if (type === TokenType.DoubleQuotedFinish) {\n      if (\n        prevToken.isValid &&\n        prevToken.children.every(({ type: t }) => t === TokenType.String)\n      ) {\n        // Nothing to interpolate, replace to String\n        acc[acc.length - 1] = {\n          type: TokenType.String,\n          value: prevToken.children.map(({ value }) => value).join(''),\n          offset: prevToken.offset,\n        };\n        return acc;\n      }\n      prevToken.isComplete = true;\n    } else if (type === TokenType.String || type === TokenType.Variable) {\n      prevToken.children.push(token);\n    } else {\n      prevToken.children.push(token);\n      prevToken.isValid = false;\n    }\n  } else {\n    acc.push(token);\n  }\n  return acc;\n}\n\nconst filteredTokens = [\n  TokenType.Space,\n  TokenType.LineComment,\n  TokenType.MultiComment,\n  TokenType.Newline,\n  TokenType.Semicolon,\n  TokenType.SingleQuotedStart,\n  TokenType.SingleQuotedFinish,\n  TokenType.DoubleQuotedFinish,\n  TokenType.TripleSingleQuotedStart,\n  TokenType.TripleDoubleQuotedStart,\n  TokenType.TripleQuotedFinish,\n];\n\nfunction filterTokens({ type }: Token): boolean {\n  return !filteredTokens.includes(type);\n}\n\nexport function extractRawTokens(input: string): Token[] {\n  lexer.reset(input);\n  return Array.from(lexer).map(\n    ({ type, offset, value }) => ({ type, offset, value } as Token)\n  );\n}\n\nexport function processTokens(tokens: Token[]): Token[] {\n  return tokens\n    .reduce(processChars, [])\n    .reduce(processInterpolation, [])\n    .filter(filterTokens);\n}\n\nexport function tokenize(input: string): Token[] {\n  return processTokens(extractRawTokens(input));\n}\n"]}