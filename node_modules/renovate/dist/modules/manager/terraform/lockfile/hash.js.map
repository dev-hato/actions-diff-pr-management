{"version":3,"file":"hash.js","sourceRoot":"","sources":["../../../../../lib/modules/manager/terraform/lockfile/hash.ts"],"names":[],"mappings":"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","sourcesContent":["import crypto from 'crypto';\nimport extract from 'extract-zip';\nimport pMap from 'p-map';\nimport upath from 'upath';\nimport { logger } from '../../../../logger';\nimport { cache } from '../../../../util/cache/package/decorator';\nimport * as fs from '../../../../util/fs';\nimport { ensureCacheDir } from '../../../../util/fs';\nimport { Http } from '../../../../util/http';\nimport { regEx } from '../../../../util/regex';\nimport { TerraformProviderDatasource } from '../../../datasource/terraform-provider';\nimport type { TerraformBuild } from '../../../datasource/terraform-provider/types';\n\nexport class TerraformProviderHash {\n  static http = new Http(TerraformProviderDatasource.id);\n\n  static terraformDatasource = new TerraformProviderDatasource();\n\n  static hashCacheTTL = 10080; // in minutes == 1 week\n\n  private static async hashFiles(files: string[]): Promise<string> {\n    const rootHash = crypto.createHash('sha256');\n\n    for (const file of files) {\n      // build for every file a line looking like \"aaaaaaaaaaaaaaa  file.txt\\n\"\n      const hash = crypto.createHash('sha256');\n\n      // a sha256sum displayed as lowercase hex string to root hash\n      const fileBuffer = await fs.readCacheFile(file);\n      hash.update(fileBuffer);\n      rootHash.update(hash.digest('hex'));\n\n      // add double space, the filename and a new line char\n      rootHash.update('  ');\n      const fileName = file.replace(regEx(/^.*[\\\\/]/), '');\n      rootHash.update(fileName);\n      rootHash.update('\\n');\n    }\n\n    return rootHash.digest('base64');\n  }\n\n  static async hashOfZipContent(\n    zipFilePath: string,\n    extractPath: string\n  ): Promise<string> {\n    await extract(zipFilePath, { dir: extractPath });\n    const files = await fs.listCacheDir(extractPath);\n    // the h1 hashing algorithms requires that the files are sorted by filename\n    const sortedFiles = files.sort((a, b) => a.localeCompare(b));\n    const filesWithPath = sortedFiles.map((file) => `${extractPath}/${file}`);\n\n    const result = await TerraformProviderHash.hashFiles(filesWithPath);\n\n    // delete extracted files\n    await fs.rmCache(extractPath);\n\n    return result;\n  }\n\n  @cache({\n    namespace: `datasource-${TerraformProviderDatasource.id}-build-hashes`,\n    key: (build: TerraformBuild) => build.url,\n    ttlMinutes: TerraformProviderHash.hashCacheTTL,\n  })\n  static async calculateSingleHash(\n    build: TerraformBuild,\n    cacheDir: string\n  ): Promise<string> {\n    const downloadFileName = upath.join(cacheDir, build.filename);\n    const extractPath = upath.join(cacheDir, 'extract', build.filename);\n    logger.trace(\n      `Downloading archive and generating hash for ${build.name}-${build.version}...`\n    );\n    const readStream = TerraformProviderHash.http.stream(build.url);\n    const writeStream = fs.createCacheWriteStream(downloadFileName);\n\n    try {\n      await fs.pipeline(readStream, writeStream);\n\n      const hash = await this.hashOfZipContent(downloadFileName, extractPath);\n      logger.trace(\n        { hash },\n        `Generated hash for ${build.name}-${build.version}`\n      );\n      return hash;\n    } finally {\n      // delete zip file\n      await fs.rmCache(downloadFileName);\n    }\n  }\n\n  static async calculateHashes(builds: TerraformBuild[]): Promise<string[]> {\n    const cacheDir = await ensureCacheDir('./others/terraform');\n\n    // for each build download ZIP, extract content and generate hash for all containing files\n    return pMap(\n      builds,\n      (build) => this.calculateSingleHash(build, cacheDir),\n      { concurrency: 4 } // allow to look up 4 builds for this version in parallel\n    );\n  }\n\n  static async createHashes(\n    registryURL: string,\n    repository: string,\n    version: string\n  ): Promise<string[] | null> {\n    const builds = await TerraformProviderHash.terraformDatasource.getBuilds(\n      registryURL,\n      repository,\n      version\n    );\n    if (!builds) {\n      return null;\n    }\n    const hashes = await TerraformProviderHash.calculateHashes(builds);\n\n    // sorting the hash alphabetically as terraform does this as well\n    return hashes.sort().map((hash) => `h1:${hash}`);\n  }\n}\n"]}