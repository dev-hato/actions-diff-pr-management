{"version":3,"file":"artifacts.js","sourceRoot":"","sources":["../../../../lib/modules/manager/nuget/artifacts.ts"],"names":[],"mappings":"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","sourcesContent":["import { quote } from 'shlex';\nimport { join } from 'upath';\nimport { TEMPORARY_ERROR } from '../../../constants/error-messages';\nimport { logger } from '../../../logger';\nimport { exec } from '../../../util/exec';\nimport type { ExecOptions } from '../../../util/exec/types';\nimport {\n  ensureDir,\n  getSiblingFileName,\n  outputCacheFile,\n  privateCacheDir,\n  readLocalFile,\n  writeLocalFile,\n} from '../../../util/fs';\nimport { getFile } from '../../../util/git';\nimport * as hostRules from '../../../util/host-rules';\nimport { regEx } from '../../../util/regex';\nimport { NugetDatasource } from '../../datasource/nuget';\nimport { parseRegistryUrl } from '../../datasource/nuget/common';\nimport type {\n  UpdateArtifact,\n  UpdateArtifactsConfig,\n  UpdateArtifactsResult,\n} from '../types';\nimport {\n  MSBUILD_CENTRAL_FILE,\n  NUGET_CENTRAL_FILE,\n  getDependentPackageFiles,\n} from './package-tree';\nimport { getConfiguredRegistries, getDefaultRegistries } from './util';\n\nasync function addSourceCmds(\n  packageFileName: string,\n  _config: UpdateArtifactsConfig,\n  nugetConfigFile: string\n): Promise<string[]> {\n  const registries =\n    (await getConfiguredRegistries(packageFileName)) ?? getDefaultRegistries();\n  const result: string[] = [];\n  for (const registry of registries) {\n    const { username, password } = hostRules.find({\n      hostType: NugetDatasource.id,\n      url: registry.url,\n    });\n    const registryInfo = parseRegistryUrl(registry.url);\n    let addSourceCmd = `dotnet nuget add source ${quote(\n      registryInfo.feedUrl\n    )} --configfile ${quote(nugetConfigFile)}`;\n    if (registry.name) {\n      // Add name for registry, if known.\n      addSourceCmd += ` --name ${quote(registry.name)}`;\n    }\n    if (username && password) {\n      // Add registry credentials from host rules, if configured.\n      addSourceCmd += ` --username ${quote(username)} --password ${quote(\n        password\n      )} --store-password-in-clear-text`;\n    }\n    result.push(addSourceCmd);\n  }\n  return result;\n}\n\nasync function runDotnetRestore(\n  packageFileName: string,\n  dependentPackageFileNames: string[],\n  config: UpdateArtifactsConfig\n): Promise<void> {\n  const nugetCacheDir = join(privateCacheDir(), 'nuget');\n\n  const execOptions: ExecOptions = {\n    docker: {\n      image: 'dotnet',\n    },\n    extraEnv: { NUGET_PACKAGES: join(nugetCacheDir, 'packages') },\n  };\n\n  const nugetConfigFile = join(nugetCacheDir, `nuget.config`);\n\n  await ensureDir(nugetCacheDir);\n\n  await outputCacheFile(\n    nugetConfigFile,\n    `<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n<configuration>\\n</configuration>\\n`\n  );\n\n  const cmds = [\n    ...(await addSourceCmds(packageFileName, config, nugetConfigFile)),\n    ...dependentPackageFileNames.map(\n      (fileName) =>\n        `dotnet restore ${quote(\n          fileName\n        )} --force-evaluate --configfile ${quote(nugetConfigFile)}`\n    ),\n  ];\n  await exec(cmds, execOptions);\n}\n\nasync function getLockFileContentMap(\n  lockFileNames: string[],\n  local = false\n): Promise<Record<string, string | null>> {\n  const lockFileContentMap: Record<string, string | null> = {};\n\n  for (const lockFileName of lockFileNames) {\n    lockFileContentMap[lockFileName] = local\n      ? await readLocalFile(lockFileName, 'utf8')\n      : await getFile(lockFileName);\n  }\n\n  return lockFileContentMap;\n}\n\nexport async function updateArtifacts({\n  packageFileName,\n  newPackageFileContent,\n  config,\n  updatedDeps,\n}: UpdateArtifact): Promise<UpdateArtifactsResult[] | null> {\n  logger.debug(`nuget.updateArtifacts(${packageFileName})`);\n\n  // https://github.com/NuGet/Home/wiki/Centrally-managing-NuGet-package-versions\n  // https://github.com/microsoft/MSBuildSdks/tree/main/src/CentralPackageVersions\n  const isCentralManament =\n    packageFileName === NUGET_CENTRAL_FILE ||\n    packageFileName === MSBUILD_CENTRAL_FILE ||\n    packageFileName.endsWith(`/${NUGET_CENTRAL_FILE}`) ||\n    packageFileName.endsWith(`/${MSBUILD_CENTRAL_FILE}`);\n\n  if (\n    !isCentralManament &&\n    !regEx(/(?:cs|vb|fs)proj$/i).test(packageFileName)\n  ) {\n    // This could be implemented in the future if necessary.\n    // It's not that easy though because the questions which\n    // project file to restore how to determine which lock files\n    // have been changed in such cases.\n    logger.debug(\n      { packageFileName },\n      'Not updating lock file for non project files'\n    );\n    return null;\n  }\n\n  const packageFiles = [\n    ...(await getDependentPackageFiles(packageFileName, isCentralManament)),\n  ];\n\n  if (!isCentralManament) {\n    packageFiles.push(packageFileName);\n  }\n\n  logger.trace(\n    { packageFiles },\n    `Found ${packageFiles.length} dependent package files`\n  );\n\n  const lockFileNames = packageFiles.map((f) =>\n    getSiblingFileName(f, 'packages.lock.json')\n  );\n\n  const existingLockFileContentMap = await getLockFileContentMap(lockFileNames);\n\n  const hasLockFileContent = Object.values(existingLockFileContentMap).some(\n    (val) => !!val\n  );\n  if (!hasLockFileContent) {\n    logger.debug(\n      { packageFileName },\n      'No lock file found for package or dependents'\n    );\n    return null;\n  }\n\n  try {\n    if (updatedDeps.length === 0 && config.isLockFileMaintenance !== true) {\n      logger.debug(\n        `Not updating lock file because no deps changed and no lock file maintenance.`\n      );\n      return null;\n    }\n\n    await writeLocalFile(packageFileName, newPackageFileContent);\n\n    await runDotnetRestore(packageFileName, packageFiles, config);\n\n    const newLockFileContentMap = await getLockFileContentMap(\n      lockFileNames,\n      true\n    );\n\n    const retArray: UpdateArtifactsResult[] = [];\n    for (const lockFileName of lockFileNames) {\n      if (\n        existingLockFileContentMap[lockFileName] ===\n        newLockFileContentMap[lockFileName]\n      ) {\n        logger.trace(`Lock file ${lockFileName} is unchanged`);\n      } else if (newLockFileContentMap[lockFileName]) {\n        retArray.push({\n          file: {\n            type: 'addition',\n            path: lockFileName,\n            contents: newLockFileContentMap[lockFileName]!,\n          },\n        });\n      }\n      // TODO: else should we return an artifact error if new content is missing?\n    }\n\n    return retArray.length > 0 ? retArray : null;\n  } catch (err) {\n    // istanbul ignore if\n    if (err.message === TEMPORARY_ERROR) {\n      throw err;\n    }\n    logger.debug({ err }, 'Failed to generate lock file');\n    return [\n      {\n        artifactError: {\n          lockFile: lockFileNames.join(', '),\n          // error is written to stdout\n          stderr: err.stdout || err.message,\n        },\n      },\n    ];\n  }\n}\n"]}