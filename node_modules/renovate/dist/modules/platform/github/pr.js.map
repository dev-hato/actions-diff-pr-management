{"version":3,"file":"pr.js","sourceRoot":"","sources":["../../../../lib/modules/platform/github/pr.ts"],"names":[],"mappings":"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","sourcesContent":["import is from '@sindresorhus/is';\nimport { PlatformId } from '../../../constants';\nimport { logger } from '../../../logger';\nimport { ExternalHostError } from '../../../types/errors/external-host-error';\nimport { getCache } from '../../../util/cache/repository';\nimport type { GithubHttp, GithubHttpOptions } from '../../../util/http/github';\nimport { parseLinkHeader } from '../../../util/url';\nimport { getPrBodyStruct } from '../pr-body';\nimport type { Pr } from '../types';\nimport { ApiCache } from './api-cache';\nimport { coerceRestPr } from './common';\nimport type { ApiPageCache, GhRestPr } from './types';\n\nfunction removeUrlFields(input: unknown): void {\n  if (is.plainObject(input)) {\n    for (const [key, val] of Object.entries(input)) {\n      if ((key === 'url' || key.endsWith('_url')) && is.string(val)) {\n        delete input[key];\n      } else {\n        removeUrlFields(val);\n      }\n    }\n  }\n}\n\nfunction compactPrBodyStructure(input: unknown): void {\n  if (is.plainObject(input)) {\n    if (!input.bodyStruct && is.string(input.body)) {\n      input.bodyStruct = getPrBodyStruct(input.body);\n      delete input.body;\n    }\n  }\n}\n\nfunction massageGhRestPr(ghPr: GhRestPr): GhRestPr {\n  removeUrlFields(ghPr);\n  delete ghPr.head?.repo?.pushed_at;\n  delete ghPr.base?.repo?.pushed_at;\n  delete ghPr._links;\n\n  compactPrBodyStructure(ghPr);\n\n  return ghPr;\n}\n\nfunction getPrApiCache(): ApiCache<GhRestPr> {\n  const repoCache = getCache();\n  repoCache.platform ??= {};\n  repoCache.platform.github ??= {};\n  repoCache.platform.github.prCache ??= { items: {} };\n  const apiPageCache = repoCache.platform.github\n    .prCache as ApiPageCache<GhRestPr>;\n\n  const items = Object.values(apiPageCache.items);\n\n  const firstItem = items?.[0];\n  if (firstItem?.body) {\n    apiPageCache.items = {};\n  } else if (firstItem?._links) {\n    for (const ghPr of items) {\n      massageGhRestPr(ghPr);\n    }\n  }\n\n  const prCache = new ApiCache(apiPageCache);\n  return prCache;\n}\n\n/**\n *  Fetch and return Pull Requests from GitHub repository:\n *\n *   1. Synchronize long-term cache.\n *\n *   2. Store items in raw format, i.e. exactly what\n *      has been returned by GitHub REST API.\n *\n *   3. Convert items to the Renovate format and return.\n *\n * In order synchronize ApiCache properly, we handle 3 cases:\n *\n *   a. We never fetched PR list for this repo before.\n *      If cached PR list is empty, we assume it's the case.\n *\n *      In this case, we're falling back to quick fetch via\n *      `paginate=true` option (see `util/http/github.ts`).\n *\n *   b. Some of PRs had changed since last run.\n *\n *      In this case, we sequentially fetch page by page\n *      until `ApiCache.coerce` function indicates that\n *      no more fresh items can be found in the next page.\n *\n *      We expect to fetch just one page per run in average,\n *      since it's rare to have more than 100 updated PRs.\n */\nexport async function getPrCache(\n  http: GithubHttp,\n  repo: string,\n  username: string | null\n): Promise<Record<number, Pr>> {\n  const prCache: Record<number, Pr> = {};\n  const prApiCache = getPrApiCache();\n  const isInitial = is.emptyArray(prApiCache.getItems());\n\n  try {\n    let requestsTotal = 0;\n    let apiQuotaAffected = false;\n    let needNextPageFetch = true;\n    let needNextPageSync = true;\n\n    let pageIdx = 1;\n    while (needNextPageFetch && needNextPageSync) {\n      const opts: GithubHttpOptions = { paginate: false };\n      if (pageIdx === 1 && isInitial) {\n        // Speed up initial fetch\n        opts.paginate = true;\n      }\n\n      const perPage = isInitial ? 100 : 20;\n      const urlPath = `repos/${repo}/pulls?per_page=${perPage}&state=all&sort=updated&direction=desc&page=${pageIdx}`;\n\n      const res = await http.getJson<GhRestPr[]>(urlPath, opts);\n      apiQuotaAffected = true;\n      requestsTotal += 1;\n\n      const {\n        headers: { link: linkHeader },\n      } = res;\n\n      let { body: page } = res;\n\n      if (username) {\n        page = page.filter(\n          (ghPr) => ghPr?.user?.login && ghPr.user.login === username\n        );\n      }\n\n      for (const ghPr of page) {\n        massageGhRestPr(ghPr);\n      }\n\n      needNextPageSync = prApiCache.reconcile(page);\n      needNextPageFetch = !!parseLinkHeader(linkHeader)?.next;\n\n      if (pageIdx === 1) {\n        needNextPageFetch &&= !opts.paginate;\n      }\n\n      pageIdx += 1;\n    }\n\n    logger.debug(\n      {\n        pullsTotal: prApiCache.getItems().length,\n        requestsTotal,\n        apiQuotaAffected,\n      },\n      `getPrList success`\n    );\n  } catch (err) /* istanbul ignore next */ {\n    logger.debug({ err }, 'getPrList err');\n    throw new ExternalHostError(err, PlatformId.Github);\n  }\n\n  const cacheItems = prApiCache.getItems();\n  for (const ghPr of cacheItems) {\n    const pr = coerceRestPr(ghPr);\n    if (pr) {\n      prCache[ghPr.number] = pr;\n    }\n  }\n\n  return prCache;\n}\n"]}