{"version":3,"file":"api-cache.js","sourceRoot":"","sources":["../../../../lib/modules/platform/github/api-cache.ts"],"names":[],"mappings":"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","sourcesContent":["import { dequal } from 'dequal';\nimport { DateTime } from 'luxon';\nimport type { ApiPageCache, ApiPageItem } from './types';\n\nexport class ApiCache<T extends ApiPageItem> {\n  private itemsMapCache = new WeakMap();\n\n  constructor(private cache: ApiPageCache<T>) {}\n\n  get etag(): string | null {\n    return this.cache.etag ?? null;\n  }\n\n  set etag(value: string | null) {\n    if (value === null) {\n      delete this.cache.etag;\n    } else {\n      this.cache.etag = value;\n    }\n  }\n\n  /**\n   * @returns Date formatted to use in HTTP headers\n   */\n  get lastModified(): string | null {\n    const { lastModified } = this.cache;\n    return lastModified ? DateTime.fromISO(lastModified).toHTTP() : null;\n  }\n\n  getItems(): T[];\n  getItems<U = unknown>(mapFn: (_: T) => U): U[];\n  getItems<U = unknown>(mapFn?: (_: T) => U): T[] | U[] {\n    if (mapFn) {\n      const cachedResult = this.itemsMapCache.get(mapFn);\n      if (cachedResult) {\n        return cachedResult;\n      }\n\n      const items = Object.values(this.cache.items);\n      const mappedResult = items.map(mapFn);\n      this.itemsMapCache.set(mapFn, mappedResult);\n      return mappedResult;\n    }\n\n    const items = Object.values(this.cache.items);\n    return items;\n  }\n\n  getItem(number: number): T | null {\n    return this.cache.items[number] ?? null;\n  }\n\n  /**\n   * It intentionally doesn't alter `lastModified` cache field.\n   *\n   * The point is to allow cache modifications during run, but\n   * force fetching and refreshing of modified items next run.\n   */\n  updateItem(item: T): void {\n    this.cache.items[item.number] = item;\n    this.itemsMapCache = new WeakMap();\n  }\n\n  /**\n   * Copies items from `page` to `cache`.\n   * Updates internal cache timestamp.\n   *\n   * @param cache Cache object\n   * @param page List of cacheable items, sorted by `updated_at` field\n   * starting from the most recently updated.\n   * @returns `true` when the next page is likely to contain fresh items,\n   * otherwise `false`.\n   */\n  reconcile(page: T[]): boolean {\n    const { items } = this.cache;\n    let { lastModified } = this.cache;\n\n    let needNextPage = true;\n\n    for (const newItem of page) {\n      const number = newItem.number;\n      const oldItem = items[number];\n\n      const itemNewTime = DateTime.fromISO(newItem.updated_at);\n      const itemOldTime = oldItem?.updated_at\n        ? DateTime.fromISO(oldItem.updated_at)\n        : null;\n\n      if (!dequal(oldItem, newItem)) {\n        items[number] = newItem;\n        this.itemsMapCache = new WeakMap();\n      }\n\n      needNextPage = itemOldTime ? itemOldTime < itemNewTime : true;\n\n      const cacheOldTime = lastModified ? DateTime.fromISO(lastModified) : null;\n      if (!cacheOldTime || itemNewTime > cacheOldTime) {\n        lastModified = newItem.updated_at;\n      }\n    }\n\n    this.cache.lastModified = lastModified;\n\n    return needNextPage;\n  }\n}\n"]}