"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProofdictTester = void 0;
// MIT Â© 2017 azu
var prh_1 = require("prh");
var proofdict_tester_util_1 = require("./proofdict-tester-util");
var TagFilter_1 = require("./TagFilter");
var AllowPatterns_1 = require("./AllowPatterns");
var ProofdictTester = /** @class */ (function () {
    function ProofdictTester(options) {
        this.proofdict = options.dictionary;
        var filteredProofdict = TagFilter_1.filterByTags(this.proofdict, options.allowTags, options.denyTags);
        this.prhEngine = new prh_1.Engine({
            version: 1,
            rules: this.splitRuleToEachPattern(filteredProofdict)
        });
    }
    /**
     * split pattern to each rules
     * It avoid prh multiple capture issue
     * https://github.com/prh/prh/issues/32
     * @param dictionary
     */
    ProofdictTester.prototype.splitRuleToEachPattern = function (dictionary) {
        var results = [];
        dictionary.map(function (dict) {
            var patterns = TagFilter_1.isNoun(dict)
                ? dict.patterns.map(function (pattern) {
                    return proofdict_tester_util_1.wrapWordBoundaryToString(pattern);
                })
                : dict.patterns;
            patterns.forEach(function (pattern) {
                results.push(__assign(__assign({}, dict), { patterns: [pattern], specs: [] // remove specs because proodict has difference logic to prh
                 }));
            });
        });
        return results;
    };
    ProofdictTester.prototype.replace = function (text) {
        return this.match(text).then(function (result) { return result.output; });
    };
    ProofdictTester.prototype.match = function (text) {
        // pass empty string for working in browser
        // https://github.com/prh/prh/issues/29
        var changeSet = this.prhEngine.makeChangeSet("", text);
        var sortedDiffs = changeSet.diffs.sort(function (a, b) {
            return a.index - b.index;
        });
        var deltaTestStartPosition = 0;
        var currentString = text;
        var results = [];
        sortedDiffs.forEach(function (diff) {
            if (!diff.expected) {
                return;
            }
            // "allows"
            // match it and ignore
            var allowPatterns = new AllowPatterns_1.AllowPatterns(diff.rule.raw);
            if (allowPatterns.match(currentString)) {
                return;
            }
            // Deprecated: should use "allow"
            // Extension: "noun"
            // Automatically add word boundary to the patterns
            if (TagFilter_1.isNoun(diff.rule.raw)) {
                var expectPatterns = proofdict_tester_util_1.createCombinationPatterns(diff.pattern);
                var isExpected = expectPatterns.some(function (expectPattern) {
                    return expectPattern.test(currentString);
                });
                if (isExpected) {
                    return;
                }
            }
            var applied = diff.apply(currentString, deltaTestStartPosition);
            if (applied == null) {
                return;
            }
            // matchStartIndex/matchEndIndex value is original position, not replaced position
            // textlint use original position
            var matchStartIndex = diff.index;
            var matchEndIndex = matchStartIndex + diff.matches[0].length;
            var actual = currentString.slice(matchStartIndex, matchEndIndex);
            var expected = diff.newText;
            var description = diff.rule && diff.rule.raw.description;
            var rule = diff.rule && diff.rule.raw;
            results.push({
                rule: rule,
                matchStartIndex: matchStartIndex,
                matchEndIndex: matchEndIndex,
                actual: actual,
                expected: expected,
                description: description
            });
            currentString = applied.replaced;
            deltaTestStartPosition = applied.newDelta;
        });
        return Promise.resolve({
            output: currentString,
            details: results
        });
    };
    return ProofdictTester;
}());
exports.ProofdictTester = ProofdictTester;
//# sourceMappingURL=proofdict-tester.js.map