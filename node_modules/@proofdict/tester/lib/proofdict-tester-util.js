"use strict";
// MIT Â© 2017 azu
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCombinationPatterns = exports.wrapWordBoundary = exports.wrapWordBoundaryToString = exports.parseRegExpString = exports.addBoundary = exports.concat = void 0;
var regexpRegexp = /^\/(.*)\/([gimy]*)$/;
function concat(args, flags) {
    var prevFlags = flags || "";
    var foundRegExp = false;
    var result = args.reduce(function (p, c) {
        if (typeof c === "string") {
            return p + c;
        }
        else if (c instanceof RegExp) {
            c.flags.split("").sort();
            var currentFlags = c.flags
                .split("")
                .sort()
                .join("");
            if (foundRegExp) {
                if (prevFlags !== currentFlags) {
                    throw new Error("combining different flags " + prevFlags + " and " + currentFlags + ".\nThe pattern " + c + " has different flag with other patterns.");
                }
            }
            prevFlags = currentFlags;
            foundRegExp = true;
            return p + c.source;
        }
        else {
            throw new Error("unknown type: " + c);
        }
    }, "");
    return new RegExp(result, prevFlags);
}
exports.concat = concat;
function addBoundary(arg) {
    var result;
    var flags = "";
    if (typeof arg === "string") {
        result = arg;
    }
    else if (arg instanceof RegExp) {
        result = arg.source;
        flags = arg.flags;
    }
    else {
        throw new Error("unknown type: " + arg);
    }
    return concat(["\\b", result, "\\b"], flags);
}
exports.addBoundary = addBoundary;
function parseRegExpString(str) {
    var result = str.match(regexpRegexp);
    if (!result) {
        return null;
    }
    return new RegExp(result[1], result[2]);
}
exports.parseRegExpString = parseRegExpString;
exports.wrapWordBoundaryToString = function (pattern) {
    var regExp = parseRegExpString(pattern);
    if (regExp === null) {
        return pattern;
    }
    var wrapWordPattern = exports.wrapWordBoundary(regExp);
    return wrapWordPattern.toString();
};
exports.wrapWordBoundary = function (pattern) {
    var result;
    var flags;
    if (typeof pattern === "string") {
        result = pattern;
    }
    else if (pattern instanceof RegExp) {
        result = pattern.source;
        flags = pattern.flags;
    }
    else {
        throw new Error("unknown type: " + pattern);
    }
    return concat(["\\b", result, "\\b"], flags);
};
/**
 * input: webkit
 * output: [/-webkit/, /webkit-/]
 * @param pattern
 */
exports.createCombinationPatterns = function (pattern) {
    var result;
    var flags;
    if (typeof pattern === "string") {
        var regExp = parseRegExpString(pattern);
        if (regExp) {
            result = regExp.source;
            flags = regExp.flags;
        }
        else {
            result = pattern;
        }
    }
    else if (pattern instanceof RegExp) {
        result = pattern.source;
        flags = pattern.flags;
    }
    else {
        throw new Error("unknown type: " + pattern);
    }
    return [concat(["-", result], flags), concat([result, "-"], flags)];
};
//# sourceMappingURL=proofdict-tester-util.js.map