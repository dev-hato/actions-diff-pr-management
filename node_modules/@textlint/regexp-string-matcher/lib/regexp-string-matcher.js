"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var uniq = require("lodash.uniq");
var uniqWith = require("lodash.uniqwith");
var sortBy = require("lodash.sortby");
var escapeStringRegexp = require("escape-string-regexp");
var regexp_parse_1 = require("./regexp-parse");
var execall = require("execall");
var toRegex = require("to-regex");
var DEFAULT_FLAGS = "g";
var defaultFlags = function (flagsString) {
    if (flagsString.length === 0) {
        return DEFAULT_FLAGS;
    }
    return uniq((flagsString + DEFAULT_FLAGS).split("")).join("");
};
exports.createRegExp = function (patternString, defaultFlag) {
    if (defaultFlag === void 0) { defaultFlag = DEFAULT_FLAGS; }
    if (patternString.length === 0) {
        throw new Error("Empty string can not handled");
    }
    if (regexp_parse_1.isRegExpString(patternString)) {
        var regExpStructure = regexp_parse_1.parseRegExpString(patternString);
        if (regExpStructure) {
            return toRegex(regExpStructure.source, {
                flags: defaultFlags(regExpStructure.flagString),
                contains: true
            });
        }
        throw new Error("\"" + patternString + "\" can not parse as RegExp.");
    }
    else {
        return new RegExp(escapeStringRegexp(patternString), defaultFlag);
    }
};
var isEqualMatchPatternResult = function (a, b) {
    return a.startIndex === b.startIndex && a.endIndex === b.endIndex && a.match === b.match;
};
/**
 * Match regExpLikeStrings and return matchPatternResults
 * @param text target text
 * @param regExpLikeStrings an array of pattern string
 */
exports.matchPatterns = function (text, regExpLikeStrings) {
    var matchPatternResults = [];
    regExpLikeStrings
        .map(function (patternString) {
        return exports.createRegExp(patternString);
    })
        .forEach(function (regExp) {
        var execallResults = execall(regExp, text);
        execallResults.forEach(function (result) {
            var match = result.match;
            var index = result.index;
            matchPatternResults.push({
                match: match,
                startIndex: index,
                endIndex: index + match.length
            });
        });
    });
    var uniqResults = uniqWith(matchPatternResults, isEqualMatchPatternResult);
    return sortBy(uniqResults, ["startIndex", "endIndex"]);
};
//# sourceMappingURL=regexp-string-matcher.js.map