"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPaddingLocator = exports.isTextlintRuleErrorPaddingLocation = exports.isTextlintRuleErrorPaddingLocRange = exports.isTextlintRuleErrorPaddingLocObject = void 0;
const isTextlintRuleErrorPaddingLocObject = (loc) => {
    return (typeof loc === "object" &&
        typeof loc.start === "object" &&
        typeof loc.end === "object" &&
        typeof loc.start.line === "number" &&
        !Number.isNaN(loc.start.line) &&
        typeof loc.start.column === "number" &&
        !Number.isNaN(loc.start.column) &&
        typeof loc.end.line === "number" &&
        !Number.isNaN(loc.end.line) &&
        typeof loc.end.column === "number" &&
        !Number.isNaN(loc.end.column));
};
exports.isTextlintRuleErrorPaddingLocObject = isTextlintRuleErrorPaddingLocObject;
const isTextlintRuleErrorPaddingLocRange = (range) => {
    return Array.isArray(range) && range.length === 2;
};
exports.isTextlintRuleErrorPaddingLocRange = isTextlintRuleErrorPaddingLocRange;
const isTextlintRuleErrorPaddingLocation = (o) => {
    return (typeof o === "object" &&
        o !== null &&
        "type" in o &&
        o.type === "TextlintRuleErrorPaddingLocation" &&
        ((0, exports.isTextlintRuleErrorPaddingLocRange)(o.range) || (0, exports.isTextlintRuleErrorPaddingLocObject)(o.loc)));
};
exports.isTextlintRuleErrorPaddingLocation = isTextlintRuleErrorPaddingLocation;
const createPaddingLocator = () => {
    return {
        at(index) {
            if (Number.isNaN(index)) {
                throw new Error(`index must be number: ${index}`);
            }
            return {
                type: "TextlintRuleErrorPaddingLocation",
                isAbsolute: false,
                range: [index, index + 1]
            };
        },
        range(aRange) {
            if (!Array.isArray(aRange)) {
                throw new Error("range must be array");
            }
            if (aRange.length !== 2) {
                throw new Error(`range must be [start, end]: ${JSON.stringify(aRange)}`);
            }
            if (Number.isNaN(aRange[0]) || Number.isNaN(aRange[1])) {
                throw new Error(`range must not be NaN: ${JSON.stringify(aRange)}`);
            }
            if (aRange[0] === aRange[1]) {
                throw new Error(`range must not be same: ${JSON.stringify(aRange)}
                
Probably, you need to use at() method instead.`);
            }
            return {
                type: "TextlintRuleErrorPaddingLocation",
                isAbsolute: false,
                range: aRange
            };
        },
        loc(location) {
            if (!(0, exports.isTextlintRuleErrorPaddingLocObject)(location)) {
                throw new Error(`loc must be TextlintRuleErrorPaddingLocation object: ${JSON.stringify(location)}`);
            }
            return {
                type: "TextlintRuleErrorPaddingLocation",
                isAbsolute: false,
                loc: location
            };
        }
    };
};
exports.createPaddingLocator = createPaddingLocator;
//# sourceMappingURL=TextlintRulePaddingLocator.js.map