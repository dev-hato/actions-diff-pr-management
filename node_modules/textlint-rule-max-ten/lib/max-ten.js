// LICENSE : MIT
"use strict";

var _textlintRuleHelper = require("textlint-rule-helper");

var _kuromojin = require("kuromojin");

var _sentenceSplitter = require("sentence-splitter");

var _textlintUtilToString = require("textlint-util-to-string");

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var defaultOptions = {
  // 1文に利用できる最大の、の数
  max: 3,
  // 例外ルールを適応するかどうか,
  strict: false,
  // 読点として扱う文字
  // https://ja.wikipedia.org/wiki/%E8%AA%AD%E7%82%B9
  touten: "、",
  // 句点として扱う文字
  // https://ja.wikipedia.org/wiki/%E5%8F%A5%E7%82%B9
  kuten: "。"
};

function isSandwichedMeishi(_ref) {
  var {
    before,
    token,
    after
  } = _ref;

  if (before === undefined || after === undefined || token === undefined) {
    return false;
  }

  return before.pos === "名詞" && after.pos === "名詞";
}
/**
 * 括弧のトークンかどうか
 * @param token
 * @returns {boolean}
 */


function is括弧(token) {
  if (token.pos === "記号" && /^括弧/.test(token.pos_detail_1)) {
    return true;
  }

  if (token.surface_form === "(" || token.surface_form === ")") {
    return true;
  }

  return false;
}
/**
 * 括弧などの記号的なTokenはスキップとして隣接するTokenを探す
 * @see https://github.com/textlint-ja/textlint-rule-max-ten/issues/12
 * @param {*[]} tokens
 * @param {number} currentIndex
 * @param {"prev"|"next"} direction
 * @returns {undefined | *}
 */


function findSiblingMeaningToken(_ref2) {
  var {
    tokens,
    currentIndex,
    direction
  } = _ref2;
  var delta = direction === "prev" ? -1 : 1;
  var sibilingToken = tokens[currentIndex + delta];

  if (!sibilingToken) {
    return;
  } // 括弧はスキップして、隣接Nodeを探す


  if (is括弧(sibilingToken)) {
    return findSiblingMeaningToken({
      tokens,
      currentIndex: currentIndex + delta,
      direction
    });
  }

  return sibilingToken;
}
/**
 * @param {RuleContext} context
 * @param {typeof defaultOptions} [options]
 */


module.exports = function (context) {
  var _options$max, _options$strict, _options$touten, _options$kuten;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var maxLen = (_options$max = options.max) !== null && _options$max !== void 0 ? _options$max : defaultOptions.max;
  var isStrict = (_options$strict = options.strict) !== null && _options$strict !== void 0 ? _options$strict : defaultOptions.strict;
  var touten = (_options$touten = options.touten) !== null && _options$touten !== void 0 ? _options$touten : defaultOptions.touten;
  var kuten = (_options$kuten = options.kuten) !== null && _options$kuten !== void 0 ? _options$kuten : defaultOptions.kuten;
  var helper = new _textlintRuleHelper.RuleHelper(context);
  var {
    Syntax,
    RuleError,
    report,
    getSource
  } = context;
  return {
    [Syntax.Paragraph](node) {
      if (helper.isChildNode(node, [Syntax.BlockQuote])) {
        return;
      }

      var resultNode = (0, _sentenceSplitter.splitAST)(node, {
        SeparatorParser: {
          separatorCharacters: ["?", // question mark
          "!", //  exclamation mark
          "？", // (ja) zenkaku question mark
          "！" // (ja) zenkaku exclamation mark
          ].concat(kuten)
        }
      });
      var sentences = resultNode.children.filter(childNode => childNode.type === _sentenceSplitter.Syntax.Sentence);
      /*
       <p>
       <str><code><img><str>
       <str>
       </p>
       */

      /*
       # workflow
       1. split text to sentences
       2. sentence to tokens
       3. check tokens
       */

      var checkSentence = /*#__PURE__*/function () {
        var _ref3 = _asyncToGenerator(function* (sentence) {
          var source = new _textlintUtilToString.StringSource(sentence);
          var text = source.toString();
          var tokens = yield (0, _kuromojin.tokenize)(text);
          var currentTenCount = 0;
          var lastToken = null;
          tokens.forEach((token, index) => {
            var surface = token.surface_form;

            if (surface === touten) {
              // 名詞に囲まわれている場合は例外とする
              var isSandwiched = isSandwichedMeishi({
                before: findSiblingMeaningToken({
                  tokens,
                  currentIndex: index,
                  direction: "prev"
                }),
                token: token,
                after: findSiblingMeaningToken({
                  tokens,
                  currentIndex: index,
                  direction: "next"
                })
              }); // strictなら例外を例外としない

              if (!isStrict && isSandwiched) {
                return;
              }

              currentTenCount++;
              lastToken = token;
            }

            if (surface === kuten) {
              // reset
              currentTenCount = 0;
            } // report


            if (currentTenCount > maxLen) {
              var positionInSentence = source.originalIndexFromIndex(lastToken.word_position - 1); // relative index from Paragraph Node
              // Sentence start(relative) + word position(relative)

              var _index = sentence.range[0] - node.range[0] + positionInSentence;

              var ruleError = new context.RuleError("\u4E00\u3064\u306E\u6587\u3067\"".concat(touten, "\"\u3092").concat(maxLen + 1, "\u3064\u4EE5\u4E0A\u4F7F\u7528\u3057\u3066\u3044\u307E\u3059"), {
                index: _index
              });
              report(node, ruleError);
              currentTenCount = 0;
            }
          });
        });

        return function checkSentence(_x) {
          return _ref3.apply(this, arguments);
        };
      }();

      return Promise.all(sentences.map(checkSentence));
    }

  };
};
//# sourceMappingURL=max-ten.js.map