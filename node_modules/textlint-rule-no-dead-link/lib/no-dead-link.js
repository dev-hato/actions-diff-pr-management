"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _textlintRuleHelper = require("textlint-rule-helper");

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var _url = _interopRequireDefault(require("url"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _minimatch = _interopRequireDefault(require("minimatch"));

var _path = require("path");

var _getUrlOrigin = require("get-url-origin");

var _pMemoize = _interopRequireDefault(require("p-memoize"));

var _pQueue = _interopRequireDefault(require("p-queue"));

var http = _interopRequireWildcard(require("http"));

var https = _interopRequireWildcard(require("https"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DEFAULT_OPTIONS = {
  checkRelative: true,
  // {boolean} `false` disables the checks for relative URIs.
  baseURI: null,
  // {String|null} a base URI to resolve relative URIs.
  ignore: [],
  // {Array<String>} URIs to be skipped from availability checks.
  preferGET: [],
  // {Array<String>} origins to prefer GET over HEAD.
  retry: 3,
  // {number} Max retry count
  concurrency: 8,
  // {number} Concurrency count of linting link [Experimental]
  interval: 500,
  // The length of time in milliseconds before the interval count resets. Must be finite. [Experimental]
  intervalCap: 8,
  // The max number of runs in the given interval of time. [Experimental]
  keepAlive: false,
  // {boolean} if it is true, use keepAlive for checking request [Experimental]
  userAgent: 'textlint-rule-no-dead-link/1.0',
  // {String} a UserAgent,
  maxRetryTime: 10 // (number) The max of waiting seconds for retry, if response returns `After-Retry` header.

}; // Adopted from http://stackoverflow.com/a/3809435/951517

var URI_REGEXP = /(?:https?:)?\/\/(?:www\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,6}\b(?:[-a-zA-Z0-9@:%_+.~#?&//=]*)/g;
/**
 * Returns `true` if a given URI is https? url.
 * @param {string} uri
 * @return {boolean}
 */

function isHttp(uri) {
  var {
    protocol
  } = _url.default.parse(uri);

  return protocol === 'http:' || protocol === 'https:';
}
/**
 * Returns `true` if a given URI is relative.
 * @param {string} uri
 * @return {boolean}
 * @see https://github.com/panosoft/is-local-path
 */


function isRelative(uri) {
  var {
    host
  } = _url.default.parse(uri);

  return host === null || host === '';
}
/**
 * Returns if a given URI indicates a local file.
 * @param {string} uri
 * @return {boolean}
 * @see https://nodejs.org/api/path.html#path_path_isabsolute_path
 */


function isLocal(uri) {
  if ((0, _path.isAbsolute)(uri)) {
    return true;
  }

  return isRelative(uri);
}
/**
 * Return `true` if the `code` is redirect status code.
 * @see https://fetch.spec.whatwg.org/#redirect-status
 * @param {number} code
 * @returns {boolean}
 */


function isRedirect(code) {
  return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
}

function isIgnored(uri) {
  var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return ignore.some(pattern => (0, _minimatch.default)(uri, pattern));
}
/**
 * wait for ms and resolve the promise
 * @param ms
 * @returns {Promise<any>}
 */


function waitTimeMs(ms) {
  return new Promise(resolve => {
    setTimeout(resolve, ms);
  });
}

var keepAliveAgents = {
  http: new http.Agent({
    keepAlive: true
  }),
  https: new https.Agent({
    keepAlive: true
  })
};

var createFetchWithRuleDefaults = ruleOptions => {
  /**
   * Use library agent, avoid to use global.http(s)Agent
   * Want to avoid Socket hang up
   * @param parsedURL
   * @returns {module:http.Agent|null|module:https.Agent}
   */
  var getAgent = parsedURL => {
    if (!ruleOptions.keepAlive) {
      return null;
    }

    if (parsedURL.protocol === 'http:') {
      return keepAliveAgents.http;
    }

    return keepAliveAgents.https;
  };

  return (uri, fetchOptions) => {
    var {
      host
    } = _url.default.parse(uri);

    return (0, _nodeFetch.default)(uri, _objectSpread(_objectSpread({}, fetchOptions), {}, {
      // Disable gzip compression in Node.js
      // to avoid the zlib's "unexpected end of file" error
      // https://github.com/request/request/issues/2045
      compress: false,
      // Some website require UserAgent and Accept header
      // to avoid ECONNRESET error
      // https://github.com/textlint-rule/textlint-rule-no-dead-link/issues/111
      headers: {
        'User-Agent': ruleOptions.userAgent,
        'Accept': '*/*',
        // Same host for target url
        // https://github.com/textlint-rule/textlint-rule-no-dead-link/issues/111
        'Host': host
      },
      // custom http(s).agent
      agent: getAgent
    }));
  };
};
/**
 * Create isAliveURI function with ruleOptions
 * @param {object} ruleOptions
 * @returns {isAliveURI}
 */


var createCheckAliveURL = ruleOptions => {
  // Create fetch function for this rule
  var fetchWithDefaults = createFetchWithRuleDefaults(ruleOptions);
  /**
   * Checks if a given URI is alive or not.
   *
   * Normally, this method following strategiry about retry
   *
   * 1. Head
   * 2. Get
   * 3. Get
   *
   * @param {string} uri
   * @param {string} method
   * @param {number} maxRetryCount
   * @param {number} currentRetryCount
   * @return {{ ok: boolean, redirect?: string, message: string }}
   */

  return /*#__PURE__*/function () {
    var _isAliveURI = _asyncToGenerator(function* (uri) {
      var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'HEAD';
      var maxRetryCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
      var currentRetryCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var opts = {
        method,
        // Use `manual` redirect behaviour to get HTTP redirect status code
        // and see what kind of redirect is occurring
        redirect: 'manual'
      };

      try {
        var res = yield fetchWithDefaults(uri, opts); // redirected

        if (isRedirect(res.status)) {
          var redirectedUrl = res.headers.get('Location');
          var finalRes = yield fetchWithDefaults(redirectedUrl, _objectSpread(_objectSpread({}, opts), {}, {
            redirect: 'follow'
          }));

          var {
            hash
          } = _url.default.parse(uri);

          return {
            ok: finalRes.ok,
            redirected: true,
            redirectTo: hash !== null ? "".concat(finalRes.url).concat(hash) : finalRes.url,
            message: "".concat(res.status, " ").concat(res.statusText)
          };
        } // retry if it is not ok when use head request


        if (!res.ok && method === 'HEAD' && currentRetryCount < maxRetryCount) {
          return isAliveURI(uri, 'GET', maxRetryCount, currentRetryCount + 1);
        } // try to fetch again if not reach max retry count


        if (currentRetryCount < maxRetryCount) {
          var retrySeconds = res.headers.get('Retry-After'); // If the response has `Retry-After` header, prefer it
          // else exponential retry: 0ms -> 100ms -> 200ms -> 400ms -> 800ms ...

          var retryWaitTimeMs = retrySeconds !== null ? retrySeconds * 1000 : currentRetryCount ** 2 * 100;
          var maxRetryTimeMs = ruleOptions.maxRetryTime * 1000;

          if (retryWaitTimeMs <= maxRetryTimeMs) {
            yield waitTimeMs(retryWaitTimeMs);
          }

          return isAliveURI(uri, 'GET', maxRetryCount, currentRetryCount + 1);
        }

        return {
          ok: res.ok,
          message: "".concat(res.status, " ").concat(res.statusText)
        };
      } catch (ex) {
        // Retry with `GET` method if the request failed
        // as some servers don't accept `HEAD` requests but are OK with `GET` requests.
        // https://github.com/textlint-rule/textlint-rule-no-dead-link/pull/86
        if (method === 'HEAD' && currentRetryCount < maxRetryCount) {
          return isAliveURI(uri, 'GET', maxRetryCount, currentRetryCount + 1);
        }

        return {
          ok: false,
          message: ex.message
        };
      }
    });

    function isAliveURI(_x) {
      return _isAliveURI.apply(this, arguments);
    }

    return isAliveURI;
  }();
};
/**
 * Check if a given file exists
 */


function isAliveLocalFile(_x2) {
  return _isAliveLocalFile.apply(this, arguments);
}

function _isAliveLocalFile() {
  _isAliveLocalFile = _asyncToGenerator(function* (filePath) {
    try {
      yield _fsExtra.default.access(filePath.replace(/[?#].*?$/, ''));
      return {
        ok: true
      };
    } catch (ex) {
      return {
        ok: false,
        message: ex.message
      };
    }
  });
  return _isAliveLocalFile.apply(this, arguments);
}

function reporter(context) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var {
    Syntax,
    getSource,
    report,
    RuleError,
    fixer,
    getFilePath
  } = context;
  var helper = new _textlintRuleHelper.RuleHelper(context);

  var ruleOptions = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);

  var isAliveURI = createCheckAliveURL(ruleOptions); // 30sec memorized

  var memorizedIsAliveURI = (0, _pMemoize.default)(isAliveURI, {
    maxAge: 30 * 1000
  });
  /**
   * Checks a given URI's availability and report if it is dead.
   * @param {TextLintNode} node TextLintNode the URI belongs to.
   * @param {string} uri a URI string to be linted.
   * @param {number} index column number the URI is located at.
   * @param {number} maxRetryCount retry count of linting
   */

  var lint = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(function* (_ref, maxRetryCount) {
      var {
        node,
        uri,
        index
      } = _ref;

      if (isIgnored(uri, ruleOptions.ignore)) {
        return;
      }

      if (isRelative(uri)) {
        if (!ruleOptions.checkRelative) {
          return;
        }

        var filePath = getFilePath();
        var base = ruleOptions.baseURI || filePath;

        if (!base) {
          var _message = 'Unable to resolve the relative URI. Please check if the base URI is correctly specified.';
          report(node, new RuleError(_message, {
            index
          }));
          return;
        } // eslint-disable-next-line no-param-reassign


        uri = _url.default.resolve(base, uri);
      } // Ignore non http external link
      // https://github.com/textlint-rule/textlint-rule-no-dead-link/issues/112


      if (!isLocal(uri) && !isHttp(uri)) {
        return;
      }

      var method = ruleOptions.preferGET.filter(origin => (0, _getUrlOrigin.getURLOrigin)(uri) === (0, _getUrlOrigin.getURLOrigin)(origin)).length > 0 ? 'GET' : 'HEAD';
      var result = isLocal(uri) ? yield isAliveLocalFile(uri) : yield memorizedIsAliveURI(uri, method, maxRetryCount);
      var {
        ok,
        redirected,
        redirectTo,
        message
      } = result; // When ignoreRedirects is true, redirected should be ignore

      if (redirected && ruleOptions.ignoreRedirects) {
        return;
      }

      if (!ok) {
        var lintMessage = "".concat(uri, " is dead. (").concat(message, ")");
        report(node, new RuleError(lintMessage, {
          index
        }));
      } else if (redirected) {
        var _lintMessage = "".concat(uri, " is redirected to ").concat(redirectTo, ". (").concat(message, ")");

        var fix = fixer.replaceTextRange([index, index + uri.length], redirectTo);
        report(node, new RuleError(_lintMessage, {
          fix,
          index
        }));
      }
    });

    return function lint(_x3, _x4) {
      return _ref2.apply(this, arguments);
    };
  }();
  /**
   * URIs to be checked.
   * @type {Array<{ node: TextLintNode, uri: string, index: number }>}
   */


  var URIs = [];
  return {
    [Syntax.Str](node) {
      if (helper.isChildNode(node, [Syntax.BlockQuote])) {
        return;
      } // prevent double checks


      if (helper.isChildNode(node, [Syntax.Link])) {
        return;
      }

      var text = getSource(node); // Use `String#replace` instead of `RegExp#exec` to allow us
      // perform RegExp matches in an iterate and immutable manner

      text.replace(URI_REGEXP, (uri, index) => {
        URIs.push({
          node,
          uri,
          index
        });
      });
    },

    [Syntax.Link](node) {
      if (helper.isChildNode(node, [Syntax.BlockQuote])) {
        return;
      } // Ignore HTML5 place holder link.
      // Ex) <a>Placeholder Link</a>


      if (typeof node.url === 'undefined') {
        return;
      } // [text](http://example.com)
      //       ^


      var index = node.raw.indexOf(node.url) || 0;
      URIs.push({
        node,
        uri: node.url,
        index
      });
    },

    ["".concat(context.Syntax.Document, ":exit")]() {
      var queue = new _pQueue.default({
        concurrency: ruleOptions.concurrency,
        intervalCap: ruleOptions.intervalCap,
        interval: ruleOptions.interval
      });
      var linkTasks = URIs.map(item => () => lint(item, ruleOptions.retry));
      return queue.addAll(linkTasks);
    }

  };
}

var _default = {
  linter: reporter,
  fixer: reporter
};
exports.default = _default;
//# sourceMappingURL=no-dead-link.js.map