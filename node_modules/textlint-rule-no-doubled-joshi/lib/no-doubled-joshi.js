// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _textlintRuleHelper = require("textlint-rule-helper");

var _sentenceSplitter = require("sentence-splitter");

var _kuromojin = require("kuromojin");

var _tokenUtils = require("./token-utils");

var _textlintUtilToString = require("textlint-util-to-string");

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/**
 * Create token map object
 * {
 *  "は:助詞.係助詞": [token, token]
 * }
 * @param tokens
 * @returns {*}
 */
function createSurfaceKeyMap(tokens) {
  // 助詞のみを対象とする
  return tokens.filter(_tokenUtils.is助詞Token).reduce((keyMap, token) => {
    // "は:助詞.係助詞" : [token]
    var tokenKey = (0, _tokenUtils.createKeyFromKey)(token);

    if (!keyMap[tokenKey]) {
      keyMap[tokenKey] = [];
    }

    keyMap[tokenKey].push(token);
    return keyMap;
  }, {});
}

function matchExceptionRule(tokens) {
  var token = tokens[0]; // "の" の重なりは例外

  if (token.pos_detail_1 === "連体化") {
    return true;
  } // "を" の重なりは例外


  if (token.pos_detail_1 === "格助詞" && token.surface_form === "を") {
    return true;
  } // 接続助詞 "て" の重なりは例外


  if (token.pos_detail_1 === "接続助詞" && token.surface_form === "て") {
    return true;
  } // 並立助詞は例外
  // 登ったり降りたり


  if (tokens.length === 2 && tokens[0].pos_detail_1 === "並立助詞" && tokens[1].pos_detail_1 === "並立助詞") {
    return true;
  }

  return false;
}
/*
 default options
 */


var defaultOptions = {
  min_interval: 1,
  strict: false,
  allow: [],
  separatorCharacters: [".", // period
  "．", // (ja) zenkaku-period
  "。", // (ja) 句点
  "?", // question mark
  "!", //  exclamation mark
  "？", // (ja) zenkaku question mark
  "！" // (ja) zenkaku exclamation mark
  ],
  commaCharacters: ["、", "，" // 全角カンマ
  ]
};

/*
 1. Paragraph Node -> text
 2. text -> sentences
 3. tokenize sentence
 4. report error if found word that match the rule.

 TODO: need abstraction
 */
var report = function report(context) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var helper = new _textlintRuleHelper.RuleHelper(context); // 最低間隔値

  var minInterval = options.min_interval !== undefined ? options.min_interval : defaultOptions.min_interval;

  if (minInterval <= 0) {
    throw new Error("options.min_intervalは1以上の数値を指定してください");
  }

  var isStrict = options.strict || defaultOptions.strict;
  var allow = options.allow || defaultOptions.allow;
  var separatorCharacters = options.separatorCharacters || defaultOptions.separatorCharacters;
  var commaCharacters = options.commaCharacters || defaultOptions.commaCharacters;
  var {
    Syntax,
    report,
    RuleError
  } = context;
  var is読点Token = (0, _tokenUtils.create読点Matcher)(commaCharacters);
  return {
    [Syntax.Paragraph](node) {
      if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {
        return;
      }

      var isSentenceNode = node => {
        return node.type === _sentenceSplitter.Syntax.Sentence;
      };

      var txtParentNode = (0, _sentenceSplitter.splitAST)(node, {
        SeparatorParser: {
          separatorCharacters
        }
      });
      var sentences = txtParentNode.children.filter(isSentenceNode);

      var checkSentence = /*#__PURE__*/function () {
        var _ref = _asyncToGenerator(function* (sentence) {
          var sentenceSource = new _textlintUtilToString.StringSource(sentence);
          var text = sentenceSource.toString();
          var tokens = yield (0, _kuromojin.tokenize)(text); // 助詞 + 助詞は 一つの助詞として扱う
          // https://github.com/textlint-ja/textlint-rule-no-doubled-joshi/issues/15
          // 連語(助詞)の対応
          // http://www.weblio.jp/parts-of-speech/%E9%80%A3%E8%AA%9E(%E5%8A%A9%E8%A9%9E)_1

          var concatTokens = (0, _tokenUtils.concatJoishiTokens)(tokens);
          var countableTokens = concatTokens.filter(token => {
            if (isStrict) {
              return (0, _tokenUtils.is助詞Token)(token);
            } // "("や")"などもトークンとしてカウントする
            // xxxx（xxx) xxx でカッコの中と外に距離を一つ増やす目的
            // https://github.com/textlint-ja/textlint-rule-no-doubled-joshi/issues/31


            if ((0, _tokenUtils.is括弧Token)(token)) {
              return true;
            } // "、" があると助詞同士の距離が開くようにすることで、並列的な"、"の使い方を許容する目的
            // https://github.com/azu/textlint-rule-no-doubled-joshi/issues/2


            if (is読点Token(token)) {
              return true;
            } // デフォルトでは、"、"を間隔値の距離としてカウントする


            return (0, _tokenUtils.is助詞Token)(token);
          });
          var joshiTokenSurfaceKeyMap = createSurfaceKeyMap(countableTokens);
          /*
              # Data Structure
               joshiTokens = [tokenA, tokenB, tokenC, tokenD, tokenE, tokenF]
              joshiTokenSurfaceKeyMap = {
                  "は:助詞.係助詞": [tokenA, tokenC, tokenE],
                  "で:助詞.係助詞": [tokenB, tokenD, tokenF]
              }
              */

          Object.keys(joshiTokenSurfaceKeyMap).forEach(key => {
            var tokens = joshiTokenSurfaceKeyMap[key];
            var joshiName = (0, _tokenUtils.restoreToSurfaceFromKey)(key); // check allow

            if (allow.indexOf(joshiName) >= 0) {
              return;
            } // strict mode ではない時例外を除去する


            if (!isStrict) {
              if (matchExceptionRule(tokens)) {
                return;
              }
            }

            if (tokens.length <= 1) {
              return; // no duplicated token
            } // if found differenceIndex less than
            // tokes are sorted ascending order


            tokens.reduce((prev, current) => {
              var startPosition = countableTokens.indexOf(prev);
              var otherPosition = countableTokens.indexOf(current); // 助詞token同士の距離が設定値以下ならエラーを報告する

              var differenceIndex = otherPosition - startPosition;

              if (differenceIndex <= minInterval) {
                // padding positionを計算する
                var originalIndex = sentenceSource.originalIndexFromIndex(current.word_position - 1);
                report(sentence, new RuleError("\u4E00\u6587\u306B\u4E8C\u56DE\u4EE5\u4E0A\u5229\u7528\u3055\u308C\u3066\u3044\u308B\u52A9\u8A5E \"".concat(joshiName, "\" \u304C\u307F\u3064\u304B\u308A\u307E\u3057\u305F\u3002"), {
                  index: originalIndex
                }));
              }

              return current;
            });
          });
        });

        return function checkSentence(_x) {
          return _ref.apply(this, arguments);
        };
      }();

      return Promise.all(sentences.map(checkSentence));
    }

  };
};

var _default = report;
exports.default = _default;
//# sourceMappingURL=no-doubled-joshi.js.map