{"version":3,"sources":["../src/morpheme-match-all.js"],"names":["assert","require","createMatcher","dictionaries","expectors","map","Expector","dict","morphemeMatchAll","actualTokens","matchResults","forEach","expector","match","actualToken","tokens","skipped","index","indexOf","push","module","exports"],"mappings":"AAAA;AACA;;AAEA;;;;;;AADA,IAAMA,SAASC,QAAQ,QAAR,CAAf;;AAEA;;;;;;;AAOA;;;;;;;;AAQA;;;;;AAKA,SAASC,aAAT,CAAuBC,YAAvB,EAAqC;AACjC,QAAMC,YAAYD,aAAaE,GAAb,CAAiB,gBAAQ;AACvC,eAAO,IAAIC,kBAAJ,CAAaC,IAAb,CAAP;AACH,KAFiB,CAAlB;AAGA;;;;;;;AAOA,WAAO,SAASC,gBAAT,CAA0BC,YAA1B,EAAwC;AAC3C;;;AAGA,YAAMC,eAAe,EAArB;AACAD,qBAAaE,OAAb,CAAqB,uBAAe;AAChCP,sBAAUO,OAAV,CAAkB,oBAAY;AAAA,sCACOC,SAASC,KAAT,CAAeC,WAAf,CADP;AAAA,oBACnBD,KADmB,mBACnBA,KADmB;AAAA,oBACZE,MADY,mBACZA,MADY;AAAA,oBACJC,OADI,mBACJA,OADI;;AAE1B,oBAAI,CAACH,KAAL,EAAY;AACR;AACH;AACD;;;;AAIA,oBAAMI,QAAQR,aAAaS,OAAb,CAAqBH,OAAO,CAAP,CAArB,CAAd;AACAL,6BAAaS,IAAb,CAAkB;AACdJ,kCADc;AAEdE,gCAFc;AAGdD,oCAHc;AAIdT,0BAAMK,SAASL;AAJD,iBAAlB;AAMH,aAhBD;AAiBH,SAlBD;AAmBA,eAAOG,YAAP;AACH,KAzBD;AA0BH;AACDU,OAAOC,OAAP,GAAiBnB,aAAjB","file":"morpheme-match-all.js","sourcesContent":["// MIT Â© 2016 azu\n\"use strict\";\nconst assert = require(\"assert\");\nimport Expector from \"./Expector\";\n/**\n * @typedef {Object} ExpectedDictionary\n * @property {Object[]} tokens kuromoji's token list\n * @property {string} [message]\n * @property {string} [expected]\n * @public\n */\n/**\n * @typedef {Object} MatchResult\n * @property {Object[]} tokens match tokens,\n * @property {number} index index of first match token\n * @property {boolean[]} skipped skipped values for tokens\n * @property {ExpectedDictionary[]} dict dictionary defined by you\n * @public\n */\n/**\n * @param {ExpectedDictionary[]} dictionaries\n * @return {morphemeMatchAll}\n * @public\n */\nfunction createMatcher(dictionaries) {\n    const expectors = dictionaries.map(dict => {\n        return new Expector(dict);\n    });\n    /**\n     * match `actualTokens` with `dictionaries`\n     * @param {Object[]} actualTokens\n     * @returns {MatchResult[]}\n     * @function morphemeMatchAll\n     * @public\n     */\n    return function morphemeMatchAll(actualTokens) {\n        /**\n         * @type {MatchResult[]}\n         */\n        const matchResults = [];\n        actualTokens.forEach(actualToken => {\n            expectors.forEach(expector => {\n                const {match, tokens, skipped} = expector.match(actualToken);\n                if (!match) {\n                    return;\n                }\n                /**\n                 * the index of first match token\n                 * @type {number}\n                 */\n                const index = actualTokens.indexOf(tokens[0]);\n                matchResults.push({\n                    tokens,\n                    index,\n                    skipped,\n                    dict: expector.dict\n                });\n            });\n        });\n        return matchResults;\n    };\n}\nmodule.exports = createMatcher;\n"]}