// MIT Â© 2016 azu
"use strict";

var _Expector = require("./Expector");

var _Expector2 = _interopRequireDefault(_Expector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var assert = require("assert");

/**
 * @typedef {Object} ExpectedDictionary
 * @property {Object[]} tokens kuromoji's token list
 * @property {string} [message]
 * @property {string} [expected]
 * @public
 */
/**
 * @typedef {Object} MatchResult
 * @property {Object[]} tokens match tokens,
 * @property {number} index index of first match token
 * @property {boolean[]} skipped skipped values for tokens
 * @property {ExpectedDictionary[]} dict dictionary defined by you
 * @public
 */
/**
 * @param {ExpectedDictionary[]} dictionaries
 * @return {morphemeMatchAll}
 * @public
 */
function createMatcher(dictionaries) {
    var expectors = dictionaries.map(function (dict) {
        return new _Expector2.default(dict);
    });
    /**
     * match `actualTokens` with `dictionaries`
     * @param {Object[]} actualTokens
     * @returns {MatchResult[]}
     * @function morphemeMatchAll
     * @public
     */
    return function morphemeMatchAll(actualTokens) {
        /**
         * @type {MatchResult[]}
         */
        var matchResults = [];
        actualTokens.forEach(function (actualToken) {
            expectors.forEach(function (expector) {
                var _expector$match = expector.match(actualToken),
                    match = _expector$match.match,
                    tokens = _expector$match.tokens,
                    skipped = _expector$match.skipped;

                if (!match) {
                    return;
                }
                /**
                 * the index of first match token
                 * @type {number}
                 */
                var index = actualTokens.indexOf(tokens[0]);
                matchResults.push({
                    tokens: tokens,
                    index: index,
                    skipped: skipped,
                    dict: expector.dict
                });
            });
        });
        return matchResults;
    };
}
module.exports = createMatcher;
//# sourceMappingURL=morpheme-match-all.js.map