// MIT © 2017 azu
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var find = require("array.prototype.find");
var endWith = require("end-with");
var emojiRegExp = require("emoji-regex")();
var exceptionMarkRegExp = /[!?！？\)）」』]/;

/**
 * Check ends with period.
 * @param {string} lineText
 * @param {string[]} periodMarks
 * @param {boolean} allowExceptionMark often used at end.
 * @param {boolean} allowEmoji
 * @returns {{valid: boolean, periodMark: string, index: number}}
 *
 * `index` is index value of last character.
 * If last character is a parts of periodMarks, `index` is the position of periodMark.
 * If last character is not a parts of periodMarks, `index` is the position of the last character.
 * If last character is white space, `index` is the position of starting of white space on the end.
 */
var checkEndsWithPeriod = function checkEndsWithPeriod(lineText) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$periodMarks = _ref.periodMarks,
        periodMarks = _ref$periodMarks === undefined ? ["。", "."] : _ref$periodMarks,
        _ref$allowExceptionMa = _ref.allowExceptionMark,
        allowExceptionMark = _ref$allowExceptionMa === undefined ? true : _ref$allowExceptionMa,
        _ref$allowEmoji = _ref.allowEmoji,
        allowEmoji = _ref$allowEmoji === undefined ? false : _ref$allowEmoji;

    // サロゲートペアを考慮した文字列長・文字アクセス
    var characters = [].concat(_toConsumableArray(lineText));
    var lastCharacterIndex = characters.length - 1;
    var periodMark = characters[lastCharacterIndex];
    if (/\s/.test(periodMark)) {
        var _lineText$match = lineText.match(/\s+$/),
            _lineText$match2 = _slicedToArray(_lineText$match, 1),
            whiteSpaces = _lineText$match2[0];

        return {
            valid: false,
            periodMark: whiteSpaces,
            index: lastCharacterIndex - (whiteSpaces.length - 1)
        };
    }
    // allo exclamation mark and serif symbol
    if (allowExceptionMark && exceptionMarkRegExp.test(periodMark)) {
        return {
            valid: true,
            periodMark: periodMark,
            index: lastCharacterIndex
        };
    }
    // allow emoji
    if (allowEmoji && emojiRegExp.test(periodMark)) {
        return {
            valid: true,
            periodMark: periodMark,
            index: lastCharacterIndex
        };
    }
    /**
     * @type {string|undefined}
     */
    var matchMark = find(periodMarks, function (mark) {
        return endWith(lineText, mark);
    });
    if (matchMark) {
        return {
            valid: true,
            periodMark: matchMark,
            index: lineText.length - matchMark.length
        };
    }
    return {
        valid: false,
        periodMark: periodMark,
        index: lastCharacterIndex
    };
};
module.exports = checkEndsWithPeriod;
//# sourceMappingURL=check-ends-with-period.js.map