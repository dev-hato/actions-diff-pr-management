{"version":3,"sources":["../src/analyze.js"],"names":["tokenize","require","defaultOptions","ignoreConjunction","Types","desu","masu","dearu","isDesumasu","type","isDesumasuType","isDearu","isDearuType","isLastToken","targetToken","allTokens","nextPunctureToken","findNextPunctureToken","undefined","nextPunctureTokenSurface","surface_form","test","PUNCTUATION","CONJUGATED_TYPE","indexOfTargetToken","indexOf","postTokens","slice","find","token","mapToAnalyzedResult","tokens","mapTokenToAnalyzedResult","nextTokenIndex","length","valueTokens","value","map","join","surface","index","Object","assign","analyze","text","options","then","filterByType","filter","nextToken","conjugatedType","analyzeDesumasu","results","analyzeDearu"],"mappings":"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","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst tokenize = require(\"kuromojin\").tokenize;\n/**\n * token object\n * @typedef {{word_id: number, word_type: string, word_position: number, surface_form: string, pos: string, pos_detail_1: string, pos_detail_2: string, pos_detail_3: string, conjugated_type: string, conjugated_form: string, basic_form: string, reading: string, pronunciation: string}} AnalyzedToken\n * @see https://github.com/takuyaa/kuromoji.js#api\n */\n\n/**\n * Analyzed result Object\n * @typedef {{type:string, value:string, surface: string, token:AnalyzedToken, index: number}} AnalyzedResultObject\n */\n\n/**\n * デフォルトのオプション値\n * @type {{ignoreConjunction: boolean}}\n */\nconst defaultOptions = {\n    // 接続的な \"である\" を無視する\n    // e.g.) 今日はいい天気であるが明日はどうなるかは分からない。\n    ignoreConjunction: false\n};\n/**\n * Type enum\n * @type {{desu: string, dearu: string}}\n * @example\n *  analyze(text).filter(results => results.type === Types.desu);\n */\nexport const Types = {\n    desu: \"特殊・デス\",\n    masu: \"特殊・マス\",\n    dearu: \"特殊・ダ\"\n};\n\n/**\n * @param {AnalyzedResultObject} resultObject\n * @returns {boolean}\n */\nexport function isDesumasu({ type }) {\n    return isDesumasuType(type);\n}\n\n/**\n * @param {AnalyzedResultObject} resultObject\n * @returns {boolean}\n */\nexport function isDearu({ type }) {\n    return isDearuType(type);\n}\n\n/**\n * typeが敬体(ですます調)か常体(である調)かを判定する\n * @param {string} type\n * @returns {boolean}\n */\nconst isDesumasuType = (type) => type === Types.desu || type === Types.masu;\nconst isDearuType = (type) => type === Types.dearu;\n\n/**\n * tokenが文末のtokenなのかどうか\n * 文末とは\"。\"やこれ以上後ろにtokenがないケースを示す\n * @param {AnalyzedToken} targetToken\n * @param allTokens\n * @returns {boolean}\n */\nconst isLastToken = (targetToken, allTokens) => {\n    const nextPunctureToken = findNextPunctureToken(targetToken, allTokens);\n    if (nextPunctureToken === undefined) {\n        return true;\n    }\n    const nextPunctureTokenSurface = nextPunctureToken.surface_form;\n    if (/[\\!\\?！？。]/.test(nextPunctureTokenSurface)) {\n        return true;\n    }\n};\n/**\n * targetTokenより後ろにあるtokenから切り口となるtokenを探す\n * @param targetToken\n * @param allTokens\n * @returns {AnalyzedToken|undefined}\n */\nconst findNextPunctureToken = (targetToken, allTokens) => {\n    const PUNCTUATION = /、|。/;\n    const CONJUGATED_TYPE = /特殊/;\n    const indexOfTargetToken = allTokens.indexOf(targetToken);\n    // value is collection of these tokens: [ {target}, token, token, nextTarget|PunctuationToken ]\n    const postTokens = allTokens.slice(indexOfTargetToken + 1);\n    return postTokens.find((token) => {\n        // 接続、末尾なので切る\n        if (PUNCTUATION.test(token[\"surface_form\"])) {\n            return true;\n        }\n        // 次の特殊・がきたら\n        if (CONJUGATED_TYPE.test(token[\"conjugated_type\"])) {\n            return true;\n        }\n        // 明示的なtokenがない場合は、名詞がきたらそこで切ってしまう\n        if (token[\"pos\"] === \"名詞\") {\n            return true;\n        }\n        return false;\n    });\n};\n/**\n * tokensからAnalyzedTokenにmapを作る\n * @param {AnalyzedToken[]}tokens\n * @returns {function(token: AnalyzedToken)}\n */\nconst mapToAnalyzedResult = (tokens) => {\n    /**\n     * @param {AnalyzedToken} token\n     * @return {AnalyzedResultObject}\n     */\n    return function mapTokenToAnalyzedResult(token) {\n        const indexOfTargetToken = tokens.indexOf(token);\n        const nextPunctureToken = findNextPunctureToken(token, tokens);\n        // if has not next token, use between token <--> last.\n        const nextTokenIndex = nextPunctureToken ? tokens.indexOf(nextPunctureToken) : tokens.length;\n        const valueTokens = tokens.slice(indexOfTargetToken, nextTokenIndex + 1);\n        const value = valueTokens.map((token) => token[\"surface_form\"]).join(\"\");\n        return {\n            type: token[\"conjugated_type\"],\n            value: value,\n            surface: token[\"surface_form\"],\n            // index start with 0\n            index: token[\"word_position\"] - 1,\n            /**\n             * @type {AnalyzedToken}\n             */\n            token: Object.assign({}, token)\n        };\n    };\n};\n\n/**\n * `text`から敬体(ですます調)と常体(である調)を取り出した結果を返します。\n * @param {string} text\n * @param {Object} options\n * @returns {Promise.<AnalyzedResultObject[]>}\n */\nexport function analyze(text, options = defaultOptions) {\n    const ignoreConjunction =\n        options.ignoreConjunction !== undefined ? options.ignoreConjunction : defaultOptions.ignoreConjunction;\n    return tokenize(text).then((tokens) => {\n        const filterByType = tokens.filter((token, index) => {\n            const nextToken = tokens[index + 1];\n            // token[特殊・ダ] + nextToken[アル] なら 常体(である調) として認識する\n            const conjugatedType = token[\"conjugated_type\"];\n            if (isDearuType(conjugatedType)) {\n                // \"である\" を取り出す。この時点では接続なのか末尾なのかは区別できない\n                if (token[\"pos\"] === \"助動詞\" && token[\"conjugated_form\"] === \"連用形\") {\n                    if (nextToken && nextToken[\"conjugated_type\"] === \"五段・ラ行アル\") {\n                        // 文末の\"である\"のみを許容する場合は文末であるかどうかを調べる\n                        if (ignoreConjunction) {\n                            return isLastToken(token, tokens);\n                        } else {\n                            return true;\n                        }\n                    }\n                }\n            } else if (isDesumasuType(conjugatedType)) {\n                // TODO: can omit?\n                if (token[\"conjugated_form\"] === \"基本形\") {\n                    // 文末の\"です\"のみを許容する場合は、文末であるかどうかを調べる\n                    if (ignoreConjunction) {\n                        return isLastToken(token, tokens);\n                    } else {\n                        return true;\n                    }\n                }\n            }\n        });\n        return filterByType.map(mapToAnalyzedResult(tokens));\n    });\n}\n\n/**\n * `text` の敬体(ですます調)について解析し、敬体(ですます調)のトークン情報を返します。\n * @param {string} text\n * @param {Object} options\n * @return {Promise.<AnalyzedResultObject[]>}\n */\nexport function analyzeDesumasu(text, options = defaultOptions) {\n    return analyze(text, options).then((results) => results.filter(isDesumasu));\n}\n\n/**\n * `text` の常体(である調)について解析し、常体(である調)のトークン情報を返します。\n * @param {string} text\n * @param {Object} options\n * @return {Promise.<AnalyzedResultObject[]>}\n */\nexport function analyzeDearu(text, options = defaultOptions) {\n    return analyze(text, options).then((results) => results.filter(isDearu));\n}\n"],"file":"analyze.js"}