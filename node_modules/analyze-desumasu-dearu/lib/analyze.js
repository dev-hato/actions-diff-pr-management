// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDesumasu = isDesumasu;
exports.isDearu = isDearu;
exports.analyze = analyze;
exports.analyzeDesumasu = analyzeDesumasu;
exports.analyzeDearu = analyzeDearu;
exports.Types = void 0;

var tokenize = require("kuromojin").tokenize;
/**
 * token object
 * @typedef {{word_id: number, word_type: string, word_position: number, surface_form: string, pos: string, pos_detail_1: string, pos_detail_2: string, pos_detail_3: string, conjugated_type: string, conjugated_form: string, basic_form: string, reading: string, pronunciation: string}} AnalyzedToken
 * @see https://github.com/takuyaa/kuromoji.js#api
 */

/**
 * Analyzed result Object
 * @typedef {{type:string, value:string, surface: string, token:AnalyzedToken, index: number}} AnalyzedResultObject
 */

/**
 * デフォルトのオプション値
 * @type {{ignoreConjunction: boolean}}
 */


var defaultOptions = {
  // 接続的な "である" を無視する
  // e.g.) 今日はいい天気であるが明日はどうなるかは分からない。
  ignoreConjunction: false
};
/**
 * Type enum
 * @type {{desu: string, dearu: string}}
 * @example
 *  analyze(text).filter(results => results.type === Types.desu);
 */

var Types = {
  desu: "特殊・デス",
  masu: "特殊・マス",
  dearu: "特殊・ダ"
};
/**
 * @param {AnalyzedResultObject} resultObject
 * @returns {boolean}
 */

exports.Types = Types;

function isDesumasu(_ref) {
  var type = _ref.type;
  return isDesumasuType(type);
}
/**
 * @param {AnalyzedResultObject} resultObject
 * @returns {boolean}
 */


function isDearu(_ref2) {
  var type = _ref2.type;
  return isDearuType(type);
}
/**
 * typeが敬体(ですます調)か常体(である調)かを判定する
 * @param {string} type
 * @returns {boolean}
 */


var isDesumasuType = function isDesumasuType(type) {
  return type === Types.desu || type === Types.masu;
};

var isDearuType = function isDearuType(type) {
  return type === Types.dearu;
};
/**
 * tokenが文末のtokenなのかどうか
 * 文末とは"。"やこれ以上後ろにtokenがないケースを示す
 * @param {AnalyzedToken} targetToken
 * @param allTokens
 * @returns {boolean}
 */


var isLastToken = function isLastToken(targetToken, allTokens) {
  var nextPunctureToken = findNextPunctureToken(targetToken, allTokens);

  if (nextPunctureToken === undefined) {
    return true;
  }

  var nextPunctureTokenSurface = nextPunctureToken.surface_form;

  if (/[\!\?！？。]/.test(nextPunctureTokenSurface)) {
    return true;
  }
};
/**
 * targetTokenより後ろにあるtokenから切り口となるtokenを探す
 * @param targetToken
 * @param allTokens
 * @returns {AnalyzedToken|undefined}
 */


var findNextPunctureToken = function findNextPunctureToken(targetToken, allTokens) {
  var PUNCTUATION = /、|。/;
  var CONJUGATED_TYPE = /特殊/;
  var indexOfTargetToken = allTokens.indexOf(targetToken); // value is collection of these tokens: [ {target}, token, token, nextTarget|PunctuationToken ]

  var postTokens = allTokens.slice(indexOfTargetToken + 1);
  return postTokens.find(function (token) {
    // 接続、末尾なので切る
    if (PUNCTUATION.test(token["surface_form"])) {
      return true;
    } // 次の特殊・がきたら


    if (CONJUGATED_TYPE.test(token["conjugated_type"])) {
      return true;
    } // 明示的なtokenがない場合は、名詞がきたらそこで切ってしまう


    if (token["pos"] === "名詞") {
      return true;
    }

    return false;
  });
};
/**
 * tokensからAnalyzedTokenにmapを作る
 * @param {AnalyzedToken[]}tokens
 * @returns {function(token: AnalyzedToken)}
 */


var mapToAnalyzedResult = function mapToAnalyzedResult(tokens) {
  /**
   * @param {AnalyzedToken} token
   * @return {AnalyzedResultObject}
   */
  return function mapTokenToAnalyzedResult(token) {
    var indexOfTargetToken = tokens.indexOf(token);
    var nextPunctureToken = findNextPunctureToken(token, tokens); // if has not next token, use between token <--> last.

    var nextTokenIndex = nextPunctureToken ? tokens.indexOf(nextPunctureToken) : tokens.length;
    var valueTokens = tokens.slice(indexOfTargetToken, nextTokenIndex + 1);
    var value = valueTokens.map(function (token) {
      return token["surface_form"];
    }).join("");
    return {
      type: token["conjugated_type"],
      value: value,
      surface: token["surface_form"],
      // index start with 0
      index: token["word_position"] - 1,

      /**
       * @type {AnalyzedToken}
       */
      token: Object.assign({}, token)
    };
  };
};
/**
 * `text`から敬体(ですます調)と常体(である調)を取り出した結果を返します。
 * @param {string} text
 * @param {Object} options
 * @returns {Promise.<AnalyzedResultObject[]>}
 */


function analyze(text) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;
  var ignoreConjunction = options.ignoreConjunction !== undefined ? options.ignoreConjunction : defaultOptions.ignoreConjunction;
  return tokenize(text).then(function (tokens) {
    var filterByType = tokens.filter(function (token, index) {
      var nextToken = tokens[index + 1]; // token[特殊・ダ] + nextToken[アル] なら 常体(である調) として認識する

      var conjugatedType = token["conjugated_type"];

      if (isDearuType(conjugatedType)) {
        // "である" を取り出す。この時点では接続なのか末尾なのかは区別できない
        if (token["pos"] === "助動詞" && token["conjugated_form"] === "連用形") {
          if (nextToken && nextToken["conjugated_type"] === "五段・ラ行アル") {
            // 文末の"である"のみを許容する場合は文末であるかどうかを調べる
            if (ignoreConjunction) {
              return isLastToken(token, tokens);
            } else {
              return true;
            }
          }
        }
      } else if (isDesumasuType(conjugatedType)) {
        // TODO: can omit?
        if (token["conjugated_form"] === "基本形") {
          // 文末の"です"のみを許容する場合は、文末であるかどうかを調べる
          if (ignoreConjunction) {
            return isLastToken(token, tokens);
          } else {
            return true;
          }
        }
      }
    });
    return filterByType.map(mapToAnalyzedResult(tokens));
  });
}
/**
 * `text` の敬体(ですます調)について解析し、敬体(ですます調)のトークン情報を返します。
 * @param {string} text
 * @param {Object} options
 * @return {Promise.<AnalyzedResultObject[]>}
 */


function analyzeDesumasu(text) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;
  return analyze(text, options).then(function (results) {
    return results.filter(isDesumasu);
  });
}
/**
 * `text` の常体(である調)について解析し、常体(である調)のトークン情報を返します。
 * @param {string} text
 * @param {Object} options
 * @return {Promise.<AnalyzedResultObject[]>}
 */


function analyzeDearu(text) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;
  return analyze(text, options).then(function (results) {
    return results.filter(isDearu);
  });
}
//# sourceMappingURL=analyze.js.map