{"version":3,"sources":["../src/textlint-rule-ja-no-successive-word.js"],"names":["DefaultOptions","allowOnomatopee","allow","isOnomatopee","str","test","context","options","undefined","Syntax","RuleError","report","getSource","Str","node","text","then","tokens","prevToken","reportIfMatch","nextToken","prevWord","surface_form","currentWord","length","index","Math","max","word_position","forEach","token"],"mappings":"AAAA;AACA;;;;;;;AACA;;AACA;;AAEA,IAAMA,cAAc,GAAG;AACnB;AACA;AACA;AACA;AACAC,EAAAA,eAAe,EAAE,IALE;AAOnB;AACA;AACAC,EAAAA,KAAK,EAAE;AATY,CAAvB;;AAYA,SAASC,YAAT,CAAsBC,GAAtB,EAA2B;AACvB,SAAO,eAAeC,IAAf,CAAoBD,GAApB,CAAP;AACH;;AAEc,kBAASE,OAAT,EAAgC;AAAA,MAAdC,OAAc,uEAAJ,EAAI;AAC3C,MAAMN,eAAe,GAAGM,OAAO,CAACN,eAAR,KAA4BO,SAA5B,GAAwCD,OAAO,CAACN,eAAhD,GACwCD,cAAc,CAACC,eAD/E;AAEA,MAAMC,KAAK,GAAGK,OAAO,CAACL,KAAR,IAAiBF,cAAc,CAACE,KAA9C;AACA,MAAM;AAAEO,IAAAA,MAAF;AAAUC,IAAAA,SAAV;AAAqBC,IAAAA,MAArB;AAA6BC,IAAAA;AAA7B,MAA2CN,OAAjD;AACA,SAAO;AACH,KAACG,MAAM,CAACI,GAAR,EAAaC,IAAb,EAAmB;AACf,UAAMC,IAAI,GAAGH,SAAS,CAACE,IAAD,CAAtB;AACA,aAAO,yBAASC,IAAT,EAAeC,IAAf,CAAoBC,MAAM,IAAI;AACjC,YAAIC,SAAS,GAAG,EAAhB;;AACA,YAAMC,aAAa,GAAG,CAACD,SAAD,EAAYE,SAAZ,KAA0B;AAC5C,cAAMC,QAAQ,GAAGH,SAAS,CAACI,YAA3B;AACA,cAAMC,WAAW,GAAGH,SAAS,CAACE,YAA9B;;AACA,cAAI,IAAIpB,KAAK,CAACsB,MAAV,IAAoB,IAAI,wCAAcD,WAAd,EAA2BrB,KAA3B,EAAkCsB,MAA9D,EAAsE;AAClE;AACH;;AACD,cAAIH,QAAQ,KAAKE,WAAjB,EAA8B;AAC1B;AACH;;AACD,cAAItB,eAAe,IAAIE,YAAY,CAACkB,QAAD,CAA/B,IAA6ClB,YAAY,CAACoB,WAAD,CAA7D,EAA4E;AACxE;AACH;;AACD,cAAME,KAAK,GAAGC,IAAI,CAACC,GAAL,CAASP,SAAS,CAACQ,aAAV,GAA0B,CAAnC,EAAsC,CAAtC,CAAd;AACAjB,UAAAA,MAAM,CAACG,IAAD,EAAO,IAAIJ,SAAJ,aAAkBa,WAAlB,+FAAkD;AAC3DE,YAAAA;AAD2D,WAAlD,CAAP,CAAN;AAGH,SAhBD;;AAiBAR,QAAAA,MAAM,CAACY,OAAP,CAAeC,KAAK,IAAI;AACpBX,UAAAA,aAAa,CAACD,SAAD,EAAYY,KAAZ,CAAb;AACAZ,UAAAA,SAAS,GAAGY,KAAZ;AACH,SAHD;AAIH,OAvBM,CAAP;AAwBH;;AA3BE,GAAP;AA6BH;;AAAA","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport { matchPatterns } from \"@textlint/regexp-string-matcher\";\nimport { tokenize } from \"kuromojin\";\n\nconst DefaultOptions = {\n    // オノマトペを許可する\n    // 制限: オノマトペを判定する方法がないため、同じカタカナの語が連続したものをオノマトペとして扱う\n    // 例) カクカク、ドキドキ、ビリビリ\n    // https://ja.wikipedia.org/wiki/%E6%93%AC%E5%A3%B0%E8%AA%9E\n    allowOnomatopee: true,\n\n    // 許可する単語\n    // RegExp-like Stringを使用可能\n    allow: []\n};\n\nfunction isOnomatopee(str) {\n    return /^[ァ-ロワヲンー]*$/.test(str);\n}\n\nexport default function(context, options = {}) {\n    const allowOnomatopee = options.allowOnomatopee !== undefined ? options.allowOnomatopee\n                                                                  : DefaultOptions.allowOnomatopee;\n    const allow = options.allow || DefaultOptions.allow;\n    const { Syntax, RuleError, report, getSource } = context;\n    return {\n        [Syntax.Str](node) {\n            const text = getSource(node);\n            return tokenize(text).then(tokens => {\n                let prevToken = {};\n                const reportIfMatch = (prevToken, nextToken) => {\n                    const prevWord = prevToken.surface_form;\n                    const currentWord = nextToken.surface_form;\n                    if (0 < allow.length && 0 < matchPatterns(currentWord, allow).length) {\n                        return;\n                    }\n                    if (prevWord !== currentWord) {\n                        return;\n                    }\n                    if (allowOnomatopee && isOnomatopee(prevWord) && isOnomatopee(currentWord)) {\n                        return;\n                    }\n                    const index = Math.max(nextToken.word_position - 1, 0);\n                    report(node, new RuleError(`\"${currentWord}\" が連続して2回使われています。`, {\n                        index\n                    }));\n                };\n                tokens.forEach(token => {\n                    reportIfMatch(prevToken, token);\n                    prevToken = token;\n                });\n            });\n        }\n    }\n};\n"],"file":"textlint-rule-ja-no-successive-word.js"}