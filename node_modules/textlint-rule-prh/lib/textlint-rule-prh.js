// LICENSE : MIT
"use strict";

var _textlintRuleHelper = require("textlint-rule-helper");

var _parser = require("@babel/parser");

/**
 * RegExp#flags polyfill
 */
if (RegExp.prototype.flags === undefined) {
  Object.defineProperty(RegExp.prototype, "flags", {
    configurable: true,
    get: function get() {
      return this.toString().match(/[gimuy]*$/)[0];
    }
  });
}

var prh = require("prh");

var path = require("path");

var untildify = require("untildify");

var defaultOptions = {
  checkLink: false,
  checkBlockQuote: false,
  checkEmphasis: false,
  checkHeader: true,

  /**
   * Check CodeBlock text
   * Default: []
   */
  checkCodeComment: [],

  /**
   * Report parsing error for debug
   */
  debug: false
};

function createPrhEngine(rulePaths, baseDir) {
  if (rulePaths.length === 0) {
    return null;
  }

  var expandedRulePaths = rulePaths.map(rulePath => untildify(rulePath));
  var prhEngine = prh.fromYAMLFilePath(path.resolve(baseDir, expandedRulePaths[0]));
  expandedRulePaths.slice(1).forEach(ruleFilePath => {
    var config = prh.fromYAMLFilePath(path.resolve(baseDir, ruleFilePath));
    prhEngine.merge(config);
  });
  return prhEngine;
}

function createPrhEngineFromContents(yamlContents) {
  if (yamlContents.length === 0) {
    return null;
  }

  var dummyFilePath = "";
  var prhEngine = prh.fromYAML(dummyFilePath, yamlContents[0]);
  yamlContents.slice(1).forEach(content => {
    var config = prh.fromYAML(dummyFilePath, content);
    prhEngine.merge(config);
  });
  return prhEngine;
}

function mergePrh() {
  for (var _len = arguments.length, engines = new Array(_len), _key = 0; _key < _len; _key++) {
    engines[_key] = arguments[_key];
  }

  var engines_ = engines.filter(engine => !!engine);
  var mainEngine = engines_[0];
  engines_.slice(1).forEach(engine => {
    mainEngine.merge(engine);
  });
  return mainEngine;
}

var assertOptions = options => {
  if (typeof options.ruleContents === "undefined" && typeof options.rulePaths === "undefined") {
    throw new Error("textlint-rule-prh require Rule Options.\nPlease set .textlintrc:\n{\n    \"rules\": {\n        \"prh\": {\n            \"rulePaths\" :[\"path/to/prh.yml\"]\n        }\n    }\n}\n");
  }
};

var createIgnoreNodeTypes = (options, Syntax) => {
  var nodeTypes = [];

  if (!options.checkLink) {
    nodeTypes.push(Syntax.Link);
  }

  if (!options.checkBlockQuote) {
    nodeTypes.push(Syntax.BlockQuote);
  }

  if (!options.checkEmphasis) {
    nodeTypes.push(Syntax.Emphasis);
  }

  if (!options.checkHeader) {
    nodeTypes.push(Syntax.Header);
  }

  return nodeTypes;
};
/**
 * for each diff of changeSet
 * @param {ChangeSet} changeSet
 * @param {string} str
 * @param {function({
            matchStartIndex: number,
            matchEndIndex: number,
            actual: string
            expected: string
        })}onChangeOfMatch
 */


var forEachChange = (changeSet, str, onChangeOfMatch) => {
  var sortedDiffs = changeSet.diffs.sort(function (a, b) {
    return a.index - b.index;
  });
  var delta = 0;
  sortedDiffs.forEach(function (diff) {
    var result = diff.expected.replace(/\$([0-9]{1,2})/g, function (match, g1) {
      var index = parseInt(g1);

      if (index === 0 || diff.matches.length - 1 < index) {
        return match;
      }

      return diff.matches[index] || "";
    }); // matchStartIndex/matchEndIndex value is original position, not replaced position
    // textlint use original position

    var matchStartIndex = diff.index;
    var matchEndIndex = matchStartIndex + diff.matches[0].length; // actual => expected

    var actual = str.slice(diff.index + delta, diff.index + delta + diff.matches[0].length);
    var prh = diff.rule.raw.prh || null;
    onChangeOfMatch({
      matchStartIndex,
      matchEndIndex,
      actual: actual,
      expected: result,
      prh
    });
    str = str.slice(0, diff.index + delta) + result + str.slice(diff.index + delta + diff.matches[0].length);
    delta += result.length - diff.matches[0].length;
  });
};

var getConfigBaseDir = context => {
  if (typeof context.getConfigBaseDir === "function") {
    return context.getConfigBaseDir() || process.cwd();
  } // Old fallback that use deprecated `config` value
  // https://github.com/textlint/textlint/issues/294


  var textlintRcFilePath = context.config ? context.config.configFile : null; // .textlintrc directory

  return textlintRcFilePath ? path.dirname(textlintRcFilePath) : process.cwd();
};
/**
 * [Markdown] get actual code value from CodeBlock node
 * @param {Object} node
 * @param {string} raw raw value include CodeBlock syntax
 * @returns {string}
 */


function getUntrimmedCode(node, raw) {
  if (node.type !== "CodeBlock") {
    return node.value;
  } // Space indented CodeBlock that has not lang


  if (!node.lang) {
    return node.value;
  } // If it is not markdown codeBlock, just use node.value


  if (!(raw.startsWith("```") && raw.endsWith("```"))) {
    if (node.value.endsWith("\n")) {
      return node.value;
    }

    return node.value + "\n";
  } // Markdown(remark) specific hack
  // https://github.com/wooorm/remark/issues/207#issuecomment-244620590


  var lines = raw.split("\n"); // code lines without the first line and the last line

  var codeLines = lines.slice(1, lines.length - 1); // add last new line
  // \n```

  return codeLines.join("\n") + "\n";
}

function reporter(context) {
  var userOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  assertOptions(userOptions);
  var options = Object.assign({}, defaultOptions, userOptions); // .textlintrc directory

  var textlintRCDir = getConfigBaseDir(context); // create prh config

  var rulePaths = options.rulePaths || [];
  var ruleContents = options.ruleContents || []; // yaml file + yaml contents

  var prhEngineContent = createPrhEngineFromContents(ruleContents);
  var prhEngineFiles = createPrhEngine(rulePaths, textlintRCDir);
  var prhEngine = mergePrh(prhEngineFiles, prhEngineContent);
  var helper = new _textlintRuleHelper.RuleHelper(context);
  var {
    Syntax,
    getSource,
    report,
    fixer,
    RuleError
  } = context;
  var ignoreNodeTypes = createIgnoreNodeTypes(options, Syntax);
  var codeCommentTypes = options.checkCodeComment ? options.checkCodeComment : defaultOptions.checkCodeComment;
  var isDebug = options.debug ? options.debug : defaultOptions.debug;
  return {
    [Syntax.Str](node) {
      if (helper.isChildNode(node, ignoreNodeTypes)) {
        return;
      }

      var text = getSource(node); // to get position from index
      // https://github.com/prh/prh/issues/29

      var dummyFilePath = "";
      var makeChangeSet = prhEngine.makeChangeSet(dummyFilePath, text);
      forEachChange(makeChangeSet, text, (_ref) => {
        var {
          matchStartIndex,
          matchEndIndex,
          actual,
          expected,
          prh
        } = _ref;

        // If result is not changed, should not report
        if (actual === expected) {
          return;
        }

        var suffix = prh !== null ? "\n" + prh : "";
        var messages = actual + " => " + expected + suffix;
        report(node, new RuleError(messages, {
          index: matchStartIndex,
          fix: fixer.replaceTextRange([matchStartIndex, matchEndIndex], expected)
        }));
      });
    },

    [Syntax.CodeBlock](node) {
      var lang = node.lang;

      if (!lang) {
        return;
      }

      var checkLang = codeCommentTypes.some(type => {
        return type === node.lang;
      });

      if (!checkLang) {
        return;
      }

      var rawText = getSource(node);
      var codeText = getUntrimmedCode(node, rawText);
      var sourceBlockDiffIndex = rawText !== node.value ? rawText.indexOf(codeText) : 0;

      var reportComment = comment => {
        // to get position from index
        // https://github.com/prh/prh/issues/29
        var dummyFilePath = ""; // TODO: trim option for value?

        var text = comment.value;
        var makeChangeSet = prhEngine.makeChangeSet(dummyFilePath, text);
        forEachChange(makeChangeSet, text, (_ref2) => {
          var {
            matchStartIndex,
            matchEndIndex,
            actual,
            expected,
            prh
          } = _ref2;

          // If result is not changed, should not report
          if (actual === expected) {
            return;
          }

          var suffix = prh !== null ? "\n" + prh : "";
          var messages = actual + " => " + expected + suffix;
          var commentIdentifier = comment.type === "CommentBlock" ? "/*" : "//";
          var commentStart = sourceBlockDiffIndex + comment.start + commentIdentifier.length;
          report(node, new RuleError(messages, {
            index: commentStart + matchStartIndex,
            fix: fixer.replaceTextRange([commentStart + matchStartIndex, commentStart + matchEndIndex], expected)
          }));
        });
      };

      try {
        var AST = (0, _parser.parse)(codeText, {
          ranges: true,
          allowReturnOutsideFunction: true,
          allowAwaitOutsideFunction: true,
          allowUndeclaredExports: true,
          allowSuperOutsideMethod: true
        });
        var comments = AST.comments;

        if (!comments) {
          return;
        }

        comments.forEach(comment => {
          reportComment(comment);
        });
      } catch (error) {
        if (isDebug) {
          console.error(error);
          report(node, new RuleError(error.message));
        }
      }
    }

  };
}

module.exports = {
  linter: reporter,
  fixer: reporter
};
//# sourceMappingURL=textlint-rule-prh.js.map