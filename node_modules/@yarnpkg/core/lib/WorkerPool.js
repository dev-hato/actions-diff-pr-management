"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerPool = void 0;
const tslib_1 = require("tslib");
const os_1 = require("os");
const p_queue_1 = (0, tslib_1.__importDefault)(require("p-queue"));
const worker_threads_1 = require("worker_threads");
class WorkerPool {
    constructor(source) {
        this.source = source;
        this.pool = [];
        this.queue = new p_queue_1.default({
            concurrency: Math.max(1, (0, os_1.cpus)().length),
        });
        const timeout = setTimeout(() => {
            if (this.queue.size !== 0 || this.queue.pending !== 0)
                return;
            for (const worker of this.pool)
                worker.terminate();
            this.pool = [];
        }, 1000).unref();
        this.queue.on(`idle`, () => {
            timeout.refresh();
        });
    }
    run(data) {
        return this.queue.add(() => {
            var _a;
            const worker = (_a = this.pool.pop()) !== null && _a !== void 0 ? _a : new worker_threads_1.Worker(this.source, {
                eval: true,
                execArgv: [...process.execArgv, `--unhandled-rejections=strict`],
            });
            worker.ref();
            return new Promise((resolve, reject) => {
                const exitHandler = (code) => {
                    if (code !== 0) {
                        reject(new Error(`Worker exited with code ${code}`));
                    }
                };
                worker.once(`message`, (result) => {
                    this.pool.push(worker);
                    worker.unref();
                    worker.off(`error`, reject);
                    worker.off(`exit`, exitHandler);
                    resolve(result);
                });
                worker.once(`error`, reject);
                worker.once(`exit`, exitHandler);
                worker.postMessage(data);
            });
        });
    }
}
exports.WorkerPool = WorkerPool;
