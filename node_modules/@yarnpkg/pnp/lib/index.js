'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const zlib = require('zlib');
const fs = require('fs');
const path = require('path');
const nodeUtils = require('util');
const module$1 = require('module');
const os = require('os');

const _interopDefaultLegacy = e => e && typeof e === 'object' && 'default' in e ? e : { default: e };

const zlib__default = /*#__PURE__*/_interopDefaultLegacy(zlib);
const fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
const path__default = /*#__PURE__*/_interopDefaultLegacy(path);

exports.LinkType = void 0;
(function(LinkType2) {
  LinkType2["HARD"] = `HARD`;
  LinkType2["SOFT"] = `SOFT`;
})(exports.LinkType || (exports.LinkType = {}));

var PrettyJsonState;
(function(PrettyJsonState2) {
  PrettyJsonState2["DEFAULT"] = `DEFAULT`;
  PrettyJsonState2["TOP_LEVEL"] = `TOP_LEVEL`;
  PrettyJsonState2["FALLBACK_EXCLUSION_LIST"] = `FALLBACK_EXCLUSION_LIST`;
  PrettyJsonState2["FALLBACK_EXCLUSION_ENTRIES"] = `FALLBACK_EXCLUSION_ENTRIES`;
  PrettyJsonState2["FALLBACK_EXCLUSION_DATA"] = `FALLBACK_EXCLUSION_DATA`;
  PrettyJsonState2["PACKAGE_REGISTRY_DATA"] = `PACKAGE_REGISTRY_DATA`;
  PrettyJsonState2["PACKAGE_REGISTRY_ENTRIES"] = `PACKAGE_REGISTRY_ENTRIES`;
  PrettyJsonState2["PACKAGE_STORE_DATA"] = `PACKAGE_STORE_DATA`;
  PrettyJsonState2["PACKAGE_STORE_ENTRIES"] = `PACKAGE_STORE_ENTRIES`;
  PrettyJsonState2["PACKAGE_INFORMATION_DATA"] = `PACKAGE_INFORMATION_DATA`;
  PrettyJsonState2["PACKAGE_DEPENDENCIES"] = `PACKAGE_DEPENDENCIES`;
  PrettyJsonState2["PACKAGE_DEPENDENCY"] = `PACKAGE_DEPENDENCY`;
})(PrettyJsonState || (PrettyJsonState = {}));
const prettyJsonMachine = {
  [PrettyJsonState.DEFAULT]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.DEFAULT
    }
  },
  [PrettyJsonState.TOP_LEVEL]: {
    collapsed: false,
    next: {
      [`fallbackExclusionList`]: PrettyJsonState.FALLBACK_EXCLUSION_LIST,
      [`packageRegistryData`]: PrettyJsonState.PACKAGE_REGISTRY_DATA,
      [`*`]: PrettyJsonState.DEFAULT
    }
  },
  [PrettyJsonState.FALLBACK_EXCLUSION_LIST]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.FALLBACK_EXCLUSION_ENTRIES
    }
  },
  [PrettyJsonState.FALLBACK_EXCLUSION_ENTRIES]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.FALLBACK_EXCLUSION_DATA
    }
  },
  [PrettyJsonState.FALLBACK_EXCLUSION_DATA]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.DEFAULT
    }
  },
  [PrettyJsonState.PACKAGE_REGISTRY_DATA]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_REGISTRY_ENTRIES
    }
  },
  [PrettyJsonState.PACKAGE_REGISTRY_ENTRIES]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_STORE_DATA
    }
  },
  [PrettyJsonState.PACKAGE_STORE_DATA]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_STORE_ENTRIES
    }
  },
  [PrettyJsonState.PACKAGE_STORE_ENTRIES]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_INFORMATION_DATA
    }
  },
  [PrettyJsonState.PACKAGE_INFORMATION_DATA]: {
    collapsed: false,
    next: {
      [`packageDependencies`]: PrettyJsonState.PACKAGE_DEPENDENCIES,
      [`*`]: PrettyJsonState.DEFAULT
    }
  },
  [PrettyJsonState.PACKAGE_DEPENDENCIES]: {
    collapsed: false,
    next: {
      [`*`]: PrettyJsonState.PACKAGE_DEPENDENCY
    }
  },
  [PrettyJsonState.PACKAGE_DEPENDENCY]: {
    collapsed: true,
    next: {
      [`*`]: PrettyJsonState.DEFAULT
    }
  }
};
function generateCollapsedArray(data, state, indent) {
  let result = ``;
  result += `[`;
  for (let t = 0, T = data.length; t < T; ++t) {
    result += generateNext(String(t), data[t], state, indent).replace(/^ +/g, ``);
    if (t + 1 < T) {
      result += `, `;
    }
  }
  result += `]`;
  return result;
}
function generateExpandedArray(data, state, indent) {
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `[
`;
  for (let t = 0, T = data.length; t < T; ++t) {
    result += nextIndent + generateNext(String(t), data[t], state, nextIndent).replace(/^ +/, ``);
    if (t + 1 < T)
      result += `,`;
    result += `
`;
  }
  result += indent;
  result += `]`;
  return result;
}
function generateCollapsedObject(data, state, indent) {
  const keys = Object.keys(data);
  let result = ``;
  result += `{`;
  for (let t = 0, T = keys.length, keysPrinted = 0; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`)
      continue;
    if (keysPrinted !== 0)
      result += `, `;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, indent).replace(/^ +/g, ``);
    keysPrinted += 1;
  }
  result += `}`;
  return result;
}
function generateExpandedObject(data, state, indent) {
  const keys = Object.keys(data);
  const nextIndent = `${indent}  `;
  let result = ``;
  result += indent;
  result += `{
`;
  let keysPrinted = 0;
  for (let t = 0, T = keys.length; t < T; ++t) {
    const key = keys[t];
    const value = data[key];
    if (typeof value === `undefined`)
      continue;
    if (keysPrinted !== 0) {
      result += `,`;
      result += `
`;
    }
    result += nextIndent;
    result += JSON.stringify(key);
    result += `: `;
    result += generateNext(key, value, state, nextIndent).replace(/^ +/g, ``);
    keysPrinted += 1;
  }
  if (keysPrinted !== 0)
    result += `
`;
  result += indent;
  result += `}`;
  return result;
}
function generateNext(key, data, state, indent) {
  const {next} = prettyJsonMachine[state];
  const nextState = next[key] || next[`*`];
  return generate(data, nextState, indent);
}
function generate(data, state, indent) {
  const {collapsed} = prettyJsonMachine[state];
  if (Array.isArray(data)) {
    if (collapsed) {
      return generateCollapsedArray(data, state, indent);
    } else {
      return generateExpandedArray(data, state, indent);
    }
  }
  if (typeof data === `object` && data !== null) {
    if (collapsed) {
      return generateCollapsedObject(data, state, indent);
    } else {
      return generateExpandedObject(data, state, indent);
    }
  }
  return JSON.stringify(data);
}
function generatePrettyJson(data) {
  return generate(data, PrettyJsonState.TOP_LEVEL, ``);
}

function sortMap(values, mappers) {
  const asArray = Array.from(values);
  if (!Array.isArray(mappers))
    mappers = [mappers];
  const stringified = [];
  for (const mapper of mappers)
    stringified.push(asArray.map((value) => mapper(value)));
  const indices = asArray.map((_, index) => index);
  indices.sort((a, b) => {
    for (const layer of stringified) {
      const comparison = layer[a] < layer[b] ? -1 : layer[a] > layer[b] ? 1 : 0;
      if (comparison !== 0) {
        return comparison;
      }
    }
    return 0;
  });
  return indices.map((index) => {
    return asArray[index];
  });
}
function generateFallbackExclusionList(settings) {
  const fallbackExclusionList = new Map();
  const sortedData = sortMap(settings.fallbackExclusionList || [], [
    ({name, reference}) => name,
    ({name, reference}) => reference
  ]);
  for (const {name, reference} of sortedData) {
    let references = fallbackExclusionList.get(name);
    if (typeof references === `undefined`)
      fallbackExclusionList.set(name, references = new Set());
    references.add(reference);
  }
  return Array.from(fallbackExclusionList).map(([name, references]) => {
    return [name, Array.from(references)];
  });
}
function generateFallbackPoolData(settings) {
  return sortMap(settings.fallbackPool || [], ([name]) => name);
}
function generatePackageRegistryData(settings) {
  const packageRegistryData = [];
  for (const [packageName, packageStore] of sortMap(settings.packageRegistry, ([packageName2]) => packageName2 === null ? `0` : `1${packageName2}`)) {
    const packageStoreData = [];
    packageRegistryData.push([packageName, packageStoreData]);
    for (const [packageReference, {packageLocation, packageDependencies, packagePeers, linkType, discardFromLookup}] of sortMap(packageStore, ([packageReference2]) => packageReference2 === null ? `0` : `1${packageReference2}`)) {
      const normalizedDependencies = [];
      if (packageName !== null && packageReference !== null && !packageDependencies.has(packageName))
        normalizedDependencies.push([packageName, packageReference]);
      for (const [dependencyName, dependencyReference] of sortMap(packageDependencies.entries(), ([dependencyName2]) => dependencyName2))
        normalizedDependencies.push([dependencyName, dependencyReference]);
      const normalizedPeers = packagePeers && packagePeers.size > 0 ? Array.from(packagePeers) : void 0;
      const normalizedDiscardFromLookup = discardFromLookup ? discardFromLookup : void 0;
      packageStoreData.push([packageReference, {
        packageLocation,
        packageDependencies: normalizedDependencies,
        packagePeers: normalizedPeers,
        linkType,
        discardFromLookup: normalizedDiscardFromLookup
      }]);
    }
  }
  return packageRegistryData;
}
function generateSerializedState(settings) {
  return {
    __info: [
      `This file is automatically generated. Do not touch it, or risk`,
      `your modifications being lost. We also recommend you not to read`,
      `it either without using the @yarnpkg/pnp package, as the data layout`,
      `is entirely unspecified and WILL change from a version to another.`
    ],
    dependencyTreeRoots: settings.dependencyTreeRoots,
    enableTopLevelFallback: settings.enableTopLevelFallback || false,
    ignorePatternData: settings.ignorePattern || null,
    fallbackExclusionList: generateFallbackExclusionList(settings),
    fallbackPool: generateFallbackPoolData(settings),
    packageRegistryData: generatePackageRegistryData(settings)
  };
}

let hook$1;
var hook_1 = () => {
  if (typeof hook$1 === `undefined`)
    hook$1 = zlib__default.default.brotliDecompressSync(Buffer.from("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", "base64")).toString();
  return hook$1;
};

function generateLoader(shebang, loader) {
  return [
    shebang ? `${shebang}
` : ``,
    `/* eslint-disable */

`,
    `try {
`,
    `  Object.freeze({}).detectStrictMode = true;
`,
    `} catch (error) {
`,
    `  throw new Error(\`The whole PnP file got strict-mode-ified, which is known to break (Emscripten libraries aren't strict mode). This usually happens when the file goes through Babel.\`);
`,
    `}
`,
    `
`,
    `function $$SETUP_STATE(hydrateRuntimeState, basePath) {
`,
    loader.replace(/^/gm, `  `),
    `}
`,
    `
`,
    hook_1()
  ].join(``);
}
function generateJsonString(data) {
  return JSON.stringify(data, null, 2);
}
function generateStringLiteral(value) {
  return `'${value.replace(/\\/g, `\\\\`).replace(/'/g, `\\'`).replace(/\n/g, `\\
`)}'`;
}
function generateInlinedSetup(data) {
  return [
    `return hydrateRuntimeState(JSON.parse(${generateStringLiteral(generatePrettyJson(data))}), {basePath: basePath || __dirname});
`
  ].join(``);
}
function generateSplitSetup(dataLocation) {
  return [
    `var path = require('path');
`,
    `var dataLocation = path.resolve(__dirname, ${JSON.stringify(dataLocation)});
`,
    `return hydrateRuntimeState(require(dataLocation), {basePath: basePath || path.dirname(dataLocation)});
`
  ].join(``);
}
function generateInlinedScript(settings) {
  const data = generateSerializedState(settings);
  const setup = generateInlinedSetup(data);
  const loaderFile = generateLoader(settings.shebang, setup);
  return loaderFile;
}
function generateSplitScript(settings) {
  const data = generateSerializedState(settings);
  const setup = generateSplitSetup(settings.dataLocation);
  const loaderFile = generateLoader(settings.shebang, setup);
  return {dataFile: generateJsonString(data), loaderFile};
}

const SAFE_TIME = 456789e3;

var PathType;
(function(PathType2) {
  PathType2[PathType2["File"] = 0] = "File";
  PathType2[PathType2["Portable"] = 1] = "Portable";
  PathType2[PathType2["Native"] = 2] = "Native";
})(PathType || (PathType = {}));
const PortablePath = {
  root: `/`,
  dot: `.`
};
const Filename = {
  nodeModules: `node_modules`,
  manifest: `package.json`,
  lockfile: `yarn.lock`,
  virtual: `__virtual__`,
  pnpJs: `.pnp.js`,
  pnpCjs: `.pnp.cjs`,
  rc: `.yarnrc.yml`
};
const npath = Object.create(path__default.default);
const ppath = Object.create(path__default.default.posix);
npath.cwd = () => process.cwd();
ppath.cwd = () => toPortablePath(process.cwd());
ppath.resolve = (...segments) => {
  if (segments.length > 0 && ppath.isAbsolute(segments[0])) {
    return path__default.default.posix.resolve(...segments);
  } else {
    return path__default.default.posix.resolve(ppath.cwd(), ...segments);
  }
};
const contains = function(pathUtils, from, to) {
  from = pathUtils.normalize(from);
  to = pathUtils.normalize(to);
  if (from === to)
    return `.`;
  if (!from.endsWith(pathUtils.sep))
    from = from + pathUtils.sep;
  if (to.startsWith(from)) {
    return to.slice(from.length);
  } else {
    return null;
  }
};
npath.fromPortablePath = fromPortablePath;
npath.toPortablePath = toPortablePath;
npath.contains = (from, to) => contains(npath, from, to);
ppath.contains = (from, to) => contains(ppath, from, to);
const WINDOWS_PATH_REGEXP = /^([a-zA-Z]:.*)$/;
const UNC_WINDOWS_PATH_REGEXP = /^\/\/(\.\/)?(.*)$/;
const PORTABLE_PATH_REGEXP = /^\/([a-zA-Z]:.*)$/;
const UNC_PORTABLE_PATH_REGEXP = /^\/unc\/(\.dot\/)?(.*)$/;
function fromPortablePath(p) {
  if (process.platform !== `win32`)
    return p;
  let portablePathMatch, uncPortablePathMatch;
  if (portablePathMatch = p.match(PORTABLE_PATH_REGEXP))
    p = portablePathMatch[1];
  else if (uncPortablePathMatch = p.match(UNC_PORTABLE_PATH_REGEXP))
    p = `\\\\${uncPortablePathMatch[1] ? `.\\` : ``}${uncPortablePathMatch[2]}`;
  else
    return p;
  return p.replace(/\//g, `\\`);
}
function toPortablePath(p) {
  if (process.platform !== `win32`)
    return p;
  p = p.replace(/\\/g, `/`);
  let windowsPathMatch, uncWindowsPathMatch;
  if (windowsPathMatch = p.match(WINDOWS_PATH_REGEXP))
    p = `/${windowsPathMatch[1]}`;
  else if (uncWindowsPathMatch = p.match(UNC_WINDOWS_PATH_REGEXP))
    p = `/unc/${uncWindowsPathMatch[1] ? `.dot/` : ``}${uncWindowsPathMatch[2]}`;
  return p;
}
function convertPath(targetPathUtils, sourcePath) {
  return targetPathUtils === npath ? fromPortablePath(sourcePath) : toPortablePath(sourcePath);
}

var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
const defaultTime = new Date(SAFE_TIME * 1e3);
var LinkStrategy;
(function(LinkStrategy2) {
  LinkStrategy2["Allow"] = `allow`;
  LinkStrategy2["ReadOnly"] = `readOnly`;
})(LinkStrategy || (LinkStrategy = {}));
async function copyPromise(destinationFs, destination, sourceFs, source, opts) {
  const normalizedDestination = destinationFs.pathUtils.normalize(destination);
  const normalizedSource = sourceFs.pathUtils.normalize(source);
  const prelayout = [];
  const postlayout = [];
  const {atime, mtime} = opts.stableTime ? {atime: defaultTime, mtime: defaultTime} : await sourceFs.lstatPromise(normalizedSource);
  await destinationFs.mkdirpPromise(destinationFs.pathUtils.dirname(destination), {utimes: [atime, mtime]});
  const updateTime = typeof destinationFs.lutimesPromise === `function` ? destinationFs.lutimesPromise.bind(destinationFs) : destinationFs.utimesPromise.bind(destinationFs);
  await copyImpl(prelayout, postlayout, updateTime, destinationFs, normalizedDestination, sourceFs, normalizedSource, __spreadProps$2(__spreadValues$2({}, opts), {didParentExist: true}));
  for (const operation of prelayout)
    await operation();
  await Promise.all(postlayout.map((operation) => {
    return operation();
  }));
}
async function copyImpl(prelayout, postlayout, updateTime, destinationFs, destination, sourceFs, source, opts) {
  var _a, _b;
  const destinationStat = opts.didParentExist ? await maybeLStat(destinationFs, destination) : null;
  const sourceStat = await sourceFs.lstatPromise(source);
  const {atime, mtime} = opts.stableTime ? {atime: defaultTime, mtime: defaultTime} : sourceStat;
  let updated;
  switch (true) {
    case sourceStat.isDirectory():
      {
        updated = await copyFolder(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    case sourceStat.isFile():
      {
        updated = await copyFile(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    case sourceStat.isSymbolicLink():
      {
        updated = await copySymlink(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts);
      }
      break;
    default:
      {
        throw new Error(`Unsupported file type (${sourceStat.mode})`);
      }
  }
  if (updated || ((_a = destinationStat == null ? void 0 : destinationStat.mtime) == null ? void 0 : _a.getTime()) !== mtime.getTime() || ((_b = destinationStat == null ? void 0 : destinationStat.atime) == null ? void 0 : _b.getTime()) !== atime.getTime()) {
    postlayout.push(() => updateTime(destination, atime, mtime));
    updated = true;
  }
  if (destinationStat === null || (destinationStat.mode & 511) !== (sourceStat.mode & 511)) {
    postlayout.push(() => destinationFs.chmodPromise(destination, sourceStat.mode & 511));
    updated = true;
  }
  return updated;
}
async function maybeLStat(baseFs, p) {
  try {
    return await baseFs.lstatPromise(p);
  } catch (e) {
    return null;
  }
}
async function copyFolder(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null && !destinationStat.isDirectory()) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  let updated = false;
  if (destinationStat === null) {
    prelayout.push(async () => {
      try {
        await destinationFs.mkdirPromise(destination, {mode: sourceStat.mode});
      } catch (err) {
        if (err.code !== `EEXIST`) {
          throw err;
        }
      }
    });
    updated = true;
  }
  const entries = await sourceFs.readdirPromise(source);
  const nextOpts = opts.didParentExist && !destinationStat ? __spreadProps$2(__spreadValues$2({}, opts), {didParentExist: false}) : opts;
  if (opts.stableSort) {
    for (const entry of entries.sort()) {
      if (await copyImpl(prelayout, postlayout, updateTime, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), nextOpts)) {
        updated = true;
      }
    }
  } else {
    const entriesUpdateStatus = await Promise.all(entries.map(async (entry) => {
      await copyImpl(prelayout, postlayout, updateTime, destinationFs, destinationFs.pathUtils.join(destination, entry), sourceFs, sourceFs.pathUtils.join(source, entry), nextOpts);
    }));
    if (entriesUpdateStatus.some((status) => status)) {
      updated = true;
    }
  }
  return updated;
}
const isCloneSupportedCache = new WeakMap();
function makeLinkOperation(opFs, destination, source, sourceStat, linkStrategy) {
  return async () => {
    await opFs.linkPromise(source, destination);
    if (linkStrategy === LinkStrategy.ReadOnly) {
      sourceStat.mode &= ~146;
      await opFs.chmodPromise(destination, sourceStat.mode);
    }
  };
}
function makeCloneLinkOperation(opFs, destination, source, sourceStat, linkStrategy) {
  const isCloneSupported = isCloneSupportedCache.get(opFs);
  if (typeof isCloneSupported === `undefined`) {
    return async () => {
      try {
        await opFs.copyFilePromise(source, destination, fs__default.default.constants.COPYFILE_FICLONE_FORCE);
        isCloneSupportedCache.set(opFs, true);
      } catch (err) {
        if (err.code === `ENOSYS` || err.code === `ENOTSUP`) {
          isCloneSupportedCache.set(opFs, false);
          await makeLinkOperation(opFs, destination, source, sourceStat, linkStrategy)();
        } else {
          throw err;
        }
      }
    };
  } else {
    if (isCloneSupported) {
      return async () => opFs.copyFilePromise(source, destination, fs__default.default.constants.COPYFILE_FICLONE_FORCE);
    } else {
      return makeLinkOperation(opFs, destination, source, sourceStat, linkStrategy);
    }
  }
}
async function copyFile(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  var _a;
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  const linkStrategy = (_a = opts.linkStrategy) != null ? _a : null;
  const op = destinationFs === sourceFs ? linkStrategy !== null ? makeCloneLinkOperation(destinationFs, destination, source, sourceStat, linkStrategy) : async () => destinationFs.copyFilePromise(source, destination, fs__default.default.constants.COPYFILE_FICLONE) : linkStrategy !== null ? makeLinkOperation(destinationFs, destination, source, sourceStat, linkStrategy) : async () => destinationFs.writeFilePromise(destination, await sourceFs.readFilePromise(source));
  prelayout.push(async () => op());
  return true;
}
async function copySymlink(prelayout, postlayout, updateTime, destinationFs, destination, destinationStat, sourceFs, source, sourceStat, opts) {
  if (destinationStat !== null) {
    if (opts.overwrite) {
      prelayout.push(async () => destinationFs.removePromise(destination));
      destinationStat = null;
    } else {
      return false;
    }
  }
  prelayout.push(async () => {
    await destinationFs.symlinkPromise(convertPath(destinationFs.pathUtils, await sourceFs.readlinkPromise(source)), destination);
  });
  return true;
}

function makeError$1(code, message) {
  return Object.assign(new Error(`${code}: ${message}`), {code});
}
function ENOSYS(message, reason) {
  return makeError$1(`ENOSYS`, `${message}, ${reason}`);
}

class FakeFS {
  constructor(pathUtils) {
    this.pathUtils = pathUtils;
  }
  async *genTraversePromise(init, {stableSort = false} = {}) {
    const stack = [init];
    while (stack.length > 0) {
      const p = stack.shift();
      const entry = await this.lstatPromise(p);
      if (entry.isDirectory()) {
        const entries = await this.readdirPromise(p);
        if (stableSort) {
          for (const entry2 of entries.sort()) {
            stack.push(this.pathUtils.join(p, entry2));
          }
        } else {
          throw new Error(`Not supported`);
        }
      } else {
        yield p;
      }
    }
  }
  async removePromise(p, {recursive = true, maxRetries = 5} = {}) {
    let stat;
    try {
      stat = await this.lstatPromise(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }
    if (stat.isDirectory()) {
      if (recursive) {
        const entries = await this.readdirPromise(p);
        await Promise.all(entries.map((entry) => {
          return this.removePromise(this.pathUtils.resolve(p, entry));
        }));
      }
      for (let t = 0; t <= maxRetries; t++) {
        try {
          await this.rmdirPromise(p);
          break;
        } catch (error) {
          if (error.code !== `EBUSY` && error.code !== `ENOTEMPTY`) {
            throw error;
          } else if (t < maxRetries) {
            await new Promise((resolve) => setTimeout(resolve, t * 100));
          }
        }
      }
    } else {
      await this.unlinkPromise(p);
    }
  }
  removeSync(p, {recursive = true} = {}) {
    let stat;
    try {
      stat = this.lstatSync(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }
    if (stat.isDirectory()) {
      if (recursive)
        for (const entry of this.readdirSync(p))
          this.removeSync(this.pathUtils.resolve(p, entry));
      this.rmdirSync(p);
    } else {
      this.unlinkSync(p);
    }
  }
  async mkdirpPromise(p, {chmod, utimes} = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p))
      return;
    const parts = p.split(this.pathUtils.sep);
    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);
      if (!this.existsSync(subPath)) {
        try {
          await this.mkdirPromise(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }
        if (chmod != null)
          await this.chmodPromise(subPath, chmod);
        if (utimes != null) {
          await this.utimesPromise(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = await this.statPromise(this.pathUtils.dirname(subPath));
          await this.utimesPromise(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
  }
  mkdirpSync(p, {chmod, utimes} = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p))
      return;
    const parts = p.split(this.pathUtils.sep);
    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);
      if (!this.existsSync(subPath)) {
        try {
          this.mkdirSync(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }
        if (chmod != null)
          this.chmodSync(subPath, chmod);
        if (utimes != null) {
          this.utimesSync(subPath, utimes[0], utimes[1]);
        } else {
          const parentStat = this.statSync(this.pathUtils.dirname(subPath));
          this.utimesSync(subPath, parentStat.atime, parentStat.mtime);
        }
      }
    }
  }
  async copyPromise(destination, source, {baseFs = this, overwrite = true, stableSort = false, stableTime = false, linkStrategy = null} = {}) {
    return await copyPromise(this, destination, baseFs, source, {overwrite, stableSort, stableTime, linkStrategy});
  }
  copySync(destination, source, {baseFs = this, overwrite = true} = {}) {
    const stat = baseFs.lstatSync(source);
    const exists = this.existsSync(destination);
    if (stat.isDirectory()) {
      this.mkdirpSync(destination);
      const directoryListing = baseFs.readdirSync(source);
      for (const entry of directoryListing) {
        this.copySync(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), {baseFs, overwrite});
      }
    } else if (stat.isFile()) {
      if (!exists || overwrite) {
        if (exists)
          this.removeSync(destination);
        const content = baseFs.readFileSync(source);
        this.writeFileSync(destination, content);
      }
    } else if (stat.isSymbolicLink()) {
      if (!exists || overwrite) {
        if (exists)
          this.removeSync(destination);
        const target = baseFs.readlinkSync(source);
        this.symlinkSync(convertPath(this.pathUtils, target), destination);
      }
    } else {
      throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
    }
    const mode = stat.mode & 511;
    this.chmodSync(destination, mode);
  }
  async changeFilePromise(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferPromise(p, content, opts);
    } else {
      return this.changeFileTextPromise(p, content, opts);
    }
  }
  async changeFileBufferPromise(p, content, {mode} = {}) {
    let current = Buffer.alloc(0);
    try {
      current = await this.readFilePromise(p);
    } catch (error) {
    }
    if (Buffer.compare(current, content) === 0)
      return;
    await this.writeFilePromise(p, content, {mode});
  }
  async changeFileTextPromise(p, content, {automaticNewlines, mode} = {}) {
    let current = ``;
    try {
      current = await this.readFilePromise(p, `utf8`);
    } catch (error) {
    }
    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent)
      return;
    await this.writeFilePromise(p, normalizedContent, {mode});
  }
  changeFileSync(p, content, opts = {}) {
    if (Buffer.isBuffer(content)) {
      return this.changeFileBufferSync(p, content, opts);
    } else {
      return this.changeFileTextSync(p, content, opts);
    }
  }
  changeFileBufferSync(p, content, {mode} = {}) {
    let current = Buffer.alloc(0);
    try {
      current = this.readFileSync(p);
    } catch (error) {
    }
    if (Buffer.compare(current, content) === 0)
      return;
    this.writeFileSync(p, content, {mode});
  }
  changeFileTextSync(p, content, {automaticNewlines = false, mode} = {}) {
    let current = ``;
    try {
      current = this.readFileSync(p, `utf8`);
    } catch (error) {
    }
    const normalizedContent = automaticNewlines ? normalizeLineEndings(current, content) : content;
    if (current === normalizedContent)
      return;
    this.writeFileSync(p, normalizedContent, {mode});
  }
  async movePromise(fromP, toP) {
    try {
      await this.renamePromise(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        await this.copyPromise(toP, fromP);
        await this.removePromise(fromP);
      } else {
        throw error;
      }
    }
  }
  moveSync(fromP, toP) {
    try {
      this.renameSync(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        this.copySync(toP, fromP);
        this.removeSync(fromP);
      } else {
        throw error;
      }
    }
  }
  async lockPromise(affectedPath, callback) {
    const lockPath = `${affectedPath}.flock`;
    const interval = 1e3 / 60;
    const startTime = Date.now();
    let fd = null;
    const isAlive = async () => {
      let pid;
      try {
        [pid] = await this.readJsonPromise(lockPath);
      } catch (error) {
        return Date.now() - startTime < 500;
      }
      try {
        process.kill(pid, 0);
        return true;
      } catch (error) {
        return false;
      }
    };
    while (fd === null) {
      try {
        fd = await this.openPromise(lockPath, `wx`);
      } catch (error) {
        if (error.code === `EEXIST`) {
          if (!await isAlive()) {
            try {
              await this.unlinkPromise(lockPath);
              continue;
            } catch (error2) {
            }
          }
          if (Date.now() - startTime < 60 * 1e3) {
            await new Promise((resolve) => setTimeout(resolve, interval));
          } else {
            throw new Error(`Couldn't acquire a lock in a reasonable time (via ${lockPath})`);
          }
        } else {
          throw error;
        }
      }
    }
    await this.writePromise(fd, JSON.stringify([process.pid]));
    try {
      return await callback();
    } finally {
      try {
        await this.closePromise(fd);
        await this.unlinkPromise(lockPath);
      } catch (error) {
      }
    }
  }
  async readJsonPromise(p) {
    const content = await this.readFilePromise(p, `utf8`);
    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }
  readJsonSync(p) {
    const content = this.readFileSync(p, `utf8`);
    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }
  async writeJsonPromise(p, data) {
    return await this.writeFilePromise(p, `${JSON.stringify(data, null, 2)}
`);
  }
  writeJsonSync(p, data) {
    return this.writeFileSync(p, `${JSON.stringify(data, null, 2)}
`);
  }
  async preserveTimePromise(p, cb) {
    const stat = await this.lstatPromise(p);
    const result = await cb();
    if (typeof result !== `undefined`)
      p = result;
    if (this.lutimesPromise) {
      await this.lutimesPromise(p, stat.atime, stat.mtime);
    } else if (!stat.isSymbolicLink()) {
      await this.utimesPromise(p, stat.atime, stat.mtime);
    }
  }
  async preserveTimeSync(p, cb) {
    const stat = this.lstatSync(p);
    const result = cb();
    if (typeof result !== `undefined`)
      p = result;
    if (this.lutimesSync) {
      this.lutimesSync(p, stat.atime, stat.mtime);
    } else if (!stat.isSymbolicLink()) {
      this.utimesSync(p, stat.atime, stat.mtime);
    }
  }
}
class BasePortableFakeFS extends FakeFS {
  constructor() {
    super(ppath);
  }
}
function getEndOfLine(content) {
  const matches = content.match(/\r?\n/g);
  if (matches === null)
    return os.EOL;
  const crlf = matches.filter((nl) => nl === `\r
`).length;
  const lf = matches.length - crlf;
  return crlf > lf ? `\r
` : `
`;
}
function normalizeLineEndings(originalContent, newContent) {
  return newContent.replace(/\r?\n/g, getEndOfLine(originalContent));
}

class NodeFS extends BasePortableFakeFS {
  constructor(realFs = fs__default.default) {
    super();
    this.realFs = realFs;
    if (typeof this.realFs.lutimes !== `undefined`) {
      this.lutimesPromise = this.lutimesPromiseImpl;
      this.lutimesSync = this.lutimesSyncImpl;
    }
  }
  getExtractHint() {
    return false;
  }
  getRealPath() {
    return PortablePath.root;
  }
  resolve(p) {
    return ppath.resolve(p);
  }
  async openPromise(p, flags, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.open(npath.fromPortablePath(p), flags, mode, this.makeCallback(resolve, reject));
    });
  }
  openSync(p, flags, mode) {
    return this.realFs.openSync(npath.fromPortablePath(p), flags, mode);
  }
  async opendirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (typeof opts !== `undefined`) {
        this.realFs.opendir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.opendir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    }).then((dir) => {
      return Object.defineProperty(dir, `path`, {value: p, configurable: true, writable: true});
    });
  }
  opendirSync(p, opts) {
    const dir = typeof opts !== `undefined` ? this.realFs.opendirSync(npath.fromPortablePath(p), opts) : this.realFs.opendirSync(npath.fromPortablePath(p));
    return Object.defineProperty(dir, `path`, {value: p, configurable: true, writable: true});
  }
  async readPromise(fd, buffer, offset = 0, length = 0, position = -1) {
    return await new Promise((resolve, reject) => {
      this.realFs.read(fd, buffer, offset, length, position, (error, bytesRead) => {
        if (error) {
          reject(error);
        } else {
          resolve(bytesRead);
        }
      });
    });
  }
  readSync(fd, buffer, offset, length, position) {
    return this.realFs.readSync(fd, buffer, offset, length, position);
  }
  async writePromise(fd, buffer, offset, length, position) {
    return await new Promise((resolve, reject) => {
      if (typeof buffer === `string`) {
        return this.realFs.write(fd, buffer, offset, this.makeCallback(resolve, reject));
      } else {
        return this.realFs.write(fd, buffer, offset, length, position, this.makeCallback(resolve, reject));
      }
    });
  }
  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.realFs.writeSync(fd, buffer, offset);
    } else {
      return this.realFs.writeSync(fd, buffer, offset, length, position);
    }
  }
  async closePromise(fd) {
    await new Promise((resolve, reject) => {
      this.realFs.close(fd, this.makeCallback(resolve, reject));
    });
  }
  closeSync(fd) {
    this.realFs.closeSync(fd);
  }
  createReadStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createReadStream(realPath, opts);
  }
  createWriteStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createWriteStream(realPath, opts);
  }
  async realpathPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.realpath(npath.fromPortablePath(p), {}, this.makeCallback(resolve, reject));
    }).then((path) => {
      return npath.toPortablePath(path);
    });
  }
  realpathSync(p) {
    return npath.toPortablePath(this.realFs.realpathSync(npath.fromPortablePath(p), {}));
  }
  async existsPromise(p) {
    return await new Promise((resolve) => {
      this.realFs.exists(npath.fromPortablePath(p), resolve);
    });
  }
  accessSync(p, mode) {
    return this.realFs.accessSync(npath.fromPortablePath(p), mode);
  }
  async accessPromise(p, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.access(npath.fromPortablePath(p), mode, this.makeCallback(resolve, reject));
    });
  }
  existsSync(p) {
    return this.realFs.existsSync(npath.fromPortablePath(p));
  }
  async statPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.stat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.stat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  statSync(p, opts) {
    if (opts) {
      return this.realFs.statSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.statSync(npath.fromPortablePath(p));
    }
  }
  async fstatPromise(fd, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.fstat(fd, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.fstat(fd, this.makeCallback(resolve, reject));
      }
    });
  }
  fstatSync(fd, opts) {
    if (opts) {
      return this.realFs.fstatSync(fd, opts);
    } else {
      return this.realFs.fstatSync(fd);
    }
  }
  async lstatPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.lstat(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.lstat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  lstatSync(p, opts) {
    if (opts) {
      return this.realFs.lstatSync(npath.fromPortablePath(p), opts);
    } else {
      return this.realFs.lstatSync(npath.fromPortablePath(p));
    }
  }
  async chmodPromise(p, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.chmod(npath.fromPortablePath(p), mask, this.makeCallback(resolve, reject));
    });
  }
  chmodSync(p, mask) {
    return this.realFs.chmodSync(npath.fromPortablePath(p), mask);
  }
  async chownPromise(p, uid, gid) {
    return await new Promise((resolve, reject) => {
      this.realFs.chown(npath.fromPortablePath(p), uid, gid, this.makeCallback(resolve, reject));
    });
  }
  chownSync(p, uid, gid) {
    return this.realFs.chownSync(npath.fromPortablePath(p), uid, gid);
  }
  async renamePromise(oldP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.rename(npath.fromPortablePath(oldP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }
  renameSync(oldP, newP) {
    return this.realFs.renameSync(npath.fromPortablePath(oldP), npath.fromPortablePath(newP));
  }
  async copyFilePromise(sourceP, destP, flags = 0) {
    return await new Promise((resolve, reject) => {
      this.realFs.copyFile(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags, this.makeCallback(resolve, reject));
    });
  }
  copyFileSync(sourceP, destP, flags = 0) {
    return this.realFs.copyFileSync(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags);
  }
  async appendFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      if (opts) {
        this.realFs.appendFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.appendFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }
  appendFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    if (opts) {
      this.realFs.appendFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.appendFileSync(fsNativePath, content);
    }
  }
  async writeFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      if (opts) {
        this.realFs.writeFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.writeFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }
  writeFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    if (opts) {
      this.realFs.writeFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.writeFileSync(fsNativePath, content);
    }
  }
  async unlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.unlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }
  unlinkSync(p) {
    return this.realFs.unlinkSync(npath.fromPortablePath(p));
  }
  async utimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.utimes(npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }
  utimesSync(p, atime, mtime) {
    this.realFs.utimesSync(npath.fromPortablePath(p), atime, mtime);
  }
  async lutimesPromiseImpl(p, atime, mtime) {
    const lutimes = this.realFs.lutimes;
    if (typeof lutimes === `undefined`)
      throw ENOSYS(`unavailable Node binding`, `lutimes '${p}'`);
    return await new Promise((resolve, reject) => {
      lutimes.call(this.realFs, npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }
  lutimesSyncImpl(p, atime, mtime) {
    const lutimesSync = this.realFs.lutimesSync;
    if (typeof lutimesSync === `undefined`)
      throw ENOSYS(`unavailable Node binding`, `lutimes '${p}'`);
    lutimesSync.call(this.realFs, npath.fromPortablePath(p), atime, mtime);
  }
  async mkdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      this.realFs.mkdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
    });
  }
  mkdirSync(p, opts) {
    return this.realFs.mkdirSync(npath.fromPortablePath(p), opts);
  }
  async rmdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts) {
        this.realFs.rmdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.rmdir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
      }
    });
  }
  rmdirSync(p, opts) {
    return this.realFs.rmdirSync(npath.fromPortablePath(p), opts);
  }
  async linkPromise(existingP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.link(npath.fromPortablePath(existingP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }
  linkSync(existingP, newP) {
    return this.realFs.linkSync(npath.fromPortablePath(existingP), npath.fromPortablePath(newP));
  }
  async symlinkPromise(target, p, type) {
    return await new Promise((resolve, reject) => {
      this.realFs.symlink(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type, this.makeCallback(resolve, reject));
    });
  }
  symlinkSync(target, p, type) {
    return this.realFs.symlinkSync(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type);
  }
  async readFilePromise(p, encoding) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      this.realFs.readFile(fsNativePath, encoding, this.makeCallback(resolve, reject));
    });
  }
  readFileSync(p, encoding) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    return this.realFs.readFileSync(fsNativePath, encoding);
  }
  async readdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      if (opts == null ? void 0 : opts.withFileTypes) {
        this.realFs.readdir(npath.fromPortablePath(p), {withFileTypes: true}, this.makeCallback(resolve, reject));
      } else {
        this.realFs.readdir(npath.fromPortablePath(p), this.makeCallback((value) => resolve(value), reject));
      }
    });
  }
  readdirSync(p, opts) {
    if (opts == null ? void 0 : opts.withFileTypes) {
      return this.realFs.readdirSync(npath.fromPortablePath(p), {withFileTypes: true});
    } else {
      return this.realFs.readdirSync(npath.fromPortablePath(p));
    }
  }
  async readlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.readlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    }).then((path) => {
      return npath.toPortablePath(path);
    });
  }
  readlinkSync(p) {
    return npath.toPortablePath(this.realFs.readlinkSync(npath.fromPortablePath(p)));
  }
  async truncatePromise(p, len) {
    return await new Promise((resolve, reject) => {
      this.realFs.truncate(npath.fromPortablePath(p), len, this.makeCallback(resolve, reject));
    });
  }
  truncateSync(p, len) {
    return this.realFs.truncateSync(npath.fromPortablePath(p), len);
  }
  watch(p, a, b) {
    return this.realFs.watch(npath.fromPortablePath(p), a, b);
  }
  watchFile(p, a, b) {
    return this.realFs.watchFile(npath.fromPortablePath(p), a, b);
  }
  unwatchFile(p, cb) {
    return this.realFs.unwatchFile(npath.fromPortablePath(p), cb);
  }
  makeCallback(resolve, reject) {
    return (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    };
  }
}

class ProxiedFS extends FakeFS {
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }
  resolve(path) {
    return this.mapFromBase(this.baseFs.resolve(this.mapToBase(path)));
  }
  getRealPath() {
    return this.mapFromBase(this.baseFs.getRealPath());
  }
  async openPromise(p, flags, mode) {
    return this.baseFs.openPromise(this.mapToBase(p), flags, mode);
  }
  openSync(p, flags, mode) {
    return this.baseFs.openSync(this.mapToBase(p), flags, mode);
  }
  async opendirPromise(p, opts) {
    return Object.assign(await this.baseFs.opendirPromise(this.mapToBase(p), opts), {path: p});
  }
  opendirSync(p, opts) {
    return Object.assign(this.baseFs.opendirSync(this.mapToBase(p), opts), {path: p});
  }
  async readPromise(fd, buffer, offset, length, position) {
    return await this.baseFs.readPromise(fd, buffer, offset, length, position);
  }
  readSync(fd, buffer, offset, length, position) {
    return this.baseFs.readSync(fd, buffer, offset, length, position);
  }
  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return await this.baseFs.writePromise(fd, buffer, offset);
    } else {
      return await this.baseFs.writePromise(fd, buffer, offset, length, position);
    }
  }
  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.baseFs.writeSync(fd, buffer, offset);
    } else {
      return this.baseFs.writeSync(fd, buffer, offset, length, position);
    }
  }
  async closePromise(fd) {
    return this.baseFs.closePromise(fd);
  }
  closeSync(fd) {
    this.baseFs.closeSync(fd);
  }
  createReadStream(p, opts) {
    return this.baseFs.createReadStream(p !== null ? this.mapToBase(p) : p, opts);
  }
  createWriteStream(p, opts) {
    return this.baseFs.createWriteStream(p !== null ? this.mapToBase(p) : p, opts);
  }
  async realpathPromise(p) {
    return this.mapFromBase(await this.baseFs.realpathPromise(this.mapToBase(p)));
  }
  realpathSync(p) {
    return this.mapFromBase(this.baseFs.realpathSync(this.mapToBase(p)));
  }
  async existsPromise(p) {
    return this.baseFs.existsPromise(this.mapToBase(p));
  }
  existsSync(p) {
    return this.baseFs.existsSync(this.mapToBase(p));
  }
  accessSync(p, mode) {
    return this.baseFs.accessSync(this.mapToBase(p), mode);
  }
  async accessPromise(p, mode) {
    return this.baseFs.accessPromise(this.mapToBase(p), mode);
  }
  async statPromise(p, opts) {
    return this.baseFs.statPromise(this.mapToBase(p), opts);
  }
  statSync(p, opts) {
    return this.baseFs.statSync(this.mapToBase(p), opts);
  }
  async fstatPromise(fd, opts) {
    return this.baseFs.fstatPromise(fd, opts);
  }
  fstatSync(fd, opts) {
    return this.baseFs.fstatSync(fd, opts);
  }
  async lstatPromise(p, opts) {
    return this.baseFs.lstatPromise(this.mapToBase(p), opts);
  }
  lstatSync(p, opts) {
    return this.baseFs.lstatSync(this.mapToBase(p), opts);
  }
  async chmodPromise(p, mask) {
    return this.baseFs.chmodPromise(this.mapToBase(p), mask);
  }
  chmodSync(p, mask) {
    return this.baseFs.chmodSync(this.mapToBase(p), mask);
  }
  async chownPromise(p, uid, gid) {
    return this.baseFs.chownPromise(this.mapToBase(p), uid, gid);
  }
  chownSync(p, uid, gid) {
    return this.baseFs.chownSync(this.mapToBase(p), uid, gid);
  }
  async renamePromise(oldP, newP) {
    return this.baseFs.renamePromise(this.mapToBase(oldP), this.mapToBase(newP));
  }
  renameSync(oldP, newP) {
    return this.baseFs.renameSync(this.mapToBase(oldP), this.mapToBase(newP));
  }
  async copyFilePromise(sourceP, destP, flags = 0) {
    return this.baseFs.copyFilePromise(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }
  copyFileSync(sourceP, destP, flags = 0) {
    return this.baseFs.copyFileSync(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }
  async appendFilePromise(p, content, opts) {
    return this.baseFs.appendFilePromise(this.fsMapToBase(p), content, opts);
  }
  appendFileSync(p, content, opts) {
    return this.baseFs.appendFileSync(this.fsMapToBase(p), content, opts);
  }
  async writeFilePromise(p, content, opts) {
    return this.baseFs.writeFilePromise(this.fsMapToBase(p), content, opts);
  }
  writeFileSync(p, content, opts) {
    return this.baseFs.writeFileSync(this.fsMapToBase(p), content, opts);
  }
  async unlinkPromise(p) {
    return this.baseFs.unlinkPromise(this.mapToBase(p));
  }
  unlinkSync(p) {
    return this.baseFs.unlinkSync(this.mapToBase(p));
  }
  async utimesPromise(p, atime, mtime) {
    return this.baseFs.utimesPromise(this.mapToBase(p), atime, mtime);
  }
  utimesSync(p, atime, mtime) {
    return this.baseFs.utimesSync(this.mapToBase(p), atime, mtime);
  }
  async mkdirPromise(p, opts) {
    return this.baseFs.mkdirPromise(this.mapToBase(p), opts);
  }
  mkdirSync(p, opts) {
    return this.baseFs.mkdirSync(this.mapToBase(p), opts);
  }
  async rmdirPromise(p, opts) {
    return this.baseFs.rmdirPromise(this.mapToBase(p), opts);
  }
  rmdirSync(p, opts) {
    return this.baseFs.rmdirSync(this.mapToBase(p), opts);
  }
  async linkPromise(existingP, newP) {
    return this.baseFs.linkPromise(this.mapToBase(existingP), this.mapToBase(newP));
  }
  linkSync(existingP, newP) {
    return this.baseFs.linkSync(this.mapToBase(existingP), this.mapToBase(newP));
  }
  async symlinkPromise(target, p, type) {
    const mappedP = this.mapToBase(p);
    if (this.pathUtils.isAbsolute(target))
      return this.baseFs.symlinkPromise(this.mapToBase(target), mappedP, type);
    const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
    const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
    return this.baseFs.symlinkPromise(mappedTarget, mappedP, type);
  }
  symlinkSync(target, p, type) {
    const mappedP = this.mapToBase(p);
    if (this.pathUtils.isAbsolute(target))
      return this.baseFs.symlinkSync(this.mapToBase(target), mappedP, type);
    const mappedAbsoluteTarget = this.mapToBase(this.pathUtils.join(this.pathUtils.dirname(p), target));
    const mappedTarget = this.baseFs.pathUtils.relative(this.baseFs.pathUtils.dirname(mappedP), mappedAbsoluteTarget);
    return this.baseFs.symlinkSync(mappedTarget, mappedP, type);
  }
  async readFilePromise(p, encoding) {
    if (encoding === `utf8`) {
      return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
    } else {
      return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
    }
  }
  readFileSync(p, encoding) {
    if (encoding === `utf8`) {
      return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
    } else {
      return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
    }
  }
  async readdirPromise(p, opts) {
    return this.baseFs.readdirPromise(this.mapToBase(p), opts);
  }
  readdirSync(p, opts) {
    return this.baseFs.readdirSync(this.mapToBase(p), opts);
  }
  async readlinkPromise(p) {
    return this.mapFromBase(await this.baseFs.readlinkPromise(this.mapToBase(p)));
  }
  readlinkSync(p) {
    return this.mapFromBase(this.baseFs.readlinkSync(this.mapToBase(p)));
  }
  async truncatePromise(p, len) {
    return this.baseFs.truncatePromise(this.mapToBase(p), len);
  }
  truncateSync(p, len) {
    return this.baseFs.truncateSync(this.mapToBase(p), len);
  }
  watch(p, a, b) {
    return this.baseFs.watch(this.mapToBase(p), a, b);
  }
  watchFile(p, a, b) {
    return this.baseFs.watchFile(this.mapToBase(p), a, b);
  }
  unwatchFile(p, cb) {
    return this.baseFs.unwatchFile(this.mapToBase(p), cb);
  }
  fsMapToBase(p) {
    if (typeof p === `number`) {
      return p;
    } else {
      return this.mapToBase(p);
    }
  }
}

const NUMBER_REGEXP = /^[0-9]+$/;
const VIRTUAL_REGEXP = /^(\/(?:[^/]+\/)*?(?:\$\$virtual|__virtual__))((?:\/((?:[^/]+-)?[a-f0-9]+)(?:\/([^/]+))?)?((?:\/.*)?))$/;
const VALID_COMPONENT = /^([^/]+-)?[a-f0-9]+$/;
class VirtualFS extends ProxiedFS {
  static makeVirtualPath(base, component, to) {
    if (ppath.basename(base) !== `__virtual__`)
      throw new Error(`Assertion failed: Virtual folders must be named "__virtual__"`);
    if (!ppath.basename(component).match(VALID_COMPONENT))
      throw new Error(`Assertion failed: Virtual components must be ended by an hexadecimal hash`);
    const target = ppath.relative(ppath.dirname(base), to);
    const segments = target.split(`/`);
    let depth = 0;
    while (depth < segments.length && segments[depth] === `..`)
      depth += 1;
    const finalSegments = segments.slice(depth);
    const fullVirtualPath = ppath.join(base, component, String(depth), ...finalSegments);
    return fullVirtualPath;
  }
  static resolveVirtual(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match || !match[3] && match[5])
      return p;
    const target = ppath.dirname(match[1]);
    if (!match[3] || !match[4])
      return target;
    const isnum = NUMBER_REGEXP.test(match[4]);
    if (!isnum)
      return p;
    const depth = Number(match[4]);
    const backstep = `../`.repeat(depth);
    const subpath = match[5] || `.`;
    return VirtualFS.resolveVirtual(ppath.join(target, backstep, subpath));
  }
  constructor({baseFs = new NodeFS()} = {}) {
    super(ppath);
    this.baseFs = baseFs;
  }
  getExtractHint(hints) {
    return this.baseFs.getExtractHint(hints);
  }
  getRealPath() {
    return this.baseFs.getRealPath();
  }
  realpathSync(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match)
      return this.baseFs.realpathSync(p);
    if (!match[5])
      return p;
    const realpath = this.baseFs.realpathSync(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }
  async realpathPromise(p) {
    const match = p.match(VIRTUAL_REGEXP);
    if (!match)
      return await this.baseFs.realpathPromise(p);
    if (!match[5])
      return p;
    const realpath = await this.baseFs.realpathPromise(this.mapToBase(p));
    return VirtualFS.makeVirtualPath(match[1], match[3], realpath);
  }
  mapToBase(p) {
    if (p === ``)
      return p;
    if (this.pathUtils.isAbsolute(p))
      return VirtualFS.resolveVirtual(p);
    const resolvedRoot = VirtualFS.resolveVirtual(this.baseFs.resolve(PortablePath.dot));
    const resolvedP = VirtualFS.resolveVirtual(this.baseFs.resolve(p));
    return ppath.relative(resolvedRoot, resolvedP) || PortablePath.dot;
  }
  mapFromBase(p) {
    return p;
  }
}

function hydrateRuntimeState(data, {basePath}) {
  const portablePath = npath.toPortablePath(basePath);
  const absolutePortablePath = ppath.resolve(portablePath);
  const ignorePattern = data.ignorePatternData !== null ? new RegExp(data.ignorePatternData) : null;
  const packageLocatorsByLocations = new Map();
  const packageRegistry = new Map(data.packageRegistryData.map(([packageName, packageStoreData]) => {
    return [packageName, new Map(packageStoreData.map(([packageReference, packageInformationData]) => {
      var _a;
      if (packageName === null !== (packageReference === null))
        throw new Error(`Assertion failed: The name and reference should be null, or neither should`);
      const discardFromLookup = (_a = packageInformationData.discardFromLookup) != null ? _a : false;
      const packageLocator = {name: packageName, reference: packageReference};
      const entry = packageLocatorsByLocations.get(packageInformationData.packageLocation);
      if (!entry) {
        packageLocatorsByLocations.set(packageInformationData.packageLocation, {locator: packageLocator, discardFromLookup});
      } else {
        entry.discardFromLookup = entry.discardFromLookup && discardFromLookup;
        if (!discardFromLookup) {
          entry.locator = packageLocator;
        }
      }
      let resolvedPackageLocation = null;
      return [packageReference, {
        packageDependencies: new Map(packageInformationData.packageDependencies),
        packagePeers: new Set(packageInformationData.packagePeers),
        linkType: packageInformationData.linkType,
        discardFromLookup,
        get packageLocation() {
          return resolvedPackageLocation || (resolvedPackageLocation = ppath.join(absolutePortablePath, packageInformationData.packageLocation));
        }
      }];
    }))];
  }));
  const fallbackExclusionList = new Map(data.fallbackExclusionList.map(([packageName, packageReferences]) => {
    return [packageName, new Set(packageReferences)];
  }));
  const fallbackPool = new Map(data.fallbackPool);
  const dependencyTreeRoots = data.dependencyTreeRoots;
  const enableTopLevelFallback = data.enableTopLevelFallback;
  return {
    basePath: portablePath,
    dependencyTreeRoots,
    enableTopLevelFallback,
    fallbackExclusionList,
    fallbackPool,
    ignorePattern,
    packageLocatorsByLocations,
    packageRegistry
  };
}

/**
 * @param {object} exports
 * @param {Set<string>} keys
 */
function loop(exports, keys) {
	if (typeof exports === 'string') {
		return exports;
	}

	if (exports) {
		let idx, tmp;
		if (Array.isArray(exports)) {
			for (idx=0; idx < exports.length; idx++) {
				if (tmp = loop(exports[idx], keys)) return tmp;
			}
		} else {
			for (idx in exports) {
				if (keys.has(idx)) {
					return loop(exports[idx], keys);
				}
			}
		}
	}
}

/**
 * @param {string} name The package name
 * @param {string} entry The target entry, eg "."
 * @param {number} [condition] Unmatched condition?
 */
function bail(name, entry, condition) {
	throw new Error(
		condition
		? `No known conditions for "${entry}" entry in "${name}" package`
		: `Missing "${entry}" export in "${name}" package`
	);
}

/**
 * @param {string} name the package name
 * @param {string} entry the target path/import
 */
function toName(name, entry) {
	return entry === name ? '.'
		: entry[0] === '.' ? entry
		: entry.replace(new RegExp('^' + name + '\/'), './');
}

/**
 * @param {object} pkg package.json contents
 * @param {string} [entry] entry name or import path
 * @param {object} [options]
 * @param {boolean} [options.browser]
 * @param {boolean} [options.require]
 * @param {string[]} [options.conditions]
 * @param {boolean} [options.unsafe]
 */
function resolve(pkg, entry='.', options={}) {
	let { name, exports } = pkg;

	if (exports) {
		let { browser, require, unsafe, conditions=[] } = options;

		let target = toName(name, entry);
		if (target[0] !== '.') target = './' + target;

		if (typeof exports === 'string') {
			return target === '.' ? exports : bail(name, target);
		}

		let allows = new Set(['default', ...conditions]);
		unsafe || allows.add(require ? 'require' : 'import');
		unsafe || allows.add(browser ? 'browser' : 'node');

		let key, tmp, isSingle=false;

		for (key in exports) {
			isSingle = key[0] !== '.';
			break;
		}

		if (isSingle) {
			return target === '.'
				? loop(exports, allows) || bail(name, target, 1)
				: bail(name, target);
		}

		if (tmp = exports[target]) {
			return loop(tmp, allows) || bail(name, target, 1);
		}

		for (key in exports) {
			tmp = key[key.length - 1];
			if (tmp === '/' && target.startsWith(key)) {
				return (tmp = loop(exports[key], allows))
					? (tmp + target.substring(key.length))
					: bail(name, target, 1);
			}
			if (tmp === '*' && target.startsWith(key.slice(0, -1))) {
				// do not trigger if no *content* to inject
				if (target.substring(key.length - 1).length > 0) {
					return (tmp = loop(exports[key], allows))
						? tmp.replace('*', target.substring(key.length - 1))
						: bail(name, target, 1);
				}
			}
		}

		return bail(name, target);
	}
}

var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["API_ERROR"] = `API_ERROR`;
  ErrorCode2["BUILTIN_NODE_RESOLUTION_FAILED"] = `BUILTIN_NODE_RESOLUTION_FAILED`;
  ErrorCode2["EXPORTS_RESOLUTION_FAILED"] = `EXPORTS_RESOLUTION_FAILED`;
  ErrorCode2["MISSING_DEPENDENCY"] = `MISSING_DEPENDENCY`;
  ErrorCode2["MISSING_PEER_DEPENDENCY"] = `MISSING_PEER_DEPENDENCY`;
  ErrorCode2["QUALIFIED_PATH_RESOLUTION_FAILED"] = `QUALIFIED_PATH_RESOLUTION_FAILED`;
  ErrorCode2["INTERNAL"] = `INTERNAL`;
  ErrorCode2["UNDECLARED_DEPENDENCY"] = `UNDECLARED_DEPENDENCY`;
  ErrorCode2["UNSUPPORTED"] = `UNSUPPORTED`;
})(ErrorCode || (ErrorCode = {}));
const MODULE_NOT_FOUND_ERRORS = new Set([
  ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED,
  ErrorCode.MISSING_DEPENDENCY,
  ErrorCode.MISSING_PEER_DEPENDENCY,
  ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED,
  ErrorCode.UNDECLARED_DEPENDENCY
]);
function makeError(pnpCode, message, data = {}, code) {
  code != null ? code : code = MODULE_NOT_FOUND_ERRORS.has(pnpCode) ? `MODULE_NOT_FOUND` : pnpCode;
  const propertySpec = {
    configurable: true,
    writable: true,
    enumerable: false
  };
  return Object.defineProperties(new Error(message), {
    code: __spreadProps$1(__spreadValues$1({}, propertySpec), {
      value: code
    }),
    pnpCode: __spreadProps$1(__spreadValues$1({}, propertySpec), {
      value: pnpCode
    }),
    data: __spreadProps$1(__spreadValues$1({}, propertySpec), {
      value: data
    })
  });
}
function getPathForDisplay(p) {
  return npath.normalize(npath.fromPortablePath(p));
}

const builtinModules = new Set(module$1.Module.builtinModules || Object.keys(process.binding(`natives`)));
const isBuiltinModule = (request) => request.startsWith(`node:`) || builtinModules.has(request);

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function makeApi(runtimeState, opts) {
  const alwaysWarnOnFallback = Number(process.env.PNP_ALWAYS_WARN_ON_FALLBACK) > 0;
  const debugLevel = Number(process.env.PNP_DEBUG_LEVEL);
  const pathRegExp = /^(?![a-zA-Z]:[\\/]|\\\\|\.{0,2}(?:\/|$))((?:node:)?(?:@[^/]+\/)?[^/]+)\/*(.*|)$/;
  const isStrictRegExp = /^(\/|\.{1,2}(\/|$))/;
  const isDirRegExp = /\/$/;
  const isRelativeRegexp = /^\.{0,2}\//;
  const topLevelLocator = {name: null, reference: null};
  const fallbackLocators = [];
  const emittedWarnings = new Set();
  if (runtimeState.enableTopLevelFallback === true)
    fallbackLocators.push(topLevelLocator);
  if (opts.compatibilityMode !== false) {
    for (const name of [`react-scripts`, `gatsby`]) {
      const packageStore = runtimeState.packageRegistry.get(name);
      if (packageStore) {
        for (const reference of packageStore.keys()) {
          if (reference === null) {
            throw new Error(`Assertion failed: This reference shouldn't be null`);
          } else {
            fallbackLocators.push({name, reference});
          }
        }
      }
    }
  }
  const {
    ignorePattern,
    packageRegistry,
    packageLocatorsByLocations
  } = runtimeState;
  function makeLogEntry(name, args) {
    return {
      fn: name,
      args,
      error: null,
      result: null
    };
  }
  function trace(entry) {
    var _a, _b, _c, _d, _e, _f;
    const colors = (_c = (_b = (_a = process.stderr) == null ? void 0 : _a.hasColors) == null ? void 0 : _b.call(_a)) != null ? _c : process.stdout.isTTY;
    const c = (n, str) => `[${n}m${str}[0m`;
    const error = entry.error;
    if (error)
      console.error(c(`31;1`, `\u2716 ${(_d = entry.error) == null ? void 0 : _d.message.replace(/\n.*/s, ``)}`));
    else
      console.error(c(`33;1`, `\u203C Resolution`));
    if (entry.args.length > 0)
      console.error();
    for (const arg of entry.args)
      console.error(`  ${c(`37;1`, `In \u2190`)} ${nodeUtils.inspect(arg, {colors, compact: true})}`);
    if (entry.result) {
      console.error();
      console.error(`  ${c(`37;1`, `Out \u2192`)} ${nodeUtils.inspect(entry.result, {colors, compact: true})}`);
    }
    const stack = (_f = (_e = new Error().stack.match(/(?<=^ +)at.*/gm)) == null ? void 0 : _e.slice(2)) != null ? _f : [];
    if (stack.length > 0) {
      console.error();
      for (const line of stack) {
        console.error(`  ${c(`38;5;244`, line)}`);
      }
    }
    console.error();
  }
  function maybeLog(name, fn) {
    if (opts.allowDebug === false)
      return fn;
    if (Number.isFinite(debugLevel)) {
      if (debugLevel >= 2) {
        return (...args) => {
          const logEntry = makeLogEntry(name, args);
          try {
            return logEntry.result = fn(...args);
          } catch (error) {
            throw logEntry.error = error;
          } finally {
            trace(logEntry);
          }
        };
      } else if (debugLevel >= 1) {
        return (...args) => {
          try {
            return fn(...args);
          } catch (error) {
            const logEntry = makeLogEntry(name, args);
            logEntry.error = error;
            trace(logEntry);
            throw error;
          }
        };
      }
    }
    return fn;
  }
  function getPackageInformationSafe(packageLocator) {
    const packageInformation = getPackageInformation(packageLocator);
    if (!packageInformation) {
      throw makeError(ErrorCode.INTERNAL, `Couldn't find a matching entry in the dependency tree for the specified parent (this is probably an internal error)`);
    }
    return packageInformation;
  }
  function isDependencyTreeRoot(packageLocator) {
    if (packageLocator.name === null)
      return true;
    for (const dependencyTreeRoot of runtimeState.dependencyTreeRoots)
      if (dependencyTreeRoot.name === packageLocator.name && dependencyTreeRoot.reference === packageLocator.reference)
        return true;
    return false;
  }
  const defaultExportsConditions = new Set([`default`, `node`, `require`]);
  function applyNodeExportsResolution(unqualifiedPath, conditions = defaultExportsConditions) {
    const locator = findPackageLocator(ppath.join(unqualifiedPath, `internal.js`), {
      resolveIgnored: true,
      includeDiscardFromLookup: true
    });
    if (locator === null) {
      throw makeError(ErrorCode.INTERNAL, `The locator that owns the "${unqualifiedPath}" path can't be found inside the dependency tree (this is probably an internal error)`);
    }
    const {packageLocation} = getPackageInformationSafe(locator);
    const manifestPath = ppath.join(packageLocation, Filename.manifest);
    if (!opts.fakeFs.existsSync(manifestPath))
      return null;
    const pkgJson = JSON.parse(opts.fakeFs.readFileSync(manifestPath, `utf8`));
    let subpath = ppath.contains(packageLocation, unqualifiedPath);
    if (subpath === null) {
      throw makeError(ErrorCode.INTERNAL, `unqualifiedPath doesn't contain the packageLocation (this is probably an internal error)`);
    }
    if (!isRelativeRegexp.test(subpath))
      subpath = `./${subpath}`;
    let resolvedExport;
    try {
      resolvedExport = resolve(pkgJson, ppath.normalize(subpath), {
        conditions,
        unsafe: true
      });
    } catch (error) {
      throw makeError(ErrorCode.EXPORTS_RESOLUTION_FAILED, error.message, {unqualifiedPath: getPathForDisplay(unqualifiedPath), locator, pkgJson, subpath: getPathForDisplay(subpath), conditions}, `ERR_PACKAGE_PATH_NOT_EXPORTED`);
    }
    if (typeof resolvedExport === `string`)
      return ppath.join(packageLocation, resolvedExport);
    return null;
  }
  function applyNodeExtensionResolution(unqualifiedPath, candidates, {extensions}) {
    let stat;
    try {
      candidates.push(unqualifiedPath);
      stat = opts.fakeFs.statSync(unqualifiedPath);
    } catch (error) {
    }
    if (stat && !stat.isDirectory())
      return opts.fakeFs.realpathSync(unqualifiedPath);
    if (stat && stat.isDirectory()) {
      let pkgJson;
      try {
        pkgJson = JSON.parse(opts.fakeFs.readFileSync(ppath.join(unqualifiedPath, Filename.manifest), `utf8`));
      } catch (error) {
      }
      let nextUnqualifiedPath;
      if (pkgJson && pkgJson.main)
        nextUnqualifiedPath = ppath.resolve(unqualifiedPath, pkgJson.main);
      if (nextUnqualifiedPath && nextUnqualifiedPath !== unqualifiedPath) {
        const resolution = applyNodeExtensionResolution(nextUnqualifiedPath, candidates, {extensions});
        if (resolution !== null) {
          return resolution;
        }
      }
    }
    for (let i = 0, length = extensions.length; i < length; i++) {
      const candidateFile = `${unqualifiedPath}${extensions[i]}`;
      candidates.push(candidateFile);
      if (opts.fakeFs.existsSync(candidateFile)) {
        return candidateFile;
      }
    }
    if (stat && stat.isDirectory()) {
      for (let i = 0, length = extensions.length; i < length; i++) {
        const candidateFile = ppath.format({dir: unqualifiedPath, name: `index`, ext: extensions[i]});
        candidates.push(candidateFile);
        if (opts.fakeFs.existsSync(candidateFile)) {
          return candidateFile;
        }
      }
    }
    return null;
  }
  function makeFakeModule(path) {
    const fakeModule = new module$1.Module(path, null);
    fakeModule.filename = path;
    fakeModule.paths = module$1.Module._nodeModulePaths(path);
    return fakeModule;
  }
  function callNativeResolution(request, issuer) {
    if (issuer.endsWith(`/`))
      issuer = ppath.join(issuer, `internal.js`);
    return module$1.Module._resolveFilename(npath.fromPortablePath(request), makeFakeModule(npath.fromPortablePath(issuer)), false, {plugnplay: false});
  }
  function isPathIgnored(path) {
    if (ignorePattern === null)
      return false;
    const subPath = ppath.contains(runtimeState.basePath, path);
    if (subPath === null)
      return false;
    if (ignorePattern.test(subPath.replace(/\/$/, ``))) {
      return true;
    } else {
      return false;
    }
  }
  const VERSIONS = {std: 3, resolveVirtual: 1, getAllLocators: 1};
  const topLevel = topLevelLocator;
  function getPackageInformation({name, reference}) {
    const packageInformationStore = packageRegistry.get(name);
    if (!packageInformationStore)
      return null;
    const packageInformation = packageInformationStore.get(reference);
    if (!packageInformation)
      return null;
    return packageInformation;
  }
  function findPackageDependents({name, reference}) {
    const dependents = [];
    for (const [dependentName, packageInformationStore] of packageRegistry) {
      if (dependentName === null)
        continue;
      for (const [dependentReference, packageInformation] of packageInformationStore) {
        if (dependentReference === null)
          continue;
        const dependencyReference = packageInformation.packageDependencies.get(name);
        if (dependencyReference !== reference)
          continue;
        if (dependentName === name && dependentReference === reference)
          continue;
        dependents.push({
          name: dependentName,
          reference: dependentReference
        });
      }
    }
    return dependents;
  }
  function findBrokenPeerDependencies(dependency, initialPackage) {
    const brokenPackages = new Map();
    const alreadyVisited = new Set();
    const traversal = (currentPackage) => {
      const identifier = JSON.stringify(currentPackage.name);
      if (alreadyVisited.has(identifier))
        return;
      alreadyVisited.add(identifier);
      const dependents = findPackageDependents(currentPackage);
      for (const dependent of dependents) {
        const dependentInformation = getPackageInformationSafe(dependent);
        if (dependentInformation.packagePeers.has(dependency)) {
          traversal(dependent);
        } else {
          let brokenSet = brokenPackages.get(dependent.name);
          if (typeof brokenSet === `undefined`)
            brokenPackages.set(dependent.name, brokenSet = new Set());
          brokenSet.add(dependent.reference);
        }
      }
    };
    traversal(initialPackage);
    const brokenList = [];
    for (const name of [...brokenPackages.keys()].sort())
      for (const reference of [...brokenPackages.get(name)].sort())
        brokenList.push({name, reference});
    return brokenList;
  }
  function findPackageLocator(location, {resolveIgnored = false, includeDiscardFromLookup = false} = {}) {
    if (isPathIgnored(location) && !resolveIgnored)
      return null;
    let relativeLocation = ppath.relative(runtimeState.basePath, location);
    if (!relativeLocation.match(isStrictRegExp))
      relativeLocation = `./${relativeLocation}`;
    if (!relativeLocation.endsWith(`/`))
      relativeLocation = `${relativeLocation}/`;
    do {
      const entry = packageLocatorsByLocations.get(relativeLocation);
      if (typeof entry === `undefined` || entry.discardFromLookup && !includeDiscardFromLookup) {
        relativeLocation = relativeLocation.substring(0, relativeLocation.lastIndexOf(`/`, relativeLocation.length - 2) + 1);
        continue;
      }
      return entry.locator;
    } while (relativeLocation !== ``);
    return null;
  }
  function resolveToUnqualified(request, issuer, {considerBuiltins = true} = {}) {
    if (request === `pnpapi`)
      return npath.toPortablePath(opts.pnpapiResolution);
    if (considerBuiltins && isBuiltinModule(request))
      return null;
    const requestForDisplay = getPathForDisplay(request);
    const issuerForDisplay = issuer && getPathForDisplay(issuer);
    if (issuer && isPathIgnored(issuer)) {
      if (!ppath.isAbsolute(request) || findPackageLocator(request) === null) {
        const result = callNativeResolution(request, issuer);
        if (result === false) {
          throw makeError(ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED, `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer was explicitely ignored by the regexp)

Require request: "${requestForDisplay}"
Required by: ${issuerForDisplay}
`, {request: requestForDisplay, issuer: issuerForDisplay});
        }
        return npath.toPortablePath(result);
      }
    }
    let unqualifiedPath;
    const dependencyNameMatch = request.match(pathRegExp);
    if (!dependencyNameMatch) {
      if (ppath.isAbsolute(request)) {
        unqualifiedPath = ppath.normalize(request);
      } else {
        if (!issuer) {
          throw makeError(ErrorCode.API_ERROR, `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`, {request: requestForDisplay, issuer: issuerForDisplay});
        }
        const absoluteIssuer = ppath.resolve(issuer);
        if (issuer.match(isDirRegExp)) {
          unqualifiedPath = ppath.normalize(ppath.join(absoluteIssuer, request));
        } else {
          unqualifiedPath = ppath.normalize(ppath.join(ppath.dirname(absoluteIssuer), request));
        }
      }
    } else {
      if (!issuer) {
        throw makeError(ErrorCode.API_ERROR, `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`, {request: requestForDisplay, issuer: issuerForDisplay});
      }
      const [, dependencyName, subPath] = dependencyNameMatch;
      const issuerLocator = findPackageLocator(issuer);
      if (!issuerLocator) {
        const result = callNativeResolution(request, issuer);
        if (result === false) {
          throw makeError(ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED, `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer doesn't seem to be part of the Yarn-managed dependency tree).

Require path: "${requestForDisplay}"
Required by: ${issuerForDisplay}
`, {request: requestForDisplay, issuer: issuerForDisplay});
        }
        return npath.toPortablePath(result);
      }
      const issuerInformation = getPackageInformationSafe(issuerLocator);
      let dependencyReference = issuerInformation.packageDependencies.get(dependencyName);
      let fallbackReference = null;
      if (dependencyReference == null) {
        if (issuerLocator.name !== null) {
          const exclusionEntry = runtimeState.fallbackExclusionList.get(issuerLocator.name);
          const canUseFallbacks = !exclusionEntry || !exclusionEntry.has(issuerLocator.reference);
          if (canUseFallbacks) {
            for (let t = 0, T = fallbackLocators.length; t < T; ++t) {
              const fallbackInformation = getPackageInformationSafe(fallbackLocators[t]);
              const reference = fallbackInformation.packageDependencies.get(dependencyName);
              if (reference == null)
                continue;
              if (alwaysWarnOnFallback)
                fallbackReference = reference;
              else
                dependencyReference = reference;
              break;
            }
            if (runtimeState.enableTopLevelFallback) {
              if (dependencyReference == null && fallbackReference === null) {
                const reference = runtimeState.fallbackPool.get(dependencyName);
                if (reference != null) {
                  fallbackReference = reference;
                }
              }
            }
          }
        }
      }
      let error = null;
      if (dependencyReference === null) {
        if (isDependencyTreeRoot(issuerLocator)) {
          error = makeError(ErrorCode.MISSING_PEER_DEPENDENCY, `Your application tried to access ${dependencyName} (a peer dependency); this isn't allowed as there is no ancestor to satisfy the requirement. Use a devDependency if needed.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`, {request: requestForDisplay, issuer: issuerForDisplay, dependencyName});
        } else {
          const brokenAncestors = findBrokenPeerDependencies(dependencyName, issuerLocator);
          if (brokenAncestors.every((ancestor) => isDependencyTreeRoot(ancestor))) {
            error = makeError(ErrorCode.MISSING_PEER_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by your application; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
${brokenAncestors.map((ancestorLocator) => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}
`).join(``)}
`, {request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName, brokenAncestors});
          } else {
            error = makeError(ErrorCode.MISSING_PEER_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName} (a peer dependency) but it isn't provided by its ancestors; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})

${brokenAncestors.map((ancestorLocator) => `Ancestor breaking the chain: ${ancestorLocator.name}@${ancestorLocator.reference}
`).join(``)}
`, {request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName, brokenAncestors});
          }
        }
      } else if (dependencyReference === void 0) {
        if (!considerBuiltins && isBuiltinModule(request)) {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = makeError(ErrorCode.UNDECLARED_DEPENDENCY, `Your application tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in your dependencies, this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`, {request: requestForDisplay, issuer: issuerForDisplay, dependencyName});
          } else {
            error = makeError(ErrorCode.UNDECLARED_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName}. While this module is usually interpreted as a Node builtin, your resolver is running inside a non-Node resolution context where such builtins are ignored. Since ${dependencyName} isn't otherwise declared in ${issuerLocator.name}'s dependencies, this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`, {request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName});
          }
        } else {
          if (isDependencyTreeRoot(issuerLocator)) {
            error = makeError(ErrorCode.UNDECLARED_DEPENDENCY, `Your application tried to access ${dependencyName}, but it isn't declared in your dependencies; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerForDisplay}
`, {request: requestForDisplay, issuer: issuerForDisplay, dependencyName});
          } else {
            error = makeError(ErrorCode.UNDECLARED_DEPENDENCY, `${issuerLocator.name} tried to access ${dependencyName}, but it isn't declared in its dependencies; this makes the require call ambiguous and unsound.

Required package: ${dependencyName}${dependencyName !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
`, {request: requestForDisplay, issuer: issuerForDisplay, issuerLocator: Object.assign({}, issuerLocator), dependencyName});
          }
        }
      }
      if (dependencyReference == null) {
        if (fallbackReference === null || error === null)
          throw error || new Error(`Assertion failed: Expected an error to have been set`);
        dependencyReference = fallbackReference;
        const message = error.message.replace(/\n.*/g, ``);
        error.message = message;
        if (!emittedWarnings.has(message) && debugLevel !== 0) {
          emittedWarnings.add(message);
          process.emitWarning(error);
        }
      }
      const dependencyLocator = Array.isArray(dependencyReference) ? {name: dependencyReference[0], reference: dependencyReference[1]} : {name: dependencyName, reference: dependencyReference};
      const dependencyInformation = getPackageInformationSafe(dependencyLocator);
      if (!dependencyInformation.packageLocation) {
        throw makeError(ErrorCode.MISSING_DEPENDENCY, `A dependency seems valid but didn't get installed for some reason. This might be caused by a partial install, such as dev vs prod.

Required package: ${dependencyLocator.name}@${dependencyLocator.reference}${dependencyLocator.name !== requestForDisplay ? ` (via "${requestForDisplay}")` : ``}
Required by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuerForDisplay})
`, {request: requestForDisplay, issuer: issuerForDisplay, dependencyLocator: Object.assign({}, dependencyLocator)});
      }
      const dependencyLocation = dependencyInformation.packageLocation;
      if (subPath) {
        unqualifiedPath = ppath.join(dependencyLocation, subPath);
      } else {
        unqualifiedPath = dependencyLocation;
      }
    }
    return ppath.normalize(unqualifiedPath);
  }
  function resolveUnqualifiedExport(request, unqualifiedPath, conditions = defaultExportsConditions) {
    if (isStrictRegExp.test(request))
      return unqualifiedPath;
    const unqualifiedExportPath = applyNodeExportsResolution(unqualifiedPath, conditions);
    if (unqualifiedExportPath) {
      return ppath.normalize(unqualifiedExportPath);
    } else {
      return unqualifiedPath;
    }
  }
  function resolveUnqualified(unqualifiedPath, {extensions = Object.keys(module$1.Module._extensions)} = {}) {
    var _a, _b;
    const candidates = [];
    const qualifiedPath = applyNodeExtensionResolution(unqualifiedPath, candidates, {extensions});
    if (qualifiedPath) {
      return ppath.normalize(qualifiedPath);
    } else {
      const unqualifiedPathForDisplay = getPathForDisplay(unqualifiedPath);
      const containingPackage = findPackageLocator(unqualifiedPath);
      if (containingPackage) {
        const {packageLocation} = getPackageInformationSafe(containingPackage);
        let exists = true;
        try {
          opts.fakeFs.accessSync(packageLocation);
        } catch (err) {
          if ((err == null ? void 0 : err.code) === `ENOENT`) {
            exists = false;
          } else {
            const readableError = ((_b = (_a = err == null ? void 0 : err.message) != null ? _a : err) != null ? _b : `empty exception thrown`).replace(/^[A-Z]/, ($0) => $0.toLowerCase());
            throw makeError(ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, `Required package exists but could not be accessed (${readableError}).

Missing package: ${containingPackage.name}@${containingPackage.reference}
Expected package location: ${getPathForDisplay(packageLocation)}
`, {unqualifiedPath: unqualifiedPathForDisplay, extensions});
          }
        }
        if (!exists) {
          const errorMessage = packageLocation.includes(`/unplugged/`) ? `Required unplugged package missing from disk. This may happen when switching branches without running installs (unplugged packages must be fully materialized on disk to work).` : `Required package missing from disk. If you keep your packages inside your repository then restarting the Node process may be enough. Otherwise, try to run an install first.`;
          throw makeError(ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, `${errorMessage}

Missing package: ${containingPackage.name}@${containingPackage.reference}
Expected package location: ${getPathForDisplay(packageLocation)}
`, {unqualifiedPath: unqualifiedPathForDisplay, extensions});
        }
      }
      throw makeError(ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, `Qualified path resolution failed: we looked for the following paths, but none could be accessed.

Source path: ${unqualifiedPathForDisplay}
${candidates.map((candidate) => `Not found: ${getPathForDisplay(candidate)}
`).join(``)}`, {unqualifiedPath: unqualifiedPathForDisplay, extensions});
    }
  }
  function resolveRequest(request, issuer, {considerBuiltins, extensions, conditions} = {}) {
    try {
      const unqualifiedPath = resolveToUnqualified(request, issuer, {considerBuiltins});
      if (request === `pnpapi`)
        return unqualifiedPath;
      if (unqualifiedPath === null)
        return null;
      const isIssuerIgnored = () => issuer !== null ? isPathIgnored(issuer) : false;
      const remappedPath = (!considerBuiltins || !isBuiltinModule(request)) && !isIssuerIgnored() ? resolveUnqualifiedExport(request, unqualifiedPath, conditions) : unqualifiedPath;
      return resolveUnqualified(remappedPath, {extensions});
    } catch (error) {
      if (Object.prototype.hasOwnProperty.call(error, `pnpCode`))
        Object.assign(error.data, {request: getPathForDisplay(request), issuer: issuer && getPathForDisplay(issuer)});
      throw error;
    }
  }
  function resolveVirtual(request) {
    const normalized = ppath.normalize(request);
    const resolved = VirtualFS.resolveVirtual(normalized);
    return resolved !== normalized ? resolved : null;
  }
  return {
    VERSIONS,
    topLevel,
    getLocator: (name, referencish) => {
      if (Array.isArray(referencish)) {
        return {name: referencish[0], reference: referencish[1]};
      } else {
        return {name, reference: referencish};
      }
    },
    getDependencyTreeRoots: () => {
      return [...runtimeState.dependencyTreeRoots];
    },
    getAllLocators() {
      const locators = [];
      for (const [name, entry] of packageRegistry)
        for (const reference of entry.keys())
          if (name !== null && reference !== null)
            locators.push({name, reference});
      return locators;
    },
    getPackageInformation: (locator) => {
      const info = getPackageInformation(locator);
      if (info === null)
        return null;
      const packageLocation = npath.fromPortablePath(info.packageLocation);
      const nativeInfo = __spreadProps(__spreadValues({}, info), {packageLocation});
      return nativeInfo;
    },
    findPackageLocator: (path) => {
      return findPackageLocator(npath.toPortablePath(path));
    },
    resolveToUnqualified: maybeLog(`resolveToUnqualified`, (request, issuer, opts2) => {
      const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
      const resolution = resolveToUnqualified(npath.toPortablePath(request), portableIssuer, opts2);
      if (resolution === null)
        return null;
      return npath.fromPortablePath(resolution);
    }),
    resolveUnqualified: maybeLog(`resolveUnqualified`, (unqualifiedPath, opts2) => {
      return npath.fromPortablePath(resolveUnqualified(npath.toPortablePath(unqualifiedPath), opts2));
    }),
    resolveRequest: maybeLog(`resolveRequest`, (request, issuer, opts2) => {
      const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
      const resolution = resolveRequest(npath.toPortablePath(request), portableIssuer, opts2);
      if (resolution === null)
        return null;
      return npath.fromPortablePath(resolution);
    }),
    resolveVirtual: maybeLog(`resolveVirtual`, (path) => {
      const result = resolveVirtual(npath.toPortablePath(path));
      if (result !== null) {
        return npath.fromPortablePath(result);
      } else {
        return null;
      }
    })
  };
}

const readFileP = nodeUtils.promisify(fs.readFile);
async function hydratePnpFile(location, {fakeFs, pnpapiResolution}) {
  const source = await readFileP(location, `utf8`);
  return hydratePnpSource(source, {
    basePath: path.dirname(location),
    fakeFs,
    pnpapiResolution
  });
}
function hydratePnpSource(source, {basePath, fakeFs, pnpapiResolution}) {
  const data = JSON.parse(source);
  const runtimeState = hydrateRuntimeState(data, {
    basePath
  });
  return makeApi(runtimeState, {
    compatibilityMode: true,
    fakeFs,
    pnpapiResolution
  });
}

const makeRuntimeApi = (settings, basePath, fakeFs) => {
  const data = generateSerializedState(settings);
  const state = hydrateRuntimeState(data, {basePath});
  const pnpapiResolution = npath.join(basePath, Filename.pnpCjs);
  return makeApi(state, {fakeFs, pnpapiResolution});
};

let hook;
var builtLoader = () => {
  if (typeof hook === `undefined`)
    hook = zlib__default.default.brotliDecompressSync(Buffer.from("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", "base64")).toString();
  return hook;
};

exports.generateInlinedScript = generateInlinedScript;
exports.generateLoader = generateLoader;
exports.generatePrettyJson = generatePrettyJson;
exports.generateSplitScript = generateSplitScript;
exports.getESMLoaderTemplate = builtLoader;
exports.hydratePnpFile = hydratePnpFile;
exports.hydratePnpSource = hydratePnpSource;
exports.makeRuntimeApi = makeRuntimeApi;
