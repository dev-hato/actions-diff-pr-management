{"version":3,"sources":["../src/sentence-length.ts"],"names":["removeRangeFromString","text","regExpStrings","patterns","map","pattern","result","forEach","replace","defaultOptions","max","skipPatterns","skipUrlStringLink","exclusionPatterns","reporter","context","options","maxLength","helper","RuleHelper","Syntax","RuleError","report","isUrlStringLink","node","type","Link","linkNode","nodeText","StringSource","toString","url","Paragraph","isChildNode","BlockQuote","isChildrenSingleLinkNode","children","length","paragraph","filter","sentence","SentenceSyntax","Sentence","filteredSentence","sentenceChildNode","source","actualText","sentenceText","actualTextLength","sentenceLength","startLine","loc","start","line"],"mappings":"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","sourcesContent":["import { splitAST, Syntax as SentenceSyntax } from \"sentence-splitter\";\nimport { StringSource } from \"textlint-util-to-string\";\nimport { RuleHelper } from \"textlint-rule-helper\";\nimport { createRegExp } from \"@textlint/regexp-string-matcher\";\nimport { TextlintRuleReporter } from \"@textlint/types\";\nimport { TxtNode, TxtParentNode } from \"@textlint/ast-node-types\";\n\nfunction removeRangeFromString(text: string, regExpStrings: string[]) {\n    const patterns = regExpStrings.map((pattern) => {\n        return createRegExp(pattern);\n    });\n    let result = text;\n    patterns.forEach((pattern) => {\n        result = result.replace(pattern, \"\");\n    });\n    return result;\n}\n\nexport type Options = {\n    max?: number;\n    /**\n     * The strings that match following patterns is un-count of the sentence\n     * See https://github.com/textlint/regexp-string-matcher\n     */\n    skipPatterns?: string[];\n    /**\n     * If it is true, skip the count of following link node.\n     *\n     * [https://example.com](https://example.com)\n     * <https://example.com>\n     *\n     * UrlStringLink is has the title which is same of href.\n     */\n    skipUrlStringLink?: boolean;\n    /**\n     * @deprecated use skipPatterns\n     */\n    exclusionPatterns?: string[];\n};\nconst defaultOptions: Required<Options> = {\n    max: 100,\n    skipPatterns: [],\n    skipUrlStringLink: true,\n    /**\n     * @deprecated\n     */\n    exclusionPatterns: []\n};\n\nconst reporter: TextlintRuleReporter<Options> = (context, options = {}) => {\n    const maxLength = options.max ?? defaultOptions.max;\n    const skipPatterns = options.skipPatterns ?? options.exclusionPatterns ?? defaultOptions.skipPatterns;\n    const skipUrlStringLink = options.skipUrlStringLink ?? defaultOptions.skipUrlStringLink;\n    const helper = new RuleHelper(context);\n    const { Syntax, RuleError, report } = context;\n    const isUrlStringLink = (node: TxtNode | TxtParentNode): boolean => {\n        if (node.type !== Syntax.Link) {\n            return false;\n        }\n        const linkNode = node as TxtParentNode;\n        const nodeText = new StringSource(linkNode).toString();\n        return node.url === nodeText;\n    };\n\n    // toPlainText\n    return {\n        [Syntax.Paragraph](node) {\n            if (helper.isChildNode(node, [Syntax.BlockQuote])) {\n                return;\n            }\n            // If a single Link node in the paragraph node, should be ignore the link length\n            const isChildrenSingleLinkNode = node.children.length === 1 && node.children[0].type === Syntax.Link;\n            if (isChildrenSingleLinkNode) {\n                return;\n            }\n            // empty break line == split sentence\n            const paragraph = splitAST(node);\n            paragraph.children\n                .filter((sentence) => sentence.type === SentenceSyntax.Sentence)\n                .forEach((sentence) => {\n                    const filteredSentence = skipUrlStringLink\n                        ? {\n                              ...sentence,\n                              children: sentence.children.filter((sentenceChildNode: TxtNode | TxtParentNode) => {\n                                  return !isUrlStringLink(sentenceChildNode);\n                              })\n                          }\n                        : sentence;\n                    // @ts-expect-error: wrong types\n                    const source = new StringSource(filteredSentence);\n                    const actualText = source.toString();\n                    const sentenceText = removeRangeFromString(actualText, skipPatterns);\n                    // larger than > 100\n                    const actualTextLength = actualText.length;\n                    const sentenceLength = sentenceText.length;\n                    if (sentenceLength > maxLength) {\n                        const startLine = filteredSentence.loc.start.line;\n                        report(\n                            filteredSentence,\n                            new RuleError(`Line ${startLine} sentence length(${\n                                sentenceLength !== actualTextLength\n                                    ? `${sentenceLength}, original:${actualTextLength}`\n                                    : sentenceLength\n                            }) exceeds the maximum sentence length of ${maxLength}.\nOver ${sentenceLength - maxLength} characters.`)\n                        );\n                    }\n                });\n        }\n    };\n};\nexport default reporter;\n"],"file":"sentence-length.js"}