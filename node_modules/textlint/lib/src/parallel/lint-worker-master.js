"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lintParallel = void 0;
const os_1 = __importDefault(require("os"));
const find_util_1 = require("../util/find-util");
const kernel_1 = require("@textlint/kernel");
const object_to_kernel_format_1 = require("../util/object-to-kernel-format");
const textlint_module_loader_1 = require("../engine/textlint-module-loader");
const processor_map_1 = require("../engine/processor-map");
const debug = require("debug")("textlint:parallel/lint-worker-master");
const workerPath = require.resolve("./lint-worker");
const getPluginObject = (config) => {
    const pluginMap = new processor_map_1.PluginMap();
    const moduleLoader = new textlint_module_loader_1.TextLintModuleLoader(config);
    moduleLoader.on(textlint_module_loader_1.TextLintModuleLoader.Event.plugin, ([pluginName, plugin]) => {
        pluginMap.set(pluginName, plugin);
    });
    // load plugin
    moduleLoader.loadFromConfig(config);
    return pluginMap.toJSON();
};
// TODO: Temporal config
const MAX_CHUNK_SIZE = 256;
const lintParallel = (files, options) => {
    // TODO: avoid error on Node.js 12<
    const Worker = require("worker_threads").Worker;
    const descriptor = new kernel_1.TextlintKernelDescriptor({
        rules: [],
        plugins: (0, object_to_kernel_format_1.pluginsObjectToKernelRule)(getPluginObject(options.config), options.config.pluginsConfig),
        filterRules: []
    });
    const patterns = (0, find_util_1.pathsToGlobPatterns)(files, {
        extensions: descriptor.availableExtensions
    });
    const targetFiles = (0, find_util_1.findFiles)(patterns, { ignoreFilePath: options.config.ignoreFile });
    const concurrency = options.concurrency !== undefined ? options.concurrency : os_1.default.cpus().length;
    const chunkSize = Math.min(MAX_CHUNK_SIZE, Math.ceil(targetFiles.length / concurrency));
    const promises = [];
    debug("Worker concurrency: %s, chunk size: %s, target files", concurrency, chunkSize, targetFiles.length);
    for (let i = 0; i < targetFiles.length; i += chunkSize) {
        promises.push(new Promise((resolve, reject) => {
            const workerData = {
                config: options.config,
                type: options.type,
                files: targetFiles.slice(i, i + chunkSize)
            };
            const worker = new Worker(workerPath, { workerData });
            const startDate = Date.now();
            worker.on("message", (results) => {
                debug("Worker(%s) taken time: %s(ms)", worker.threadId, Date.now() - startDate);
                resolve(results);
            });
            worker.on("error", reject);
            worker.on("exit", (exitCode) => {
                if (exitCode) {
                    reject(new Error(`Worker(${worker.threadId}) stopped with exit code ${exitCode}`));
                }
                else {
                    resolve(undefined); // it will be flatten
                }
            });
        }));
    }
    debug("Worker count: %s", promises.length);
    return Promise.all(promises).then((resultsInList) => {
        return resultsInList.flat();
    });
};
exports.lintParallel = lintParallel;
//# sourceMappingURL=lint-worker-master.js.map