// MIT Â© 2017 azu
"use strict";

var _CONTROL_CHARACTERS = require("./CONTROL_CHARACTERS");

var execall = require("execall");

/**
 * Convert char to \uXXXX
 * @param {string} str
 * @return {string}
 */
var unicodeEscape = str => {
  return str.replace(/./g, c => {
    return "\\u".concat("000".concat(c.charCodeAt(0).toString(16)).substr(-4));
  });
};

var getName = char => {
  var matchChar = _CONTROL_CHARACTERS.CONTROL_CHARACTERS.find(CONTROL_CHARACTER => CONTROL_CHARACTER.code === char);

  if (!matchChar) {
    return "";
  }

  return matchChar.name;
};

var DEFAULT_OPTION = {
  // Define allow char code like `\u0019`
  allow: [],
  // Check code if it is true
  checkCode: false,
  // Check image title and alt text if it is true
  checkImage: true
};

var reporter = function reporter(context) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var {
    Syntax,
    RuleError,
    getSource,
    fixer,
    report
  } = context;
  var allow = options.allow || DEFAULT_OPTION.allow;
  var checkCode = options.checkCode !== undefined ? options.checkCode : DEFAULT_OPTION.checkCode;
  var checkImage = options.checkImage !== undefined ? options.checkImage : DEFAULT_OPTION.checkImage;

  var checkNode = node => {
    var text = getSource(node); // Ignore \r \n \t

    var controlCharacterPattern = /([\x00-\x08\x0B\x0C\x0E-\x1F\x7F])/g;
    /**
     * @type {Array<{match:string, sub:string[], index:number}>}
     */

    var results = execall(controlCharacterPattern, text);
    results.forEach(result => {
      var index = result.index;
      var char = result.sub[0]; // if allow the `char`, ignore it

      if (allow.some(allowChar => allowChar === char)) {
        return;
      }

      var name = getName(char);
      var ruleError = new RuleError("Found invalid control character(".concat(name, " ").concat(unicodeEscape(char), ")"), {
        index: index,
        fix: fixer.removeRange([index, index + 1])
      });
      report(node, ruleError);
    });
  };

  return {
    [Syntax.Str](node) {
      checkNode(node);
    },

    [Syntax.CodeBlock](node) {
      if (checkCode) {
        checkNode(node);
      }
    },

    [Syntax.Code](node) {
      if (checkCode) {
        checkNode(node);
      }
    },

    [Syntax.Image](node) {
      if (checkImage) {
        checkNode(node);
      }
    }

  };
};

module.exports = {
  linter: reporter,
  fixer: reporter
};
//# sourceMappingURL=textlint-rule-no-invalid-control-character.js.map