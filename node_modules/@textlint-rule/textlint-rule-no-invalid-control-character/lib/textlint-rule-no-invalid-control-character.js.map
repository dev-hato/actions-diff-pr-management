{"version":3,"sources":["../src/textlint-rule-no-invalid-control-character.js"],"names":["execall","require","unicodeEscape","str","replace","c","charCodeAt","toString","substr","getName","char","matchChar","CONTROL_CHARACTERS","find","CONTROL_CHARACTER","code","name","DEFAULT_OPTION","allow","checkCode","checkImage","reporter","context","options","Syntax","RuleError","getSource","fixer","report","undefined","checkNode","node","text","controlCharacterPattern","results","forEach","result","index","sub","some","allowChar","ruleError","fix","removeRange","Str","CodeBlock","Code","Image","module","exports","linter"],"mappings":"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","sourcesContent":["// MIT Â© 2017 azu\n\"use strict\";\n\nconst execall = require(\"execall\");\nimport { CONTROL_CHARACTERS } from \"./CONTROL_CHARACTERS\";\n\n/**\n * Convert char to \\uXXXX\n * @param {string} str\n * @return {string}\n */\nconst unicodeEscape = (str) => {\n    return str.replace(/./g, (c) => {\n        return `\\\\u${`000${c.charCodeAt(0).toString(16)}`.substr(-4)}`;\n    });\n};\n\nconst getName = (char) => {\n    const matchChar = CONTROL_CHARACTERS.find((CONTROL_CHARACTER) => CONTROL_CHARACTER.code === char);\n    if (!matchChar) {\n        return \"\";\n    }\n    return matchChar.name;\n};\n\nconst DEFAULT_OPTION = {\n    // Define allow char code like `\\u0019`\n    allow: [],\n    // Check code if it is true\n    checkCode: false,\n    // Check image title and alt text if it is true\n    checkImage: true\n};\n\nconst reporter = (context, options = {}) => {\n    const { Syntax, RuleError, getSource, fixer, report } = context;\n    const allow = options.allow || DEFAULT_OPTION.allow;\n    const checkCode = options.checkCode !== undefined ? options.checkCode : DEFAULT_OPTION.checkCode;\n    const checkImage = options.checkImage !== undefined ? options.checkImage : DEFAULT_OPTION.checkImage;\n    const checkNode = (node) => {\n        const text = getSource(node);\n        // Ignore \\r \\n \\t\n        const controlCharacterPattern = /([\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F])/g;\n        /**\n         * @type {Array<{match:string, sub:string[], index:number}>}\n         */\n        const results = execall(controlCharacterPattern, text);\n        results.forEach((result) => {\n            const index = result.index;\n            const char = result.sub[0];\n            // if allow the `char`, ignore it\n            if (allow.some((allowChar) => allowChar === char)) {\n                return;\n            }\n            const name = getName(char);\n            const ruleError = new RuleError(`Found invalid control character(${name} ${unicodeEscape(char)})`, {\n                index: index,\n                fix: fixer.removeRange([index, index + 1])\n            });\n            report(node, ruleError);\n        });\n    };\n    return {\n        [Syntax.Str](node) {\n            checkNode(node);\n        },\n        [Syntax.CodeBlock](node) {\n            if (checkCode) {\n                checkNode(node);\n            }\n        },\n        [Syntax.Code](node) {\n            if (checkCode) {\n                checkNode(node);\n            }\n        },\n        [Syntax.Image](node) {\n            if (checkImage) {\n                checkNode(node);\n            }\n        }\n    };\n};\n\nmodule.exports = {\n    linter: reporter,\n    fixer: reporter\n};\n"],"file":"textlint-rule-no-invalid-control-character.js"}