// LICENSE : MIT
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var visit = require('unist-util-visit');
/**
 * Ignore node manager that manager ignored ranges.
 *
 */


var IgnoreNodeManager =
/*#__PURE__*/
function () {
  function IgnoreNodeManager() {
    _classCallCheck(this, IgnoreNodeManager);

    /**
     * @type {[number,number][]}
     * @private
     */
    this._ignoredRangeList = [];
  }
  /**
   * @returns {(number)[][]}
   */


  _createClass(IgnoreNodeManager, [{
    key: "isIgnoredIndex",

    /**
     * |.......|
     * ^       ^
     * Ignored Range
     *
     *    |........|
     *    ^
     *  index
     * @param {number} index
     * @returns {boolean}
     */
    value: function isIgnoredIndex(index) {
      return this._ignoredRangeList.some(function (range) {
        var _range = _slicedToArray(range, 2),
            start = _range[0],
            end = _range[1];

        return start <= index && index < end;
      });
    }
    /**
     * @param {[number, number]} aRange
     * @returns {boolean}
     */

  }, {
    key: "isIgnoredRange",
    value: function isIgnoredRange(aRange) {
      var index = aRange[0];
      return this.isIgnoredIndex(index);
    }
    /**
     * @param {Object} node
     * @returns {boolean}
     */

  }, {
    key: "isIgnored",
    value: function isIgnored(node) {
      var index = node.index;
      return this.isIgnoredIndex(index);
    }
    /**
     * add node to ignore range list
     * @param {TxtNode} node
     */

  }, {
    key: "ignore",
    value: function ignore(node) {
      this.ignoreRange(node.range);
    }
    /**
     * add range to ignore range list
     * @param {[number, number]} range
     */

  }, {
    key: "ignoreRange",
    value: function ignoreRange(range) {
      this._ignoredRangeList.push(range);
    }
    /**
     * ignore children node of `node`,
     * if the children node has the type that is included in `ignoredNodeTypes`.
     * @param {TxtNode} targetNode
     * @param {string[]} ignoredNodeTypes
     */

  }, {
    key: "ignoreChildrenByTypes",
    value: function ignoreChildrenByTypes(targetNode, ignoredNodeTypes) {
      var _this = this;

      visit(targetNode, function (visitedNode) {
        if (ignoredNodeTypes.indexOf(visitedNode.type) !== -1) {
          _this.ignore(visitedNode);
        }
      });
    }
  }, {
    key: "ignoredRanges",
    get: function get() {
      return this._ignoredRangeList;
    }
  }]);

  return IgnoreNodeManager;
}();

exports.default = IgnoreNodeManager;
//# sourceMappingURL=IgnoreNodeManager.js.map