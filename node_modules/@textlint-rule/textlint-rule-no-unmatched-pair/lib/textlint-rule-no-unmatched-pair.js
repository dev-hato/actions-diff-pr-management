"use strict";

var _sentenceSplitter = require("sentence-splitter");

var _PairMaker = require("./parser/PairMaker.js");

var _SourceCode = require("./parser/SourceCode.js");

var _textlintRuleHelper = require("textlint-rule-helper");

// MIT Â© 2018 azu
var report = context => {
  var {
    Syntax,
    report,
    RuleError
  } = context;
  var ignoreNodeManager = new _textlintRuleHelper.IgnoreNodeManager();
  return {
    [Syntax.Paragraph](node) {
      var sentences = (0, _sentenceSplitter.splitAST)(node);
      ignoreNodeManager.ignoreChildrenByTypes(node, [Syntax.CodeBlock, Syntax.Code, Syntax.Link, Syntax.Strong, Syntax.Emphasis, Syntax.BlockQuote, Syntax.Comment]);
      sentences.children.filter(node => node.type === _sentenceSplitter.Syntax.Sentence).forEach(sentence => {
        var source = new _SourceCode.SourceCode(sentence.raw);
        var pairMaker = new _PairMaker.PairMaker();
        var sentenceIndex = sentence.range[0];

        while (source.canRead) {
          // If the character is in ignored range, skip it
          var characterIndex = sentenceIndex + source.index; // console.log(characterIndex, source.text[source.index], ignoreNodeManager.isIgnoredIndex(characterIndex));

          if (!ignoreNodeManager.isIgnoredIndex(characterIndex)) {
            pairMaker.mark(source);
          }

          source.peek();
        } // Report Error for each existing context keys


        source.contextLocations.forEach(contextLocation => {
          report(node, new RuleError("Not found pair character for ".concat(contextLocation.pairMark.start, ".\n                    \nYou should close this sentence with ").concat(contextLocation.pairMark.end, ".\nThis pair mark is called ").concat(contextLocation.pairMark.key, "."), {
            index: sentenceIndex - node.range[0] + contextLocation.index
          }));
        });
      });
    }

  };
};

module.exports = report;
//# sourceMappingURL=textlint-rule-no-unmatched-pair.js.map