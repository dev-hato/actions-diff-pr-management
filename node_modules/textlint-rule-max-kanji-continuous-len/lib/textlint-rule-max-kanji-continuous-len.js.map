{"version":3,"sources":["../src/textlint-rule-max-kanji-continuous-len.js"],"names":[],"mappings":";AACA;;AACA;;AACA;;;;AAEA,IAAM,cAAc,wEAApB;AACA,IAAM,iBAAiB;;;AAGnB,SAAK,CAHc;;AAKnB,WAAO;AALY,CAAvB;;AAQA,OAAO,OAAP,GAAiB,SAAS,QAAT,CAAkB,OAAlB,EAAqD;AAAA,QAA1B,OAA0B,yDAAhB,cAAgB;AAAA,QAC3D,MAD2D,GACZ,OADY,CAC3D,MAD2D;AAAA,QACnD,SADmD,GACZ,OADY,CACnD,SADmD;AAAA,QACxC,MADwC,GACZ,OADY,CACxC,MADwC;AAAA,QAChC,KADgC,GACZ,OADY,CAChC,KADgC;AAAA,QACzB,SADyB,GACZ,OADY,CACzB,SADyB;;AAElE,QAAM,SAAS,mCAAe,OAAf,CAAf;AACA,QAAM,YAAY,QAAQ,GAAR,IAAe,eAAe,GAAhD;AACA,QAAM,aAAa,QAAQ,KAAR,IAAiB,eAAe,KAAnD;AACA,+BACK,OAAO,GADZ,YACiB,IADjB,EACsB;AACd,YAAI,OAAO,WAAP,CAAmB,IAAnB,EAAyB,CAAC,OAAO,IAAR,EAAc,OAAO,KAArB,EAA4B,OAAO,UAAnC,EAA+C,OAAO,QAAtD,CAAzB,CAAJ,EAA+F;AAC3F;AACH;AACD,YAAM,OAAO,UAAU,IAAV,CAAb;AACA,8CAAqB,IAArB,EAA2B,WAA3B,EAAwC,OAAxC,CAAgD,gBAAmB;AAAA,gBAAjB,IAAiB,QAAjB,IAAiB;AAAA,gBAAX,KAAW,QAAX,KAAW;;;AAE3D,gBAAI,KAAK,MAAL,IAAe,SAAnB,EAA8B;AAC1B;AACH;;AAED,gBAAI,WAAW,OAAX,CAAmB,IAAnB,MAA6B,CAAC,CAAlC,EAAqC;AACjC;AACH;;AAED,gBAAM,YAAY,IAAI,SAAJ,UAAoB,YAAY,CAAhC,qBAAgD,IAAhD,EAAwD;AACtE;AADsE,aAAxD,CAAlB;AAGA,mBAAO,IAAP,EAAa,SAAb;AACH,SAdL;AAgBH,KAtBL;AAwBH,CA7BD","file":"textlint-rule-max-kanji-continuous-len.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nimport {RuleHelper} from \"textlint-rule-helper\";\nimport {matchCaptureGroupAll} from \"match-index\"\n\nconst KanjiRegExp = /((?:[々〇〻\\u3400-\\u9FFF\\uF900-\\uFAFF]|[\\uD840-\\uD87F][\\uDC00-\\uDFFF])+)/g;\nconst defaultOptions = {\n    // 連続できる最大の文字数\n    // If {current} > max(5), report Error.\n    max: 5,\n    // 許可する単語のリスト\n    allow: []\n};\n\nmodule.exports = function reporter(context, options = defaultOptions) {\n    const {Syntax, RuleError, report, fixer, getSource} = context;\n    const helper = new RuleHelper(context);\n    const maxLength = options.max || defaultOptions.max;\n    const allowWords = options.allow || defaultOptions.allow;\n    return {\n        [Syntax.Str](node){\n            if (helper.isChildNode(node, [Syntax.Link, Syntax.Image, Syntax.BlockQuote, Syntax.Emphasis])) {\n                return;\n            }\n            const text = getSource(node);\n            matchCaptureGroupAll(text, KanjiRegExp).forEach(({text, index}) => {\n                    // max以下であるなら無視する\n                    if (text.length <= maxLength) {\n                        return;\n                    }\n                    // 辞書にある単語は無視する\n                    if (allowWords.indexOf(text) !== -1) {\n                        return;\n                    }\n                    // maxより長い場合はエラーとなる\n                    const ruleError = new RuleError(`漢字が${maxLength + 1}つ以上連続しています: ${text}`, {\n                        index\n                    });\n                    report(node, ruleError);\n                }\n            );\n        }\n    }\n};"]}