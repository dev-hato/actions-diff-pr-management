var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
export const getItem = (storage, key) => {
    const item = storage.getItem(String(key));
    return item !== null ? JSON.parse(item) : undefined;
};
export const hasItem = (storage, key) => {
    return storage.getItem(String(key)) !== null;
};
export const setItem = (storage, key, value) => {
    // It is difference with IndexedDB implementation.
    // This behavior compatible with localStorage.
    if (value === undefined) {
        return deleteItem(storage, key);
    }
    return storage.setItem(String(key), JSON.stringify(value));
};
export const clearItem = (storage, kvsVersionKey, options) => {
    // TODO: kvsVersionKey is special type
    const currentVersion = getItem(storage, kvsVersionKey);
    // clear all
    storage.clear();
    // if option.force is true, does not restore metadata.
    if (options.force) {
        return;
    }
    // set kvs version again
    if (currentVersion !== undefined) {
        setItem(storage, kvsVersionKey, currentVersion);
    }
};
export const deleteItem = (storage, key) => {
    try {
        storage.removeItem(String(key));
        return true;
    }
    catch (_a) {
        return false;
    }
};
export function* createIterator(storage, kvsVersionKey) {
    for (let i = 0; i < storage.length; i++) {
        const key = storage.key(i);
        if (!key) {
            continue;
        }
        // skip meta key
        if (key === kvsVersionKey) {
            continue;
        }
        const value = getItem(storage, key);
        yield [key, value];
    }
}
const DEFAULT_KVS_VERSION = 1;
const openStorage = ({ storage, version, kvsVersionKey, onUpgrade }) => __awaiter(void 0, void 0, void 0, function* () {
    // kvsVersionKey is special type
    // first `oldVersion` is `0`
    let oldVersion = getItem(storage, kvsVersionKey);
    if (oldVersion === undefined) {
        setItem(storage, kvsVersionKey, DEFAULT_KVS_VERSION);
        // first `oldVersion` is `0`
        // https://github.com/azu/kvs/issues/8
        oldVersion = 0;
    }
    // if user set newVersion, upgrade it
    if (oldVersion !== version) {
        return Promise.resolve(onUpgrade({
            oldVersion,
            newVersion: version,
            storage
        })).then(() => {
            return storage;
        });
    }
    return storage;
});
const createStore = ({ storage, kvsVersionKey }) => {
    const store = {
        get(key) {
            return Promise.resolve().then(() => {
                return getItem(storage, key);
            });
        },
        has(key) {
            return Promise.resolve().then(() => {
                return hasItem(storage, key);
            });
        },
        set(key, value) {
            return Promise.resolve()
                .then(() => {
                return setItem(storage, key, value);
            })
                .then(() => {
                return store;
            });
        },
        clear() {
            return Promise.resolve().then(() => {
                return clearItem(storage, kvsVersionKey, { force: false });
            });
        },
        delete(key) {
            return Promise.resolve().then(() => {
                return deleteItem(storage, key);
            });
        },
        dropInstance() {
            return Promise.resolve().then(() => {
                return clearItem(storage, kvsVersionKey, { force: true });
            });
        },
        close() {
            // Noop function
            return Promise.resolve();
        },
        [Symbol.asyncIterator]() {
            const iterator = createIterator(storage, kvsVersionKey);
            return {
                next() {
                    return Promise.resolve().then(() => {
                        return iterator.next();
                    });
                }
            };
        }
    };
    return store;
};
export const kvsStorage = (options) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const { name, version, upgrade } = options, kvStorageOptions = __rest(options, ["name", "version", "upgrade"]);
    const kvsVersionKey = (_a = kvStorageOptions.kvsVersionKey) !== null && _a !== void 0 ? _a : "__kvs_version__";
    const storage = yield openStorage({
        storage: options.storage,
        version: options.version,
        onUpgrade: ({ oldVersion, newVersion, storage }) => {
            if (!options.upgrade) {
                return;
            }
            return options.upgrade({
                kvs: createStore({ storage, kvsVersionKey }),
                oldVersion,
                newVersion
            });
        },
        kvsVersionKey
    });
    return createStore({ storage, kvsVersionKey });
});
//# sourceMappingURL=storage.js.map