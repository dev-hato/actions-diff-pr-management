var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const debug = {
    enabled: false,
    log(...args) {
        if (!debug.enabled) {
            return;
        }
        console.log(...args);
    }
};
const openDB = ({ name, version, tableName, onUpgrade }) => {
    return new Promise((resolve, reject) => {
        const openRequest = indexedDB.open(name, version);
        openRequest.onupgradeneeded = function (event) {
            var _a;
            const oldVersion = event.oldVersion;
            const newVersion = (_a = event.newVersion) !== null && _a !== void 0 ? _a : version;
            const database = openRequest.result;
            try {
                // create table at first time
                if (!newVersion || newVersion <= 1) {
                    database.createObjectStore(tableName);
                }
            }
            catch (e) {
                reject(e);
            }
            // for drop instance
            // https://github.com/w3c/IndexedDB/issues/78
            // https://www.w3.org/TR/IndexedDB/#introduction
            database.onversionchange = () => {
                database.close();
            };
            // @ts-ignore
            event.target.transaction.oncomplete = () => {
                Promise.resolve(onUpgrade({
                    oldVersion,
                    newVersion,
                    database
                })).then(() => {
                    return resolve(database);
                });
            };
        };
        openRequest.onblocked = () => {
            reject(openRequest.error);
        };
        openRequest.onerror = function () {
            reject(openRequest.error);
        };
        openRequest.onsuccess = function () {
            const db = openRequest.result;
            resolve(db);
        };
    });
};
const dropInstance = (database, databaseName) => {
    return new Promise((resolve, reject) => {
        database.close();
        const request = indexedDB.deleteDatabase(databaseName);
        request.onupgradeneeded = (event) => {
            event.preventDefault();
            resolve();
        };
        request.onblocked = () => {
            debug.log("dropInstance:blocked", request);
            reject(request.error);
        };
        request.onerror = function () {
            debug.log("dropInstance:error", request);
            reject(request.error);
        };
        request.onsuccess = function () {
            resolve();
        };
    });
};
const getItem = (database, tableName, key) => {
    return new Promise((resolve, reject) => {
        const transaction = database.transaction(tableName, "readonly");
        const objectStore = transaction.objectStore(tableName);
        const request = objectStore.get(String(key));
        request.onsuccess = () => {
            resolve(request.result);
        };
        request.onerror = () => {
            reject(request.error);
        };
    });
};
const hasItem = (database, tableName, key) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
        const transaction = database.transaction(tableName, "readonly");
        const objectStore = transaction.objectStore(tableName);
        const request = objectStore.count(String(key));
        request.onsuccess = () => {
            resolve(request.result !== 0);
        };
        request.onerror = () => {
            reject(request.error);
        };
    });
});
const setItem = (database, tableName, key, value) => __awaiter(void 0, void 0, void 0, function* () {
    // If the value is undefined, delete the key
    // This behavior aim to align localStorage implementation
    if (value === undefined) {
        yield deleteItem(database, tableName, key);
        return;
    }
    return new Promise((resolve, reject) => {
        const transaction = database.transaction(tableName, "readwrite");
        const objectStore = transaction.objectStore(tableName);
        const request = objectStore.put(value, String(key));
        transaction.oncomplete = () => {
            resolve();
        };
        transaction.onabort = () => {
            reject(request.error ? request.error : transaction.error);
        };
        transaction.onerror = () => {
            reject(request.error ? request.error : transaction.error);
        };
    });
});
const deleteItem = (database, tableName, key) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
        const transaction = database.transaction(tableName, "readwrite");
        const objectStore = transaction.objectStore(tableName);
        const request = objectStore.delete(String(key));
        transaction.oncomplete = () => {
            resolve();
        };
        transaction.onabort = () => {
            reject(request.error ? request.error : transaction.error);
        };
        transaction.onerror = () => {
            reject(request.error ? request.error : transaction.error);
        };
    });
});
const clearItems = (database, tableName) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
        const transaction = database.transaction(tableName, "readwrite");
        const objectStore = transaction.objectStore(tableName);
        const request = objectStore.clear();
        transaction.oncomplete = () => {
            resolve();
        };
        transaction.onabort = () => {
            reject(request.error ? request.error : transaction.error);
        };
        transaction.onerror = () => {
            reject(request.error ? request.error : transaction.error);
        };
    });
});
const iterator = (database, tableName) => {
    const handleCursor = (request) => {
        return new Promise((resolve, reject) => {
            request.onsuccess = () => {
                const cursor = request.result;
                if (!cursor) {
                    return resolve({
                        done: true
                    });
                }
                return resolve({
                    done: false,
                    value: cursor
                });
            };
            request.onerror = () => {
                reject(request.error);
            };
        });
    };
    const transaction = database.transaction(tableName, "readonly");
    const objectStore = transaction.objectStore(tableName);
    const request = objectStore.openCursor();
    return {
        next() {
            return __awaiter(this, void 0, void 0, function* () {
                const { done, value } = yield handleCursor(request);
                if (!done) {
                    const storageKey = value === null || value === void 0 ? void 0 : value.key;
                    const storageValue = value === null || value === void 0 ? void 0 : value.value;
                    value === null || value === void 0 ? void 0 : value.continue();
                    return { done: false, value: [storageKey, storageValue] };
                }
                return { done: true, value: undefined };
            });
        }
    };
};
const createStore = ({ database, databaseName, tableName }) => {
    const store = {
        delete(key) {
            return deleteItem(database, tableName, key).then(() => true);
        },
        get(key) {
            return getItem(database, tableName, key);
        },
        has(key) {
            return hasItem(database, tableName, key);
        },
        set(key, value) {
            return setItem(database, tableName, key, value).then(() => store);
        },
        clear() {
            return clearItems(database, tableName);
        },
        dropInstance() {
            return dropInstance(database, databaseName);
        },
        close() {
            return Promise.resolve().then(() => {
                database.close();
            });
        },
        [Symbol.asyncIterator]() {
            return iterator(database, tableName);
        },
        __debug__database__: database
    };
    return store;
};
export const kvsIndexedDB = (options) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const { name, version, upgrade } = options, indexDBOptions = __rest(options, ["name", "version", "upgrade"]);
    if (indexDBOptions.debug) {
        debug.enabled = indexDBOptions.debug;
    }
    const tableName = (_a = indexDBOptions.tableName) !== null && _a !== void 0 ? _a : "kvs";
    const database = yield openDB({
        name,
        version,
        tableName,
        onUpgrade: ({ oldVersion, newVersion, database }) => {
            if (!upgrade) {
                return;
            }
            return upgrade({
                kvs: createStore({ database: database, tableName: tableName, databaseName: name }),
                oldVersion,
                newVersion
            });
        }
    });
    return createStore({ database: database, tableName: tableName, databaseName: name });
});
//# sourceMappingURL=index.js.map