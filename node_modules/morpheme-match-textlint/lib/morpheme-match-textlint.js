"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var morpheme_match_all_1 = require("morpheme-match-all");
/**
 * Replace all text
 */
var replaceAll = function (text, from, to) {
    return text.split(from).join(to);
};
/**
 * Replace text with tokens
 * @param text
 * @param expectedTokens
 * @param actualTokens
 * @returns {*}
 */
var replaceWithCaptureTokens = function (text, expectedTokens, actualTokens) {
    var resultText = text;
    expectedTokens.forEach(function (token, index) {
        // when the node has not `_capture`, does not replace it
        if (!token._capture) {
            return;
        }
        var actualToken = actualTokens[index];
        resultText = replaceAll(resultText, token._capture, actualToken.surface_form);
    });
    return resultText;
};
var _createMessage = function (_a) {
    var message = _a.message, matcherTokens = _a.matcherTokens, actualTokens = _a.actualTokens;
    if (!message) {
        throw new Error("message should defined");
    }
    return replaceWithCaptureTokens(message, matcherTokens, actualTokens);
};
var _createExpected = function (_a) {
    var expected = _a.expected, matcherTokens = _a.matcherTokens, actualTokens = _a.actualTokens;
    if (!expected) {
        return null;
    }
    return replaceWithCaptureTokens(expected, matcherTokens, actualTokens);
};
// FIXME: Want to support generics
// But some thing wrong
/**
 * create textlint matcher
 * @param options
 */
exports.createTextlintMatcher = function (options) {
    var matchAll = morpheme_match_all_1.createMatcher(options.dictionaries);
    var tokenize = options.tokenize;
    var createMessage = options.createMessage ? options.createMessage : _createMessage;
    var createExpected = options.createExpected ? options.createExpected : _createExpected;
    return function (text) {
        return tokenize(text).then(function (currentTokens) {
            var matchResults = matchAll(currentTokens);
            return matchResults.map(function (matchResult) {
                var firstToken = matchResult.tokens[0];
                var lastToken = matchResult.tokens[matchResult.tokens.length - 1];
                var firstWordIndex = Math.max(firstToken.word_position - 1, 0);
                var lastWorkIndex = Math.max(lastToken.word_position - 1, 0);
                // replace $1
                var message = createMessage({
                    dict: matchResult.dict,
                    message: matchResult.dict.message,
                    matcherTokens: matchResult.dict.tokens,
                    actualTokens: matchResult.tokens
                });
                var expected = createExpected({
                    dict: matchResult.dict,
                    expected: matchResult.dict.expected,
                    matcherTokens: matchResult.dict.tokens,
                    actualTokens: matchResult.tokens
                });
                return {
                    message: message,
                    expected: expected,
                    dict: matchResult.dict,
                    index: firstWordIndex,
                    range: [
                        firstWordIndex, lastWorkIndex + lastToken.surface_form.length
                    ]
                };
            });
        });
    };
};
//# sourceMappingURL=morpheme-match-textlint.js.map